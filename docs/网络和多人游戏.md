# Mindustry 网络和多人游戏

## 概述

Mindustry采用客户端-服务器架构实现多人游戏，支持大规模多人对战、实时状态同步和权威服务器模式。网络系统设计了高效的数据包协议、快照同步机制和防作弊系统，确保稳定的多人游戏体验。

## 网络架构设计

### 整体架构

```
客户端 (NetClient)     服务器 (NetServer)
      |                       |
      |------ TCP/UDP --------|
      |                       |
   渲染层                   权威逻辑
   UI交互               状态管理
   预测                 验证
   插值                 同步
```

### 协议栈

```
应用层: @Remote方法调用、游戏逻辑同步
传输层: 自定义数据包协议 (Packet)
网络层: TCP (可靠) + UDP (快照)
物理层: 底层网络实现 (Arc框架)
```

## 核心网络组件

### 1. Net - 网络抽象层

Net类是网络系统的基础，管理连接和数据包：

```java
public class Net {
    private static Seq<Prov<? extends Packet>> packetProvs = new Seq<>();
    private static ObjectIntMap<Class<?>> packetToId = new ObjectIntMap<>();

    private final Seq<Packet> packetQueue = new Seq<>();
    private final ObjectMap<Class<?>, Cons> clientListeners = new ObjectMap<>();
    private final ObjectMap<Class<?>, Cons2<NetConnection, Object>> serverListeners = new ObjectMap<>();
    private final NetProvider provider;

    // 数据包注册
    public static <T extends Packet> void registerPacket(Prov<T> cons) {
        packetProvs.add(cons);
        var packet = cons.get();
        packetClasses.add(packet.getClass());
        packetToId.put(packet.getClass(), packetProvs.size - 1);
    }

    // 数据包序列化
    public static byte getPacketId(Packet packet) {
        int id = packetToId.get(packet.getClass(), -1);
        if(id == -1) throw new ArcRuntimeException("Unknown packet type: " + packet.getClass());
        return (byte)id;
    }

    // 数据包反序列化
    public static <T extends Packet> T newPacket(byte id) {
        return ((Prov<T>)packetProvs.get(id & 0xff)).get();
    }

    // 客户端连接
    public void connectClient(String ip, int port, Runnable success) {
        provider.connectClient(ip, port, success);
    }

    // 服务器启动
    public void hostServer(int port) {
        provider.hostServer(port);
        server = true;
        active = true;
    }
}
```

### 2. NetServer - 服务器核心

NetServer管理服务器端的所有网络逻辑：

```java
public class NetServer implements ApplicationListener {
    // 快照同步配置
    private static final int maxSnapshotSize = 800;
    private static final float blockSyncTime = 60 * 6;  // 方块同步间隔
    private static final float healthSyncTime = 30;     // 血量同步间隔
    private static final float correctDist = tilesize * 14f; // 位置校正距离

    // 核心服务
    public Administration admins = new Administration();     // 管理员系统
    public CommandHandler clientCommands = new CommandHandler("/"); // 命令处理
    public TeamAssigner assigner;                          // 队伍分配器
    public ChatFormatter chatFormatter;                    // 聊天格式化

    private boolean closing = false;
    private Interval timer = new Interval(10);
    private IntSet buildHealthChanged = new IntSet();      // 血量变化建筑

    @Override
    public void update() {
        if(!active || !server) return;

        // 处理连接队列
        while(!connections.isEmpty()) {
            NetConnection connection = connections.removeFirst();
            String ip = connection.address;

            handleConnection(connection, ip);
        }

        // 同步世界状态
        if(timer.get(timerHealthSync, healthSyncTime)) {
            syncBuildingHealth();
        }

        if(timer.get(timerBlockSync, blockSyncTime)) {
            syncEntireWorld();
        }

        // 处理快照同步
        if(state.isGame()) {
            sync();
        }
    }

    // 玩家连接处理
    void handleConnection(NetConnection connection, String ip) {
        if(admins.isBlacklisted(ip)) {
            connection.kick(KickReason.banned);
            return;
        }

        if(Groups.player.size() >= maxConnections) {
            connection.kick(KickReason.playerLimit);
            return;
        }

        // 创建玩家实体
        Player player = Player.create();
        player.connection = connection;
        player.con = connection;
        player.name = "Player";
        player.add();

        // 分配队伍
        Team assignedTeam = assigner.assign(player, Groups.player);
        player.team(assignedTeam != null ? assignedTeam : state.rules.defaultTeam);

        Log.info("@ has connected. [@]", player.plainName(), connection.address);
    }

    // 快照同步
    void sync() {
        if(Groups.player.isEmpty()) return;

        // 创建世界快照
        try {
            dataWrites.clear();
            writeSnapshot(dataWrites);

            // 压缩快照数据
            byte[] snapshotData = dataWrites.toByteArray();
            byte[] compressed = compress(snapshotData);

            // 发送给所有客户端
            SnapshotPacket packet = new SnapshotPacket();
            packet.snapshot = compressed;

            for(Player player : Groups.player) {
                if(player.connection != null) {
                    player.connection.sendUDP(packet);
                }
            }

        } catch(Exception e) {
            Log.err("Error sending snapshot", e);
        }
    }

    // 写入世界快照
    void writeSnapshot(Writes buffer) {
        buffer.i(Groups.unit.size());

        // 写入所有单位状态
        for(Unit unit : Groups.unit) {
            if(unit.isRemote() || !unit.isValid()) continue;

            buffer.i(unit.id);
            buffer.f(unit.x);
            buffer.f(unit.y);
            buffer.f(unit.rotation);
            buffer.f(unit.vel.x);
            buffer.f(unit.vel.y);
            buffer.f(unit.health);
            buffer.b(unit.team.id);
        }

        // 写入建筑状态变化
        buffer.i(buildHealthChanged.size);
        for(int pos : buildHealthChanged.items) {
            Building build = world.build(pos);
            if(build != null) {
                buffer.i(pos);
                buffer.f(build.health);
                buffer.b(build.enabled ? 1 : 0);
            }
        }

        buildHealthChanged.clear();
    }
}
```

### 3. NetClient - 客户端核心

NetClient处理客户端的网络通信：

```java
public class NetClient implements ApplicationListener {
    private static final long entitySnapshotTimeout = 1000 * 20; // 快照超时
    private static final float dataTimeout = 60 * 30;            // 数据超时
    private static final float playerSyncTime = 4;               // 玩家同步频率

    private long ping;
    private boolean connecting = false;
    private boolean quiet = false;
    private float timeoutTime = 0f;
    private long lastSnapshotTimestamp;
    private int lastSent;

    // 实体同步状态
    private IntSet removed = new IntSet();                        // 已移除实体
    private ReusableByteInStream byteStream = new ReusableByteInStream();
    private DataInputStream dataStream = new DataInputStream(byteStream);

    public NetClient() {
        // 注册数据包处理器
        net.handleClient(Connect.class, this::handleConnect);
        net.handleClient(Disconnect.class, this::handleDisconnect);
        net.handleClient(WorldStream.class, this::handleWorldStream);
        net.handleClient(SnapshotPacket.class, this::handleSnapshot);
        net.handleClient(InvokePacket.class, this::handleInvoke);
    }

    @Override
    public void update() {
        if(!active) return;

        // 超时检测
        timeoutTime += Time.delta;
        if(timeoutTime > dataTimeout) {
            Log.err("Connection timeout");
            disconnectQuietly();
            return;
        }

        // 定期发送客户端状态
        if(timer.get(0, playerSyncTime) && player != null) {
            sendPlayerSync();
        }

        // 处理快照超时
        if(Time.millis() - lastSnapshotTimestamp > entitySnapshotTimeout) {
            Log.warn("Entity snapshot timeout");
        }

        sync();
    }

    // 连接到服务器
    void handleConnect(Connect packet) {
        Log.info("Connecting to server: @", packet.addressTCP);

        player.admin = false;
        reset();

        if(!net.client()) {
            Log.info("Connection canceled.");
            disconnectQuietly();
            return;
        }

        // 发送连接数据包
        ConnectPacket connectPacket = new ConnectPacket();
        connectPacket.name = player.name;
        connectPacket.locale = Core.settings.getString("locale");
        connectPacket.mods = mods.getModStrings();
        connectPacket.mobile = mobile;
        connectPacket.versionType = Version.type;
        connectPacket.buildVersion = Version.build;

        net.send(connectPacket);
    }

    // 处理快照数据
    void handleSnapshot(SnapshotPacket packet) {
        lastSnapshotTimestamp = Time.millis();
        timeoutTime = 0f;

        try {
            // 解压快照数据
            byte[] decompressed = decompress(packet.snapshot);
            byteStream.setBytes(decompressed);

            readSnapshot(dataStream);

        } catch(Exception e) {
            Log.err("Error reading snapshot", e);
        }
    }

    // 读取快照数据
    void readSnapshot(DataInputStream stream) throws IOException {
        int unitCount = stream.readInt();

        // 更新单位状态
        for(int i = 0; i < unitCount; i++) {
            int id = stream.readInt();
            float x = stream.readFloat();
            float y = stream.readFloat();
            float rotation = stream.readFloat();
            float velX = stream.readFloat();
            float velY = stream.readFloat();
            float health = stream.readFloat();
            byte teamId = stream.readByte();

            Unit unit = Groups.unit.getByID(id);
            if(unit != null && !unit.isLocal()) {
                // 插值更新位置
                unit.interpolate(x, y, rotation);
                unit.vel.set(velX, velY);
                unit.health = health;
                unit.team = Team.get(teamId);
            }
        }

        // 更新建筑状态
        int buildCount = stream.readInt();
        for(int i = 0; i < buildCount; i++) {
            int pos = stream.readInt();
            float health = stream.readFloat();
            boolean enabled = stream.readByte() == 1;

            Building build = world.build(pos);
            if(build != null) {
                build.health = health;
                build.enabled = enabled;
            }
        }
    }

    // 发送玩家同步数据
    void sendPlayerSync() {
        if(player == null) return;

        PlayerSyncPacket packet = new PlayerSyncPacket();
        packet.x = player.x;
        packet.y = player.y;
        packet.pointerX = input.mouseWorldX();
        packet.pointerY = input.mouseWorldY();
        packet.rotation = player.rotation;
        packet.baseRotation = player.baseRotation;
        packet.velocity = player.vel;
        packet.mining = player.mining();
        packet.boosting = player.boosting;
        packet.shooting = player.shooting;
        packet.chatting = ui.chatfrag.shown();

        net.send(packet);
    }
}
```

## 数据包系统

### 数据包基类

```java
public abstract class Packet {
    public boolean isImportant() { return true; }    // 是否为重要数据包
    public boolean isUnreliable() { return false; }  // 是否允许丢失
    public int getPriority() { return priorityNormal; } // 优先级

    public abstract void write(Writes write);
    public abstract void read(Reads read);
}
```

### 核心数据包类型

#### 1. 连接相关
```java
// 连接请求
public class ConnectPacket extends Packet {
    public String name;           // 玩家名称
    public String locale;         // 语言设置
    public String[] mods;         // MOD列表
    public boolean mobile;        // 是否移动设备
    public String versionType;    // 版本类型
    public int buildVersion;      // 构建版本

    @Override
    public void write(Writes write) {
        write.str(name);
        write.str(locale);
        write.i(mods.length);
        for(String mod : mods) write.str(mod);
        write.bool(mobile);
        write.str(versionType);
        write.i(buildVersion);
    }
}

// 断开连接
public class Disconnect extends Packet {
    public String reason;         // 断开原因

    @Override
    public void write(Writes write) {
        write.str(reason);
    }
}
```

#### 2. 世界同步
```java
// 世界数据流
public class WorldStream extends Packet {
    public byte[] stream;         // 世界数据流

    @Override
    public boolean isImportant() { return true; }

    @Override
    public void write(Writes write) {
        write.i(stream.length);
        write.b(stream);
    }
}

// 快照数据包
public class SnapshotPacket extends Packet {
    public byte[] snapshot;       // 压缩的快照数据

    @Override
    public boolean isUnreliable() { return true; } // 允许丢失

    @Override
    public void write(Writes write) {
        write.i(snapshot.length);
        write.b(snapshot);
    }
}
```

#### 3. 玩家同步
```java
// 玩家状态同步
public class PlayerSyncPacket extends Packet {
    public float x, y;            // 位置
    public float pointerX, pointerY; // 鼠标位置
    public float rotation, baseRotation; // 旋转角度
    public Vec2 velocity;         // 速度
    public Tile mining;           // 正在开采的地块
    public boolean boosting;      // 是否加速
    public boolean shooting;      // 是否射击
    public boolean chatting;      // 是否在聊天

    @Override
    public boolean isUnreliable() { return true; }

    @Override
    public void write(Writes write) {
        write.f(x);
        write.f(y);
        write.f(pointerX);
        write.f(pointerY);
        write.f(rotation);
        write.f(baseRotation);
        TypeIO.writeVec2(write, velocity);
        TypeIO.writeTile(write, mining);
        write.bool(boosting);
        write.bool(shooting);
        write.bool(chatting);
    }
}
```

### @Remote方法调用

通过@Remote注解自动生成RPC调用：

```java
public class Call {
    // 客户端调用服务器
    @Remote(called = Loc.server)
    public static void transferInventory(Player from, Building to) {
        if(from.team() == to.team && from.dst(to) <= itemTransferRange) {
            for(Item item : content.items()) {
                int amount = Math.min(from.core().items.get(item), to.acceptStack(item, Integer.MAX_VALUE, from));
                if(amount > 0) {
                    from.core().items.remove(item, amount);
                    to.handleStack(item, amount, from);
                }
            }
        }
    }

    // 服务器调用客户端
    @Remote(called = Loc.client, unreliable = true)
    public static void setPosition(Player player, float x, float y) {
        if(player != null) {
            player.set(x, y);
        }
    }

    // 广播给所有客户端
    @Remote(called = Loc.all)
    public static void sendChatMessage(Player from, String message) {
        if(from != null) {
            ui.chatfrag.addMessage(message, from.coloredName());
        }
    }
}
```

## 状态同步机制

### 快照系统

服务器定期发送世界快照：

```java
public class SnapshotSystem {
    private static final int snapshotRate = 20; // 20fps
    private ByteArrayOutputStream snapBuffer = new ByteArrayOutputStream();
    private DeflaterOutputStream compressor = new DeflaterOutputStream(snapBuffer);

    public void createSnapshot() {
        snapBuffer.reset();
        DataOutputStream out = new DataOutputStream(compressor);

        try {
            // 写入时间戳
            out.writeLong(Time.millis());

            // 写入单位状态
            writeUnitStates(out);

            // 写入建筑状态变化
            writeBuildingChanges(out);

            // 写入效果和粒子
            writeEffects(out);

            compressor.finish();
            byte[] data = snapBuffer.toByteArray();

            // 发送给所有客户端
            SnapshotPacket packet = new SnapshotPacket();
            packet.snapshot = data;
            Groups.player.each(p -> p.con.sendUDP(packet));

        } catch(IOException e) {
            Log.err("Snapshot creation failed", e);
        }
    }

    private void writeUnitStates(DataOutputStream out) throws IOException {
        // 只同步关键状态变化
        Seq<Unit> changedUnits = Groups.unit.select(u -> u.hasChanged());

        out.writeInt(changedUnits.size);
        for(Unit unit : changedUnits) {
            out.writeInt(unit.id);
            out.writeFloat(unit.x);
            out.writeFloat(unit.y);
            out.writeFloat(unit.rotation);
            out.writeFloat(unit.health);
            out.writeByte(unit.team.id);

            unit.markSynced(); // 标记已同步
        }
    }
}
```

### 插值系统

客户端使用插值平滑网络延迟：

```java
public class NetworkInterpolation {
    private static final float interpSpeed = 8f;

    public void interpolateUnit(Unit unit, float targetX, float targetY, float targetRot) {
        if(unit.isLocal()) return; // 本地单位不插值

        // 位置插值
        float dx = targetX - unit.x;
        float dy = targetY - unit.y;
        float dist = Mathf.sqrt(dx * dx + dy * dy);

        if(dist > maxTeleportDist) {
            // 距离过大，直接传送
            unit.set(targetX, targetY);
        } else {
            // 平滑插值
            unit.x = Mathf.lerp(unit.x, targetX, interpSpeed * Time.delta);
            unit.y = Mathf.lerp(unit.y, targetY, interpSpeed * Time.delta);
        }

        // 角度插值
        unit.rotation = Angles.lerpDelta(unit.rotation, targetRot, interpSpeed);
    }

    public void predictMovement(Unit unit) {
        if(!unit.isLocal()) return;

        // 预测移动以减少延迟感
        Vec2 predicted = Tmp.v1.set(unit.vel).scl(ping / 1000f);
        unit.x += predicted.x;
        unit.y += predicted.y;

        // 边界检查
        if(unit.x < 0 || unit.x > world.unitWidth() ||
           unit.y < 0 || unit.y > world.unitHeight()) {
            // 回滚预测
            unit.x -= predicted.x;
            unit.y -= predicted.y;
        }
    }
}
```

## 管理系统

### Administration类

```java
public class Administration {
    private final ObjectSet<String> banned = new ObjectSet<>();
    private final ObjectSet<String> admins = new ObjectSet<>();
    private final ObjectMap<String, String> whitelisted = new ObjectMap<>();

    // 权限检查
    public boolean isAdmin(String uuid, String usid) {
        return admins.contains(uuid) || admins.contains(usid);
    }

    public boolean isBanned(String uuid) {
        return banned.contains(uuid);
    }

    public boolean isWhitelisted(String uuid, String usid) {
        return whitelisted.containsKey(uuid) || whitelisted.containsKey(usid);
    }

    // 踢出玩家
    public void kickPlayer(String uuid, KickReason reason) {
        Player player = Groups.player.find(p -> p.uuid().equals(uuid));
        if(player != null) {
            player.kick(reason);
        }
    }

    // 禁言系统
    public void mutePlayer(String uuid, long duration) {
        mutedPlayers.put(uuid, Time.millis() + duration);
    }

    public boolean isMuted(String uuid) {
        Long muteEnd = mutedPlayers.get(uuid);
        return muteEnd != null && Time.millis() < muteEnd;
    }
}
```

### 反作弊系统

```java
public class AntiCheat {
    private static final float maxSpeed = 5f;          // 最大移动速度
    private static final float maxBuildRange = 220f;   // 最大建造距离
    private static final int maxActionsPerSecond = 10; // 每秒最大操作数

    private ObjectMap<String, Float> playerSpeeds = new ObjectMap<>();
    private ObjectMap<String, Integer> actionCounts = new ObjectMap<>();

    public boolean checkMovement(Player player, float newX, float newY) {
        float dist = Mathf.dst(player.x, player.y, newX, newY);
        float speed = dist / Time.delta;

        playerSpeeds.put(player.uuid(), speed);

        if(speed > maxSpeed) {
            Log.warn("@ is moving too fast: @", player.name, speed);
            // 回滚位置
            Call.setPosition(player, player.x, player.y);
            return false;
        }

        return true;
    }

    public boolean checkBuildDistance(Player player, float buildX, float buildY) {
        float dist = Mathf.dst(player.x, player.y, buildX, buildY);

        if(dist > maxBuildRange) {
            Log.warn("@ is building too far: @", player.name, dist);
            return false;
        }

        return true;
    }

    public boolean checkActionRate(Player player) {
        String uuid = player.uuid();
        int current = actionCounts.get(uuid, 0);

        if(current > maxActionsPerSecond) {
            Log.warn("@ is performing too many actions: @", player.name, current);
            return false;
        }

        actionCounts.put(uuid, current + 1);
        return true;
    }

    public void resetActionCounts() {
        actionCounts.clear();
    }
}
```

## 优化技术

### 数据压缩

```java
public class NetworkCompression {
    private static final LZ4Compressor compressor = LZ4Factory.fastestInstance().fastCompressor();
    private static final LZ4FastDecompressor decompressor = LZ4Factory.fastestInstance().fastDecompressor();

    public static byte[] compress(byte[] data) {
        return compressor.compress(data);
    }

    public static byte[] decompress(byte[] compressed, int originalLength) {
        return decompressor.decompress(compressed, originalLength);
    }

    // 增量压缩
    public static byte[] deltaCompress(byte[] current, byte[] previous) {
        if(previous == null) return compress(current);

        ByteArrayOutputStream delta = new ByteArrayOutputStream();
        DataOutputStream out = new DataOutputStream(delta);

        try {
            for(int i = 0; i < current.length; i++) {
                if(i >= previous.length || current[i] != previous[i]) {
                    out.writeInt(i);        // 位置
                    out.writeByte(current[i]); // 新值
                }
            }
        } catch(IOException e) {
            Log.err("Delta compression failed", e);
        }

        return compress(delta.toByteArray());
    }
}
```

### 带宽优化

```java
public class BandwidthOptimizer {
    private static final int maxPacketSize = 1200;     // MTU限制
    private static final float priorityThreshold = 0.1f; // 优先级阈值

    public void optimizeSnapshot(SnapshotPacket packet) {
        // 距离裁剪：只发送视野内的实体
        Player target = packet.target;
        float viewRange = target.range() * 2f;

        Seq<Unit> visibleUnits = Groups.unit.select(u ->
            u.within(target, viewRange) && target.team().data().hasUnits()
        );

        // 优先级排序：血量变化、战斗单位优先
        visibleUnits.sort(u -> {
            float priority = 0f;
            if(u.hasHealthChanged()) priority += 1f;
            if(u.isShooting()) priority += 0.5f;
            if(u.isPlayer()) priority += 0.3f;
            return -priority; // 降序
        });

        // 大小限制
        if(packet.estimatedSize() > maxPacketSize) {
            // 分批发送或降低精度
            reducePrecision(packet);
        }
    }

    private void reducePrecision(SnapshotPacket packet) {
        // 降低位置精度到0.1像素
        for(UnitSnapshot unit : packet.units) {
            unit.x = Math.round(unit.x * 10f) / 10f;
            unit.y = Math.round(unit.y * 10f) / 10f;
        }
    }
}
```

### 连接池管理

```java
public class ConnectionPool {
    private final Seq<NetConnection> available = new Seq<>();
    private final ObjectSet<NetConnection> active = new ObjectSet<>();
    private final int maxConnections = 256;

    public NetConnection acquire() {
        if(active.size >= maxConnections) {
            return null; // 连接池满
        }

        NetConnection conn = available.isEmpty() ?
            new NetConnection() : available.pop();

        active.add(conn);
        return conn;
    }

    public void release(NetConnection connection) {
        if(active.remove(connection)) {
            connection.reset();
            available.add(connection);
        }
    }

    public void cleanup() {
        // 清理断开的连接
        active.removeAll(conn -> !conn.isConnected());
    }
}
```

这个网络系统为Mindustry提供了高效、稳定的多人游戏支持，通过权威服务器、快照同步和反作弊机制确保公平的游戏环境，支持大规模多人对战和复杂的实时交互。