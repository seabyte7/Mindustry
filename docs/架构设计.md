# Mindustry 架构设计

## 总体架构概述

Mindustry采用分层模块化架构，基于ApplicationListener生命周期模式构建。整个游戏围绕事件驱动的设计，各模块通过事件总线进行通信，确保低耦合和高扩展性。

## 核心架构模式

### 1. ApplicationListener生命周期模式

每个核心模块都实现ApplicationListener接口，提供统一的生命周期管理：

```java
public interface ApplicationListener {
    default void init() {}          // 模块初始化
    default void update() {}        // 每帧更新（60fps）
    default void resize(int width, int height) {}  // 窗口调整
    default void pause() {}         // 游戏暂停
    default void resume() {}        // 游戏恢复
    default void dispose() {}       // 资源清理
}
```

### 2. 六大核心模块

#### Logic模块 - 游戏逻辑核心
```java
public class Logic implements ApplicationListener
```

**职责范围：**
- 游戏状态管理（波次、胜负、时间）
- 实体逻辑更新（单位移动、战斗、AI）
- 世界模拟（物理、碰撞、伤害计算）
- 事件响应（方块摧毁、建筑完成等）

**核心功能：**
- **波次系统**：管理敌人生成、波次进度、难度调节
- **战斗逻辑**：处理单位间的攻击、伤害、状态效果
- **资源流动**：管理物品在传送带、管道中的流动
- **建筑逻辑**：处理建筑的生产、消耗、功能逻辑

**设计特点：**
- 只处理逻辑，不涉及渲染和UI
- 通过事件系统通知其他模块
- 严格的性能优化（零分配原则）

#### Control模块 - 用户交互控制
```java
public class Control implements ApplicationListener, Loadable
```

**职责范围：**
- 输入处理（键盘、鼠标、触摸）
- 存档管理（保存、加载、自动保存）
- 声音控制（音效、音乐播放）
- 用户界面控制

**核心组件：**
```java
public class Control {
    public Saves saves;              // 存档系统
    public SoundControl sound;       // 音频控制
    public InputHandler input;       // 输入处理
    public AttackIndicators indicators; // 攻击指示器
}
```

**功能详解：**
- **存档系统**：支持多存档槽位、自动保存、存档压缩
- **输入映射**：支持自定义键位、手势识别、多平台适配
- **音频管理**：支持3D空间音效、音量控制、音频缓存

#### Renderer模块 - 渲染管理器
```java
public class Renderer implements ApplicationListener
```

**渲染管道：**
```java
public class Renderer {
    public final BlockRenderer blocks;      // 方块渲染
    public final FogRenderer fog;          // 迷雾渲染
    public final MinimapRenderer minimap;  // 小地图
    public final OverlayRenderer overlays; // 覆盖层（UI元素）
    public final LightRenderer lights;     // 光照系统
    public final Pixelator pixelator;      // 像素化效果
    public PlanetRenderer planets;         // 行星渲染
}
```

**高级渲染功能：**
- **Bloom效果**：光晕特效，提升视觉效果
- **动态光照**：实时光影计算，支持颜色光源
- **迷雾战争**：探索区域的视野限制
- **粒子系统**：爆炸、烟雾、火花等特效
- **着色器系统**：自定义渲染效果

#### UI模块 - 用户界面
```java
public class UI implements ApplicationListener, Loadable
```

**UI架构：**
```java
// Fragment系统 - 游戏内UI组件
public MenuFragment menufrag;        // 主菜单
public HudFragment hudfrag;          // 游戏内HUD
public ChatFragment chatfrag;        // 聊天界面
public MinimapFragment minimapfrag;  // 小地图

// Dialog系统 - 弹窗对话框
public SettingsMenuDialog settings; // 设置菜单
public PausedDialog paused;          // 暂停菜单
public ResearchDialog research;      // 科技树
public SchematicsDialog schematics;  // 蓝图系统
```

**设计特点：**
- 基于Scene2D UI框架
- 响应式布局，支持多分辨率
- 模块化组件设计
- 支持主题和本地化

#### NetServer和NetClient - 网络通信
```java
public class NetServer implements ApplicationListener // 服务器
public class NetClient implements ApplicationListener // 客户端
```

**网络架构：**
- **数据包系统**：自定义协议，支持压缩和加密
- **状态同步**：增量同步，减少带宽消耗
- **权限管理**：管理员系统，反作弊机制
- **大厅系统**：服务器列表，房间管理

## 事件系统设计

### 事件类型分类

#### 1. 高频触发事件（Trigger）
```java
public enum Trigger {
    update,                 // 每帧更新
    draw,                   // 渲染帧
    shock,                  // 电击效果
    turretCool,            // 炮塔冷却
    unitCommandChange,      // 单位指令变更
    // ... 58种不同的触发器
}
```

#### 2. 生命周期事件
```java
public static class WinEvent {}      // 游戏胜利
public static class LoseEvent {}     // 游戏失败
public static class PlayEvent {}     // 开始游戏
public static class PauseEvent {}    // 游戏暂停
public static class ResetEvent {}    // 游戏重置
```

#### 3. 世界变化事件
```java
public static class BlockDestroyEvent {
    public Tile tile;       // 被摧毁的位置
    public Building build;  // 被摧毁的建筑
    public Team team;       // 摧毁者的队伍
}

public static class BlockBuildEndEvent {
    public Tile tile;       // 建造位置
    public Team team;       // 建造队伍
    public boolean breaking; // 是否为拆除
}
```

### 事件处理机制

```java
// 事件监听注册
Events.on(BlockDestroyEvent.class, event -> {
    // 处理方块摧毁逻辑
    if(state.rules.ghostBlocks) {
        event.tile.build.addPlan(true); // 添加重建计划
    }
});

// 事件触发
Events.fire(new BlockDestroyEvent(tile, build, team));

// 高频事件触发
Events.fire(Trigger.update);
```

## 游戏状态管理

### GameState类详解

```java
public class GameState {
    // 波次系统
    public int wave = 1;              // 当前波次
    public float wavetime;            // 波次倒计时

    // 时间系统
    public double tick;               // 逻辑时钟
    public long updateId;             // 更新计数器

    // 游戏状态
    public boolean gameOver = false;   // 游戏结束
    public boolean won = false;        // 是否胜利
    public State state = State.menu;   // 当前状态

    // 世界数据
    public Map map;                   // 当前地图
    public Rules rules;               // 游戏规则
    public Teams teams;               // 队伍数据
    public GameStats stats;           // 游戏统计
}
```

### 状态机设计

```java
public enum State {
    menu,      // 主菜单
    playing,   // 游戏中
    paused,    // 暂停
}

// 状态转换会触发事件
public void set(State newState) {
    Events.fire(new StateChangeEvent(state, newState));
    state = newState;
}
```

## 资源和资产管理

### 异步资产加载

```java
// ClientLauncher中的加载流程
public void setup() {
    // 1. 基础系统初始化
    loadLogger();
    Time.setDeltaProvider(...);

    // 2. 核心资产加载
    assets.load("sprites/sprites.aatls", TextureAtlas.class);
    assets.load("maps", Map.class);

    // 3. 内容系统加载
    assets.loadRun("contentcreate", Content.class, () -> {
        content.createBaseContent();    // 基础内容
        mods.loadScripts();            // MOD脚本
        content.createModContent();     // MOD内容
    });

    // 4. 模块初始化
    add(logic = new Logic());
    add(control = new Control());
    add(renderer = new Renderer());
    add(ui = new UI());
}
```

### 资产热重载

- 开发模式下支持资产热重载
- 精灵图集自动重新打包
- 脚本文件实时更新

## 性能优化架构

### 1. 对象池系统
```java
// 使用Pools避免频繁分配
Bullet bullet = Pools.obtain(Bullet.class);
// 使用完毕后回收
Pools.free(bullet);
```

### 2. 静态缓存变量
```java
// Tmp类提供临时变量
Vec2 pos = Tmp.v1.set(x, y);
Rect bounds = Tmp.r1.set(x, y, width, height);
```

### 3. 专用集合类型
```java
// 避免装箱，使用原生类型集合
IntSeq numbers = new IntSeq();      // 替代ArrayList<Integer>
ObjectMap<String, Block> blocks;    // 替代HashMap<String, Block>
```

### 4. 渲染优化
- 批量渲染（SpriteBatch）
- 视锥剔除（Frustum Culling）
- 层级渲染（Layer-based Rendering）
- 动态纹理图集

## 多线程架构

### 主线程职责
- 游戏逻辑更新
- 渲染管道执行
- UI事件处理

### 异步线程
```java
// 异步执行器
public AsyncCore asyncCore;

// 异步任务示例
asyncCore.submit(() -> {
    // 地图生成
    // 文件加载
    // 网络通信
});
```

## 错误处理和调试

### 日志系统
```java
Log.info("游戏启动完成");
Log.warn("警告信息");
Log.err("错误信息", exception);
```

### 调试工具
- 内置控制台（命令行界面）
- 实时性能监控
- 内存使用统计
- 网络延迟显示

## 平台适配架构

### 平台抽象层
```java
public interface Platform {
    String getUUID();              // 获取设备ID
    void showFileChooser(...);     // 文件选择器
    void shareFile(Fi file);       // 文件分享
    void openURI(String URI);      // 打开链接
}
```

### 平台特定实现
- **Desktop**: 完整功能实现
- **Android**: 移动设备优化
- **iOS**: 苹果生态集成
- **Server**: 最小化依赖

## 扩展点设计

### 1. MOD系统集成点
- 内容注册阶段
- 事件监听器
- 脚本执行环境

### 2. 自定义渲染器
- 环境渲染器（EnvRenderer）
- 自定义背景
- 特效插件

### 3. 网络协议扩展
- 自定义数据包
- 插件通信协议

这种架构设计确保了Mindustry的高性能、可扩展性和跨平台兼容性，为游戏的持续发展提供了坚实的技术基础。