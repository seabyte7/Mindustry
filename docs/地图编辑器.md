# 地图编辑器

Mindustry内置了功能强大的地图编辑器，支持实时地图创建、多种编辑工具、程序化地图生成、撤销重做系统和多格式导入导出，为玩家和开发者提供了完整的地图制作解决方案。

## 核心架构设计

### 1. 地图编辑器架构层次

```
┌─────────────────────────────────────┐
│         MapEditorDialog             │
│         (主编辑器UI)                 │
├─────────────────────────────────────┤
│    MapView    │    MapEditor        │
│   (编辑视图)   │   (编辑器逻辑)       │
├─────────────────┬─────────────────────┤
│   EditorTool    │  DrawOperation      │
│   (编辑工具)     │  (操作系统)          │
├─────────────────┼─────────────────────┤
│  MapRenderer    │  OperationStack     │
│   (地图渲染)     │  (撤销重做)          │
├─────────────────┴─────────────────────┤
│         MapGenerateDialog           │
│         (程序化生成)                  │
└─────────────────────────────────────┘
```

### 2. 关键类说明

| 类名 | 文件位置 | 职责 |
|------|----------|------|
| `MapEditor` | `mindustry/editor/MapEditor.java` | 核心编辑器逻辑，管理地图状态和操作 |
| `MapEditorDialog` | `mindustry/editor/MapEditorDialog.java` | 主编辑器UI对话框 |
| `MapView` | `mindustry/editor/MapView.java` | 编辑视图，处理用户输入和显示 |
| `EditorTool` | `mindustry/editor/EditorTool.java` | 编辑工具枚举（画笔、橡皮擦等） |
| `DrawOperation` | `mindustry/editor/DrawOperation.java` | 绘制操作记录，支持撤销重做 |
| `OperationStack` | `mindustry/editor/OperationStack.java` | 操作栈管理 |
| `MapGenerateDialog` | `mindustry/editor/MapGenerateDialog.java` | 程序化地图生成对话框 |
| `EditorTile` | `mindustry/editor/EditorTile.java` | 编辑器专用瓦片类 |

## 核心编辑器逻辑 (MapEditor)

### 1. 地图编辑器基础架构

```java
public class MapEditor{
    public static final float[] brushSizes = {1, 1.5f, 2, 3, 4, 5, 9, 15, 20}; // 画笔大小

    public StringMap tags = new StringMap();              // 地图标签
    public MapRenderer renderer = new MapRenderer();      // 地图渲染器

    // 编辑状态
    private OperationStack stack = new OperationStack();  // 操作栈
    private DrawOperation currentOp;                      // 当前操作
    private boolean loading;                              // 是否正在加载

    // 编辑参数
    public float brushSize = 1;                          // 画笔大小
    public int rotation;                                 // 方块旋转
    public Block drawBlock = Blocks.stone;               // 绘制方块
    public Team drawTeam = Team.sharded;                 // 绘制队伍
}
```

### 2. 地图初始化和管理

```java
// 创建新地图
public void beginEdit(int width, int height){
    reset();
    loading = true;
    createTiles(width, height);      // 创建瓦片数组
    renderer.resize(width, height);   // 调整渲染器大小
    loading = false;
}

// 从现有地图开始编辑
public void beginEdit(Map map){
    reset();
    loading = true;
    tags.putAll(map.tags);           // 复制地图标签
    load(() -> MapIO.loadMap(map, context)); // 加载地图数据
    renderer.resize(width(), height());
    loading = false;
}

// 从图像创建地图
public void beginEdit(Pixmap pixmap){
    reset();
    createTiles(pixmap.width, pixmap.height);
    load(() -> MapIO.readImage(pixmap, tiles())); // 从图像读取地图
    renderer.resize(width(), height());
}

// 创建瓦片数组（默认石头地板）
private void createTiles(int width, int height){
    Tiles tiles = world.resize(width, height);
    for(int x = 0; x < width; x++){
        for(int y = 0; y < height; y++){
            tiles.set(x, y, new EditorTile(x, y, Blocks.stone.id, (short)0, (short)0));
        }
    }
}
```

### 3. 绘制系统

```java
// 主绘制方法
public void drawBlocks(int x, int y, boolean square, boolean forceOverlay, Boolf<Tile> tester){
    if(drawBlock.isMultiblock()){
        // 多块建筑特殊处理
        x = Mathf.clamp(x, (drawBlock.size - 1) / 2, width() - drawBlock.size / 2 - 1);
        y = Mathf.clamp(y, (drawBlock.size - 1) / 2, height() - drawBlock.size / 2 - 1);
        if(!hasOverlap(x, y)){
            tile(x, y).setBlock(drawBlock, drawTeam, rotation);
        }
    }else{
        boolean isFloor = drawBlock.isFloor() && drawBlock != Blocks.air;

        Cons<Tile> drawer = tile -> {
            if(!tester.get(tile)) return;

            if(isFloor){
                // 地板绘制
                if(forceOverlay){
                    tile.setOverlay(drawBlock.asFloor());
                }else{
                    if(!(drawBlock.asFloor().wallOre && !tile.block().solid)){
                        tile.setFloor(drawBlock.asFloor());
                    }
                }
            }else if(!(tile.block().isMultiblock() && !drawBlock.isMultiblock())){
                // 建筑绘制
                if(drawBlock.rotate && tile.build != null && tile.build.rotation != rotation){
                    addTileOp(TileOp.get(tile.x, tile.y, (byte)OpType.rotation.ordinal(), (byte)rotation));
                }
                tile.setBlock(drawBlock, drawTeam, rotation);
            }
        };

        // 选择绘制形状
        if(square){
            drawSquare(x, y, drawer);
        }else{
            drawCircle(x, y, drawer);
        }
    }
}

// 圆形绘制
public void drawCircle(int x, int y, Cons<Tile> drawer){
    int clamped = (int)brushSize;
    for(int rx = -clamped; rx <= clamped; rx++){
        for(int ry = -clamped; ry <= clamped; ry++){
            if(Mathf.within(rx, ry, brushSize - 0.5f + 0.0001f)){
                int wx = x + rx, wy = y + ry;
                if(wx < 0 || wy < 0 || wx >= width() || wy >= height()) continue;
                drawer.get(tile(wx, wy));
            }
        }
    }
}

// 方形绘制
public void drawSquare(int x, int y, Cons<Tile> drawer){
    int clamped = (int)brushSize;
    for(int rx = -clamped; rx <= clamped; rx++){
        for(int ry = -clamped; ry <= clamped; ry++){
            int wx = x + rx, wy = y + ry;
            if(wx < 0 || wy < 0 || wx >= width() || wy >= height()) continue;
            drawer.get(tile(wx, wy));
        }
    }
}
```

### 4. 地图调整和工具功能

```java
// 地图大小调整
public void resize(int width, int height, int shiftX, int shiftY){
    clearOp();
    Tiles previous = world.tiles;
    int offsetX = (width() - width) / 2 - shiftX;
    int offsetY = (height() - height) / 2 - shiftY;
    loading = true;

    world.clearBuildings();
    Tiles tiles = world.tiles = new Tiles(width, height);

    // 复制现有瓦片到新位置
    for(int x = 0; x < width; x++){
        for(int y = 0; y < height; y++){
            int px = offsetX + x, py = offsetY + y;
            if(previous.in(px, py)){
                tiles.set(x, y, previous.getn(px, py));
                Tile tile = tiles.getn(x, y);

                // 保存配置
                Object config = null;
                if(tile.build != null && tile.isCenter()){
                    config = tile.build.config();
                }

                // 更新坐标
                tile.x = (short)x;
                tile.y = (short)y;

                // 重新应用配置
                if(tile.build != null && tile.isCenter()){
                    tile.build.x = x * tilesize + tile.block().offset;
                    tile.build.y = y * tilesize + tile.block().offset;

                    if(config != null){
                        Object out = BuildPlan.pointConfig(tile.block(), config, p -> {
                            if(!tile.build.block.ignoreResizeConfig){
                                p.sub(offsetX, offsetY);
                            }
                        });
                        if(out != config){
                            tile.build.configureAny(out);
                        }
                    }
                }
            }else{
                tiles.set(x, y, new EditorTile(x, y, Blocks.stone.id, (short)0, (short)0));
            }
        }
    }

    renderer.resize(width, height);
    loading = false;
}

// 自动添加悬崖
public void addCliffs(){
    for(Tile tile : world.tiles){
        if(!tile.block().isStatic() || tile.block() == Blocks.cliff) continue;

        int rotation = 0;
        // 检查周围8个方向
        for(int i = 0; i < 8; i++){
            Tile other = world.tiles.get(tile.x + Geometry.d8[i].x, tile.y + Geometry.d8[i].y);
            if(other != null && !other.block().isStatic()){
                rotation |= (1 << i);
            }
        }

        if(rotation != 0){
            tile.setBlock(Blocks.cliff);
        }
        tile.data = (byte)rotation;
    }

    // 清除非悬崖的静态方块
    for(Tile tile : world.tiles){
        if(tile.block() != Blocks.cliff && tile.block().isStatic()){
            tile.setBlock(Blocks.air);
        }
    }
}
```

## 编辑工具系统 (EditorTool)

### 1. 工具类型定义

```java
public enum EditorTool{
    zoom(KeyCode.v),                     // 缩放工具
    pick(KeyCode.i){                     // 拾取工具
        public void touched(int x, int y){
            if(!Structs.inBounds(x, y, editor.width(), editor.height())) return;
            Tile tile = editor.tile(x, y);
            // 拾取瓦片上的方块作为绘制方块
            editor.drawBlock = tile.block() == Blocks.air || !tile.block().inEditor
                             ? tile.overlay() == Blocks.air ? tile.floor() : tile.overlay()
                             : tile.block();
        }
    },

    line(KeyCode.l, "replace", "orthogonal"){   // 直线工具
        @Override
        public void touchedLine(int x1, int y1, int x2, int y2){
            // 正交模式：限制为水平或垂直线
            if(mode == 1){
                if(Math.abs(x2 - x1) > Math.abs(y2 - y1)){
                    y2 = y1;
                }else{
                    x2 = x1;
                }
            }

            // 使用Bresenham算法绘制直线
            Bresenham2.line(x1, y1, x2, y2, (x, y) -> {
                if(mode == 0){
                    editor.drawBlocksReplace(x, y);  // 替换模式
                }else{
                    editor.drawBlocks(x, y);         // 正常模式
                }
            });
        }
    },

    pencil(KeyCode.b, "replace", "square", "drawteams"){ // 画笔工具
        {
            edit = true;
            draggable = true;
        }

        @Override
        public void touched(int x, int y){
            if(mode == -1){
                editor.drawBlocks(x, y);                    // 正常模式
            }else if(mode == 0){
                editor.drawBlocksReplace(x, y);             // 替换模式
            }else if(mode == 1){
                editor.drawBlocks(x, y, true, false, tile -> true); // 方形模式
            }else if(mode == 2){
                editor.drawCircle(x, y, tile -> tile.setTeam(editor.drawTeam)); // 队伍绘制
            }else if(mode == 3){
                editor.drawBlocks(x, y, false, true, tile -> tile.floor().isLiquid); // 液体覆盖
            }
        }
    };

    /** 所有工具的数组 */
    public static final EditorTool[] all = values();

    /** 工具的可选模式 */
    public final String[] altModes;
    /** 激活工具的快捷键 */
    public KeyCode key = KeyCode.unset;
    /** 当前可选模式。-1为标准模式 */
    public int mode = -1;
    /** 工具是否会修改画布 */
    public boolean edit;
    /** 工具是否支持拖拽 */
    public boolean draggable;
}
```

### 2. 橡皮擦工具

```java
eraser(KeyCode.e, "eraseores"){
    {
        edit = true;
        draggable = true;
    }

    @Override
    public void touched(int x, int y){
        editor.drawCircle(x, y, tile -> {
            if(mode == -1){
                // 删除方块
                tile.remove();
            }else if(mode == 0){
                // 删除矿物覆盖
                tile.clearOverlay();
            }
        });
    }
}
```

### 3. 填充工具

```java
fill(KeyCode.g, "replaceall", "fillteams", "fillerase"){
    {
        edit = true;
    }

    IntSeq stack = new IntSeq(); // 洪水填充栈

    @Override
    public void touched(int x, int y){
        if(!Structs.inBounds(x, y, editor.width(), editor.height())) return;
        Tile tile = editor.tile(x, y);
        if(tile == null) return;

        if(mode == 0 || mode == -1){
            // 标准填充模式
            Boolf<Tile> tester;
            Cons<Tile> setter;

            if(editor.drawBlock.isOverlay()){
                Block dest = tile.overlay();
                if(dest == editor.drawBlock) return;
                tester = t -> t.overlay() == dest && (t.floor().hasSurface() || !t.floor().needsSurface);
                setter = t -> t.setOverlay(editor.drawBlock);
            }else if(editor.drawBlock.isFloor()){
                Block dest = tile.floor();
                if(dest == editor.drawBlock) return;
                tester = t -> t.floor() == dest;
                setter = t -> t.setFloorUnder(editor.drawBlock.asFloor());
            }else{
                Block dest = tile.block();
                if(dest == editor.drawBlock) return;
                tester = t -> t.block() == dest;
                setter = t -> t.setBlock(editor.drawBlock, editor.drawTeam);
            }

            fill(x, y, mode == 0, tester, setter);
        }else if(mode == 1){
            // 队伍填充模式
            if(tile.synthetic()){
                Team dest = tile.team();
                if(dest == editor.drawTeam) return;
                fill(x, y, true, t -> t.getTeamID() == dest.id && t.synthetic(),
                     t -> t.setTeam(editor.drawTeam));
            }
        }
    }

    // 洪水填充算法实现
    void fill(int x, int y, boolean replace, Boolf<Tile> tester, Cons<Tile> filler){
        int width = editor.width(), height = editor.height();

        if(replace){
            // 全局替换
            for(int cx = 0; cx < width; cx++){
                for(int cy = 0; cy < height; cy++){
                    Tile tile = editor.tile(cx, cy);
                    if(tester.get(tile)){
                        filler.get(tile);
                    }
                }
            }
        }else{
            // 洪水填充
            stack.clear();
            stack.add(Point2.pack(x, y));

            try{
                while(stack.size > 0 && stack.size < width*height){
                    int popped = stack.pop();
                    x = Point2.x(popped);
                    y = Point2.y(popped);

                    int x1 = x;
                    while(x1 >= 0 && tester.get(editor.tile(x1, y))) x1--;
                    x1++;

                    boolean spanAbove = false, spanBelow = false;
                    while(x1 < width && tester.get(editor.tile(x1, y))){
                        filler.get(editor.tile(x1, y));

                        // 检查上方
                        if(!spanAbove && y > 0 && tester.get(editor.tile(x1, y - 1))){
                            stack.add(Point2.pack(x1, y - 1));
                            spanAbove = true;
                        }else if(spanAbove && !tester.get(editor.tile(x1, y - 1))){
                            spanAbove = false;
                        }

                        // 检查下方
                        if(!spanBelow && y < height - 1 && tester.get(editor.tile(x1, y + 1))){
                            stack.add(Point2.pack(x1, y + 1));
                            spanBelow = true;
                        }else if(spanBelow && y < height - 1 && !tester.get(editor.tile(x1, y + 1))){
                            spanBelow = false;
                        }
                        x1++;
                    }
                }
                stack.clear();
            }catch(OutOfMemoryError e){
                // 内存不足时的处理
                stack = null;
                System.gc();
                stack = new IntSeq();
            }
        }
    }
}
```

### 4. 喷洒工具

```java
spray(KeyCode.r, "replace"){
    final double chance = 0.012; // 12%概率

    {
        edit = true;
        draggable = true;
    }

    @Override
    public void touched(int x, int y){
        if(editor.drawBlock.isFloor()){
            // 地板喷洒
            editor.drawCircle(x, y, tile -> {
                if(Mathf.chance(chance)){
                    tile.setFloor(editor.drawBlock.asFloor());
                }
            });
        }else if(mode == 0){
            // 替换模式喷洒（不影响空气）
            editor.drawBlocks(x, y, tile -> Mathf.chance(chance) && tile.block() != Blocks.air);
        }else{
            // 正常喷洒
            editor.drawBlocks(x, y, tile -> Mathf.chance(chance));
        }
    }
}
```

## 编辑视图系统 (MapView)

### 1. 视图控制和输入处理

```java
public class MapView extends Element implements GestureListener{
    EditorTool tool = EditorTool.pencil;   // 当前工具
    private float offsetx, offsety;        // 视图偏移
    private float zoom = 1f;               // 缩放级别
    private boolean grid = false;          // 网格显示
    private Vec2[][] brushPolygons = new Vec2[MapEditor.brushSizes.length][0]; // 画笔多边形

    // 输入状态
    boolean drawing;
    int lastx, lasty;                      // 上次坐标
    int startx, starty;                    // 起始坐标
    float mousex, mousey;                  // 鼠标坐标
}
```

### 2. 鼠标和触摸输入处理

```java
addListener(new InputListener(){
    @Override
    public boolean touchDown(InputEvent event, float x, float y, int pointer, KeyCode button){
        if(pointer != 0) return false;

        if(!mobile && button != KeyCode.mouseLeft && button != KeyCode.mouseMiddle && button != KeyCode.mouseRight){
            return true;
        }

        // 右键切换到橡皮擦
        if(button == KeyCode.mouseRight){
            lastTool = tool;
            tool = EditorTool.eraser;
        }

        // 中键切换到缩放工具
        if(button == KeyCode.mouseMiddle){
            lastTool = tool;
            tool = EditorTool.zoom;
        }

        mousex = x;
        mousey = y;

        Point2 p = project(x, y);          // 投影到地图坐标
        lastx = p.x; lasty = p.y;
        startx = p.x; starty = p.y;
        tool.touched(p.x, p.y);            // 触发工具操作

        if(tool.edit){
            ui.editor.resetSaved();        // 标记为未保存
        }

        drawing = true;
        return true;
    }

    @Override
    public void touchDragged(InputEvent event, float x, float y, int pointer){
        mousex = x;
        mousey = y;

        Point2 p = project(x, y);

        // 拖拽绘制
        if(drawing && tool.draggable && !(p.x == lastx && p.y == lasty)){
            ui.editor.resetSaved();
            // 使用Bresenham算法连接点
            Bresenham2.line(lastx, lasty, p.x, p.y, (cx, cy) -> tool.touched(cx, cy));
        }

        // 直线工具的正交模式处理
        if(tool == EditorTool.line && tool.mode == 1){
            if(Math.abs(p.x - firstTouch.x) > Math.abs(p.y - firstTouch.y)){
                lastx = p.x;
                lasty = firstTouch.y;
            }else{
                lastx = firstTouch.x;
                lasty = p.y;
            }
        }else{
            lastx = p.x;
            lasty = p.y;
        }
    }
});
```

### 3. 坐标投影和视图控制

```java
// 屏幕坐标投影到地图坐标
Point2 project(float x, float y){
    float ratio = 1f / ((float)editor.width() / editor.height());
    float size = Math.min(width, height);
    float sclwidth = size * zoom;
    float sclheight = size * zoom * ratio;
    x = (x - getWidth() / 2 + sclwidth / 2 - offsetx * zoom) / sclwidth * editor.width();
    y = (y - getHeight() / 2 + sclheight / 2 - offsety * zoom) / sclheight * editor.height();

    // 偶数大小方块的偏移处理
    if(editor.drawBlock.size % 2 == 0 && tool != EditorTool.eraser){
        return Tmp.p1.set((int)(x - 0.5f), (int)(y - 0.5f));
    }else{
        return Tmp.p1.set((int)x, (int)y);
    }
}

// 地图坐标反投影到屏幕坐标
private Vec2 unproject(int x, int y){
    float ratio = 1f / ((float)editor.width() / editor.height());
    float size = Math.min(width, height);
    float sclwidth = size * zoom;
    float sclheight = size * zoom * ratio;
    float px = ((float)x / editor.width()) * sclwidth + offsetx * zoom - sclwidth / 2 + getWidth() / 2;
    float py = ((float)(y) / editor.height()) * sclheight + offsety * zoom - sclheight / 2 + getHeight() / 2;
    return vec.set(px, py);
}

// 视图更新和键盘控制
@Override
public void act(float delta){
    super.act(delta);

    // WASD移动视图
    if(Core.scene.getKeyboardFocus() == null || !Core.scene.hasField() && !Core.input.keyDown(KeyCode.controlLeft)){
        float ax = Core.input.axis(Binding.move_x);
        float ay = Core.input.axis(Binding.move_y);
        offsetx -= ax * 15 * Time.delta / zoom;
        offsety -= ay * 15 * Time.delta / zoom;
    }

    // Shift/Alt切换到拾取工具
    if(Core.input.keyTap(KeyCode.shiftLeft) || Core.input.keyTap(KeyCode.altLeft)){
        lastTool = tool;
        tool = EditorTool.pick;
    }

    if((Core.input.keyRelease(KeyCode.shiftLeft) || Core.input.keyRelease(KeyCode.altLeft)) && lastTool != null){
        tool = lastTool;
        lastTool = null;
    }

    // 滚轮缩放
    if(Core.scene.getScrollFocus() == this){
        zoom += Core.input.axis(Binding.zoom) / 10f * zoom;
        clampZoom();
    }
}
```

### 4. 视图渲染

```java
@Override
public void draw(){
    float ratio = 1f / ((float)editor.width() / editor.height());
    float size = Math.min(width, height);
    float sclwidth = size * zoom;
    float sclheight = size * zoom * ratio;
    float centerx = x + width / 2 + offsetx * zoom;
    float centery = y + height / 2 + offsety * zoom;

    // 设置裁剪区域
    if(!ScissorStack.push(rect.set(x + Core.scene.marginLeft, y + Core.scene.marginBottom, width, height))){
        return;
    }

    // 绘制地图边框
    Draw.color(Pal.remove);
    Lines.stroke(2f);
    Lines.rect(centerx - sclwidth / 2 - 1, centery - sclheight / 2 - 1, sclwidth + 2, sclheight + 2);

    // 渲染地图
    editor.renderer.draw(centerx - sclwidth / 2 + Core.scene.marginLeft,
                        centery - sclheight / 2 + Core.scene.marginBottom,
                        sclwidth, sclheight);

    // 绘制网格
    if(grid){
        Draw.color(Color.gray);
        image.setBounds(centerx - sclwidth / 2, centery - sclheight / 2, sclwidth, sclheight);
        image.draw();

        // 绘制坐标轴
        Lines.stroke(3f);
        Draw.color(Pal.accent);
        Lines.line(centerx - sclwidth/2f, centery, centerx + sclwidth/2f, centery);      // 水平轴
        Lines.line(centerx, centery - sclheight/2f, centerx, centery + sclheight/2f);   // 垂直轴
    }

    // 绘制画笔预览
    int index = 0;
    for(int i = 0; i < MapEditor.brushSizes.length; i++){
        if(editor.brushSize == MapEditor.brushSizes[i]){
            index = i;
            break;
        }
    }

    float scaling = zoom * Math.min(width, height) / editor.width();

    Draw.color(Pal.accent);
    Lines.stroke(Scl.scl(2f));

    // 单块和多块建筑的不同预览
    if((!editor.drawBlock.isMultiblock() || tool == EditorTool.eraser) && tool != EditorTool.fill){
        if((tool.edit || (tool == EditorTool.line && !drawing)) && (!mobile || drawing)){
            Point2 p = project(mousex, mousey);
            Vec2 v = unproject(p.x, p.y).add(x, y);

            // 画笔方形轮廓
            if(tool == EditorTool.pencil && tool.mode == 1){
                Lines.square(v.x + scaling/2f, v.y + scaling/2f,
                           scaling * ((editor.brushSize == 1.5f ? 1f : editor.brushSize) + 0.5f));
            }else{
                Lines.poly(brushPolygons[index], v.x, v.y, scaling);
            }
        }
    }else{
        // 多块建筑预览
        if((tool.edit || tool == EditorTool.line) && (!mobile || drawing)){
            Point2 p = project(mousex, mousey);
            Vec2 v = unproject(p.x, p.y).add(x, y);
            float offset = (editor.drawBlock.size % 2 == 0 ? scaling / 2f : 0f);
            Lines.square(v.x + scaling / 2f + offset, v.y + scaling / 2f + offset,
                        scaling * editor.drawBlock.size / 2f);
        }
    }

    ScissorStack.pop();
}
```

## 操作系统 (DrawOperation & OperationStack)

### 1. 绘制操作记录

```java
public class DrawOperation{
    private LongSeq array = new LongSeq(); // 操作数据数组

    public void addOperation(long op){
        array.add(op);
    }

    // 撤销操作
    public void undo(){
        for(int i = array.size - 1; i >= 0; i--){
            updateTile(i);
        }
    }

    // 重做操作
    public void redo(){
        for(int i = 0; i < array.size; i++){
            updateTile(i);
        }
    }

    // 更新瓦片状态
    private void updateTile(int i){
        long l = array.get(i);
        // 保存当前状态并应用新状态
        array.set(i, TileOp.get(TileOp.x(l), TileOp.y(l), TileOp.type(l),
                               getTile(editor.tile(TileOp.x(l), TileOp.y(l)), TileOp.type(l))));
        setTile(editor.tile(TileOp.x(l), TileOp.y(l)), TileOp.type(l), TileOp.value(l));
    }

    // 获取瓦片属性
    short getTile(Tile tile, byte type){
        if(type == OpType.floor.ordinal()){
            return tile.floorID();
        }else if(type == OpType.block.ordinal()){
            return tile.blockID();
        }else if(type == OpType.rotation.ordinal()){
            return tile.build == null ? 0 : (byte)tile.build.rotation;
        }else if(type == OpType.team.ordinal()){
            return (byte)tile.getTeamID();
        }else if(type == OpType.overlay.ordinal()){
            return tile.overlayID();
        }
        throw new IllegalArgumentException("Invalid type.");
    }

    // 设置瓦片属性
    void setTile(Tile tile, byte type, short to){
        editor.load(() -> {
            if(type == OpType.floor.ordinal()){
                if(content.block(to) instanceof Floor floor){
                    tile.setFloor(floor);
                }
            }else if(type == OpType.block.ordinal()){
                tile.getLinkedTiles(t -> editor.renderer.updatePoint(t.x, t.y));
                Block block = content.block(to);
                tile.setBlock(block, tile.team(), tile.build == null ? 0 : tile.build.rotation);
                tile.getLinkedTiles(t -> editor.renderer.updatePoint(t.x, t.y));
            }else if(type == OpType.rotation.ordinal()){
                if(tile.build != null) tile.build.rotation = to;
            }else if(type == OpType.team.ordinal()){
                tile.setTeam(Team.get(to));
            }else if(type == OpType.overlay.ordinal()){
                tile.setOverlayID(to);
            }
        });
        editor.renderer.updatePoint(tile.x, tile.y);
    }

    // 操作类型枚举
    public enum OpType{
        floor,      // 地板
        block,      // 方块
        rotation,   // 旋转
        team,       // 队伍
        overlay     // 覆盖层
    }
}
```

### 2. 撤销重做系统

```java
// MapEditor中的撤销重做方法
public void undo(){
    if(stack.canUndo()){
        stack.undo();
    }
}

public void redo(){
    if(stack.canRedo()){
        stack.redo();
    }
}

public void flushOp(){
    if(currentOp == null || currentOp.isEmpty()) return;
    stack.add(currentOp);    // 添加到操作栈
    currentOp = null;
}

public void addTileOp(long data){
    if(loading) return;

    if(currentOp == null) currentOp = new DrawOperation();
    currentOp.addOperation(data);

    renderer.updatePoint(TileOp.x(data), TileOp.y(data));
}
```

## 程序化地图生成 (MapGenerateDialog)

### 1. 生成系统架构

```java
public class MapGenerateDialog extends BaseDialog{
    Pixmap pixmap;                           // 预览图像
    Texture texture;                         // 预览纹理
    GenerateInput input = new GenerateInput(); // 生成输入
    Seq<GenerateFilter> filters = new Seq<>(); // 生成过滤器列表
    int scaling = mobile ? 3 : 1;           // 缩放因子

    Future<?> result;                        // 异步生成结果
    boolean generating;                      // 是否正在生成

    long[] buffer1, buffer2;                // 双缓冲区
    Cons<Seq<GenerateFilter>> applier;      // 应用器
}
```

### 2. 地图生成流程

```java
// 应用生成过滤器
public void apply(){
    if(generating) return;

    generating = true;
    ui.loadfrag.show("@generating");

    // 异步生成
    result = executor.submit(() -> {
        try{
            Tiles tiles = world.tiles;
            input.begin(tiles.width, tiles.height, buffer1, buffer2);

            // 应用所有过滤器
            for(GenerateFilter filter : filters){
                input.begin(tiles.width, tiles.height, buffer1, buffer2);
                filter.apply(input);
            }

            // 将结果应用到地图
            for(int x = 0; x < tiles.width; x++){
                for(int y = 0; y < tiles.height; y++){
                    tiles.getn(x, y).setFloor((Floor)content.block(input.floor[x + y * tiles.width]));
                    tiles.getn(x, y).setOverlay((Floor)content.block(input.overlay[x + y * tiles.width]));
                    Block wall = content.block(input.wall[x + y * tiles.width]);
                    if(wall != Blocks.air){
                        tiles.getn(x, y).setBlock(wall);
                    }
                }
            }

            editor.renderer.updateAll();
        }catch(Exception e){
            Log.err(e);
        }finally{
            generating = false;
        }
    });
}

// 随机化所有过滤器
buttons.button("@editor.randomize", Icon.refresh, () -> {
    for(GenerateFilter filter : filters){
        filter.randomize();
    }
    update();
});
```

### 3. 过滤器系统

```java
// 噪声过滤器示例
public class NoiseFilter extends GenerateFilter{
    public float scl = 40, threshold = 0.5f, octaves = 3, falloff = 0.5f;
    public Block target = Blocks.stone, replacement = Blocks.air;

    @Override
    public void apply(GenerateInput in){
        float noise = in.noise(scl, octaves, falloff, x, y);
        if(noise >= threshold){
            in.floor[in.ofs(x, y)] = replacement.id;
        }
    }

    @Override
    public void randomize(){
        scl = Mathf.random(10f, 60f);
        threshold = Mathf.random(0.1f, 0.9f);
        octaves = Mathf.random(1, 4);
        falloff = Mathf.random(0.3f, 0.8f);
    }
}

// 河流过滤器示例
public class RiverFilter extends GenerateFilter{
    public float scl = 40;
    public Block floor = Blocks.water, block = Blocks.air;

    @Override
    public void apply(GenerateInput in){
        float noise1 = in.noise(scl, 1, 1, x, y);
        float noise2 = in.noise(scl, 1, 1, x + 9999, y + 9999);

        if(Math.abs(noise1 - noise2) < 0.12f){
            in.floor[in.ofs(x, y)] = floor.id;
            in.wall[in.ofs(x, y)] = block.id;
        }
    }
}
```

## 地图导入导出系统

### 1. 地图保存和加载

```java
// 保存地图到文件
public Map save(){
    String name = editor.tags.get("name", "").trim();
    if(name.isEmpty()){
        ui.showInfo("@editor.save.noname");
        return null;
    }

    Fi file = maps.customMapDirectory.child(name + "." + mapExtension);
    Map map = editor.createMap(file);

    try{
        MapIO.writeMap(file, map);
        ui.showInfoFade(Core.bundle.format("editor.saved", name));
        return map;
    }catch(Exception e){
        ui.showException("@editor.save.fail", e);
        return null;
    }
}

// 导出地图为图像
platform.export(editor.tags.get("name", "unknown"), "png", file -> {
    Pixmap out = MapIO.writeImage(editor.tiles());
    file.writePng(out);
    out.dispose();
});

// 从图像导入地图
platform.showFileChooser(true, "png", file ->
ui.loadAnd(() -> {
    try{
        Pixmap pixmap = new Pixmap(file);
        editor.beginEdit(pixmap);
        pixmap.dispose();
    }catch(Exception e){
        ui.showException("@editor.errorload", e);
    }
}));
```

### 2. 地图验证和优化

```java
// 验证地图有效性
public boolean validateMap(){
    Tiles tiles = editor.tiles();
    boolean hasCore = false;
    boolean hasSpawn = false;

    for(Tile tile : tiles){
        // 检查核心
        if(tile.block() instanceof CoreBlock){
            hasCore = true;
        }

        // 检查敌人生成点
        if(tile.overlay().itemDrop != null || tile.block().breakable){
            hasSpawn = true;
        }
    }

    if(!hasCore){
        ui.showInfo("@editor.nocore");
        return false;
    }

    return true;
}

// 地图优化
public void optimizeMap(){
    Tiles tiles = editor.tiles();

    // 移除孤立的方块
    for(Tile tile : tiles){
        if(tile.block().update && !tile.block().hasBuilding()){
            boolean hasNeighbor = false;
            for(Point2 p : Geometry.d4){
                Tile other = tiles.get(tile.x + p.x, tile.y + p.y);
                if(other != null && other.block().connectsTo(tile.block())){
                    hasNeighbor = true;
                    break;
                }
            }

            if(!hasNeighbor){
                tile.setBlock(Blocks.air);
            }
        }
    }

    editor.renderer.updateAll();
}
```

## 性能优化策略

### 1. 渲染优化

```java
// MapRenderer中的批量更新
public void updateAll(){
    // 批量更新所有瓦片渲染
    for(int x = 0; x < tiles.width; x++){
        for(int y = 0; y < tiles.height; y++){
            updatePoint(x, y);
        }
    }

    // 合并绘制调用
    Draw.flush();
}

// 增量更新优化
public void updatePoint(int x, int y){
    if(!needsUpdate[x + y * width]) return;

    needsUpdate[x + y * width] = false;
    // 仅更新必要的渲染区域
    redrawRegion(x - 1, y - 1, x + 1, y + 1);
}
```

### 2. 内存管理

```java
// 对象池化
private static final Pool<DrawOperation> opPool = Pools.get(DrawOperation.class, DrawOperation::new);

public void beginOp(){
    if(currentOp != null) return;
    currentOp = opPool.obtain();
}

public void endOp(){
    if(currentOp == null) return;
    if(!currentOp.isEmpty()){
        stack.add(currentOp);
    }else{
        opPool.free(currentOp);
    }
    currentOp = null;
}

// 纹理缓存管理
private ObjectMap<String, Texture> textureCache = new ObjectMap<>();

public Texture getCachedTexture(String key){
    Texture tex = textureCache.get(key);
    if(tex == null || tex.isDisposed()){
        tex = generateTexture(key);
        textureCache.put(key, tex);
    }
    return tex;
}
```

### 3. 异步处理

```java
// 异步地图生成
ExecutorService executor = Executors.newSingleThreadExecutor();

public void generateAsync(){
    if(generating) return;

    generating = true;
    executor.submit(() -> {
        try{
            // 耗时的地图生成操作
            generateMapData();

            // 切回主线程更新UI
            Core.app.post(() -> {
                updateMapDisplay();
                generating = false;
            });
        }catch(Exception e){
            Core.app.post(() -> {
                ui.showException("@editor.generate.error", e);
                generating = false;
            });
        }
    });
}
```

## 扩展性设计

### 1. 自定义工具支持

```java
// 工具注册系统
public static void registerTool(String name, EditorTool tool){
    customTools.put(name, tool);
    allTools.add(tool);
}

// 自定义工具示例
public class CustomBrushTool extends EditorTool{
    public CustomBrushTool(){
        super(KeyCode.u, "circle", "square", "triangle");
    }

    @Override
    public void touched(int x, int y){
        switch(mode){
            case 0: drawCircle(x, y); break;
            case 1: drawSquare(x, y); break;
            case 2: drawTriangle(x, y); break;
        }
    }
}
```

### 2. 过滤器插件系统

```java
// 过滤器注册
public static void registerFilter(String name, Prov<GenerateFilter> constructor){
    filterConstructors.put(name, constructor);
    filterNames.add(name);
}

// 自定义过滤器
public class CustomNoiseFilter extends GenerateFilter{
    @Override
    public void apply(GenerateInput in){
        // 自定义噪声算法
        for(int x = 0; x < in.width; x++){
            for(int y = 0; y < in.height; y++){
                float noise = customNoise(x, y);
                if(noise > threshold){
                    in.floor[in.ofs(x, y)] = targetBlock.id;
                }
            }
        }
    }
}
```

## 总结

Mindustry的地图编辑器展现了现代游戏编辑工具的优秀设计：

**核心优势：**
1. **实时编辑** - 即时预览和反馈的编辑体验
2. **多样工具** - 画笔、橡皮擦、填充、喷洒等丰富工具
3. **撤销重做** - 完整的操作历史管理系统
4. **程序生成** - 强大的过滤器系统支持自动地图生成
5. **多格式支持** - 原生地图格式和图像格式的互转
6. **跨平台兼容** - 桌面和移动端的统一体验

**设计模式：**
- **命令模式** - DrawOperation操作记录和撤销重做
- **策略模式** - 不同的编辑工具策略
- **观察者模式** - 地图变更和渲染更新通知
- **工厂模式** - 地图生成过滤器的创建
- **状态模式** - 编辑器的不同工作状态

这个地图编辑器为Mindustry提供了强大的内容创作能力，使玩家能够轻松创建和分享自定义地图，同时为MOD开发者提供了良好的扩展基础。