# Mindustry 开发实践指南

## 概述

本文档提供 Mindustry 项目的完整开发实践指南，包括代码规范、调试技巧、测试方法和性能优化策略。遵循这些实践将帮助开发者高效地参与项目开发并保持代码质量。

## 代码规范

### 基础编码风格

#### 格式化规则
```java
// ✅ 正确：括号无空格，同行大括号
if(condition){
    statement;
}

// ❌ 错误：括号有空格，换行大括号
if ( condition )
{
    statement;
}
```

#### 命名约定
```java
// ✅ 正确：全部使用 camelCase，包括常量和枚举
public static final int maxHealth = 100;
public enum BlockType { wall, turret, factory }

// ❌ 错误：使用 SCREAMING_CASE
public static final int MAX_HEALTH = 100;
public enum BlockType { WALL, TURRET, FACTORY }

// ✅ 正确：简短变量名
int hp, dmg, spd;
Seq<Unit> units;

// ❌ 错误：冗长变量名
int currentHealthPoints, damagePerSecond, movementSpeed;
Seq<Unit> unitEntityList;
```

#### 导入和包管理
```java
// ✅ 正确：使用通配符导入
import arc.struct.*;
import mindustry.content.*;
import mindustry.entities.*;

// ❌ 错误：具体类导入
import arc.struct.Seq;
import arc.struct.ObjectMap;
import mindustry.content.Blocks;
```

### 代码结构规范

#### 类和方法设计
```java
// ✅ 正确：避免不必要的 getter/setter，直接使用公共字段
public class Building {
    public float health;
    public Team team;
    public Block block;
}

// ❌ 错误：过度封装
public class Building {
    private float health;

    public float getHealth() { return health; }
    public void setHealth(float health) { this.health = health; }
}
```

#### 方法长度控制
```java
// ✅ 正确：简洁的方法，避免过度拆分
public void update() {
    health -= damage * Time.delta;
    if(health <= 0) {
        kill();
        Effects.scorch(x, y, size);
        Groups.all.remove(this);
    }
}

// ❌ 错误：不必要的方法拆分
public void update() {
    applyDamage();
    checkDeath();
}

private void applyDamage() {
    health -= damage * Time.delta;
}

private void checkDeath() {
    if(health <= 0) handleDeath();
}
```

## 平台兼容性

### 避免不兼容的 Java 特性

#### 函数式接口使用
```java
// ✅ 正确：使用 Arc 的函数式接口
import arc.func.*;

Seq<Unit> units = new Seq<>();
units.each(unit -> unit.update());           // 使用 Cons<T>
units.select(unit -> unit.health > 0);       // 使用 Boolf<T>
units.sort(Floatf.by(unit -> unit.health)); // 使用 Floatf<T>

// ❌ 错误：使用 Java 8 函数式接口（在移动平台不支持）
import java.util.function.*;
units.forEach(unit -> unit.update());        // Consumer<T> 不支持
units.removeIf(unit -> unit.health <= 0);    // Predicate<T> 不支持
```

#### 集合类选择
```java
// ✅ 正确：使用 Arc 集合
Seq<Item> items = new Seq<>();              // 代替 ArrayList
ObjectMap<String, Block> blocks = new ObjectMap<>(); // 代替 HashMap
ObjectSet<Team> teams = new ObjectSet<>();   // 代替 HashSet
IntSeq values = new IntSeq();               // 专用 int 序列

// ❌ 错误：使用标准 Java 集合
List<Item> items = new ArrayList<>();
Map<String, Block> blocks = new HashMap<>();
Set<Team> teams = new HashSet<>();
List<Integer> values = new ArrayList<>();   // 装箱性能差
```

#### 禁用包和类
```java
// ❌ 禁止使用的包
import java.awt.*;           // 任何平台都不支持
import java.util.stream.*;   // 移动平台不支持
import java.util.function.*; // 移动平台不支持

// ✅ 安全的包
import java.util.*;          // 基础集合类 OK
import java.io.*;            // 基础 IO OK
import java.nio.*;           // NIO OK
```

## 性能优化实践

### 内存管理

#### 对象池使用
```java
// ✅ 正确：使用对象池避免 GC
public void createBullet() {
    Bullet bullet = Pools.obtain(Bullet.class);
    bullet.set(x, y, angle, damage);
    // ... 使用 bullet
    Pools.free(bullet); // 归还到池中
}

// ❌ 错误：频繁创建新对象
public void createBullet() {
    Bullet bullet = new Bullet(x, y, angle, damage); // 每次都创建新对象
}
```

#### 临时变量复用
```java
// ✅ 正确：使用 Tmp 临时变量
public void calculateDistance() {
    Tmp.v1.set(x, y);
    Tmp.v1.sub(target.x, target.y);
    float distance = Tmp.v1.len();
}

// ✅ 正确：使用静态变量复用
private static final Seq<Unit> tmpUnits = new Seq<>();

public void processNearbyUnits() {
    tmpUnits.clear();
    Units.nearby(x, y, range, tmpUnits);
    tmpUnits.each(this::processUnit);
}

// ❌ 错误：在循环中创建新对象
public void calculateDistance() {
    Vec2 temp = new Vec2(x, y);  // 每次调用都创建
    temp.sub(target.x, target.y);
    float distance = temp.len();
}
```

#### 避免装箱类型
```java
// ✅ 正确：使用专用集合
IntSeq healthValues = new IntSeq();
IntMap<Building> buildingMap = new IntMap<>();
FloatSeq damages = new FloatSeq();

// ❌ 错误：使用装箱类型
Seq<Integer> healthValues = new Seq<>();
ObjectMap<Integer, Building> buildingMap = new ObjectMap<>();
Seq<Float> damages = new Seq<>();
```

### 循环优化

#### 高效的实体遍历
```java
// ✅ 正确：使用 Groups 系统
Groups.unit.each(unit -> {
    if(unit.team == Team.crux) {
        unit.damage(10f);
    }
});

// ✅ 正确：带条件的遍历
Groups.unit.each(u -> u.team == Team.crux, unit -> {
    unit.damage(10f);
});

// ❌ 错误：手动管理单位列表
for(Unit unit : allUnits) {
    if(unit.isValid() && unit.team == Team.crux) {
        unit.damage(10f);
    }
}
```

## 测试实践

### 单元测试结构

#### 测试环境初始化
```java
@BeforeAll
public static void setup() {
    ApplicationTests.launchApplication();  // 初始化 headless 应用
}

@BeforeEach
void resetWorld() {
    Time.setDeltaProvider(() -> 1f);      // 固定时间步长
    logic.reset();                        // 重置游戏逻辑
    state.set(State.menu);               // 重置游戏状态
}
```

#### 世界创建和测试
```java
@Test
void testBlockPlacement() {
    // 创建测试地图
    Tiles tiles = world.resize(8, 8);
    world.beginMapLoad();
    tiles.fill();  // 用默认地板填充
    world.endMapLoad();

    // 放置建筑
    world.tile(4, 4).setBlock(Blocks.coreShard, Team.sharded);

    // 验证结果
    assertEquals(Blocks.coreShard, world.tile(4, 4).block());
    assertEquals(Team.sharded, world.tile(4, 4).team());
}
```

#### 建筑功能测试
```java
@Test
void testConveyorTransport() {
    createMap();
    state.set(State.playing);

    // 设置源和目标
    world.tile(0, 0).setBlock(Blocks.itemSource, Team.sharded);
    world.tile(0, 0).build.configureAny(Items.copper);

    world.tile(2, 0).setBlock(Blocks.vault, Team.sharded);
    world.tile(1, 0).setBlock(Blocks.conveyor, Team.sharded);

    // 模拟更新
    updateBlocks(50);

    // 验证物品传输
    assertTrue(world.tile(2, 0).build.items.has(Items.copper));
}

void updateBlocks(int times) {
    for(int i = 0; i < times; i++) {
        Time.update();
        for(Tile tile : world.tiles) {
            if(tile.build != null && tile.isCenter()) {
                tile.build.update();
            }
        }
    }
}
```

### 参数化测试
```java
@ParameterizedTest
@ValueSource(strings = {"copper", "lead", "titanium", "thorium"})
void testItemProcessing(String itemName) {
    Item item = content.getByName(ContentType.item, itemName);
    assertNotNull(item, "Item " + itemName + " should exist");

    // 测试物品处理逻辑
    assertTrue(item.flammability >= 0);
    assertTrue(item.explosiveness >= 0);
}
```

### 存档测试
```java
@Test
void testSaveLoad() {
    world.loadMap(testMap);

    // 创建测试单位
    Unit unit = UnitTypes.dagger.spawn(Team.sharded, 20f, 30f);
    unit.health = 50f;

    // 保存游戏
    SaveIO.save(saveDirectory.child("test.msav"));

    // 重置世界
    resetWorld();

    // 加载游戏
    SaveIO.load(saveDirectory.child("test.msav"));

    // 验证单位数据
    Unit loaded = Groups.unit.find(u -> u.type == UnitTypes.dagger);
    assertNotNull(loaded);
    assertEquals(50f, loaded.health);
}
```

## 调试技巧

### 日志系统

#### 日志级别使用
```java
// 调试信息
Log.debug("Player position: @, @", player.x, player.y);

// 一般信息
Log.info("Game started with @ players", Groups.player.size());

// 警告信息
Log.warn("Low health: @/@", health, maxHealth);

// 错误信息
Log.err("Failed to load map: @", mapName);
Log.err("Exception occurred", exception);
```

#### 条件调试
```java
// 使用调试标志
if(Vars.debug) {
    Log.info("Debug: processing @ units", Groups.unit.size());
    drawDebugInfo();
}

// 临时调试开关
public static boolean debugPathfinding = false;

if(debugPathfinding) {
    Log.info("Pathfinding from (@, @) to (@, @)",
            startX, startY, endX, endY);
}
```

### 性能分析

#### 时间测量
```java
// 测量代码执行时间
Time.mark();
expensiveOperation();
Log.info("Operation took @ms", Time.elapsed());

// 分段计时
long start = Time.nanos();
// ... 代码块
long elapsed = Time.timeSinceNanos(start);
Log.info("Block took @ns", elapsed);
```

#### 内存使用监控
```java
// 监控 GC 情况
Runtime runtime = Runtime.getRuntime();
long totalMemory = runtime.totalMemory();
long freeMemory = runtime.freeMemory();
long usedMemory = totalMemory - freeMemory;

Log.info("Memory usage: @MB / @MB",
        usedMemory / 1024 / 1024,
        totalMemory / 1024 / 1024);
```

### 可视化调试

#### 几何调试绘制
```java
// 在 Draw 类中进行调试绘制
if(debug) {
    Draw.color(Color.red);
    Lines.circle(x, y, range);              // 范围圆

    Draw.color(Color.yellow);
    Lines.line(x, y, targetX, targetY);     // 目标线

    Draw.color(Color.blue);
    Fill.circle(x, y, 3f);                  // 位置点

    Draw.reset();
}
```

#### 状态信息显示
```java
// 在 UI 中显示调试信息
if(debug) {
    ui.showInfoText("Health: " + health + "/" + maxHealth +
                   "\nAmmo: " + ammo + "/" + maxAmmo +
                   "\nTarget: " + (target != null ? "Yes" : "No"));
}
```

## 构建和部署

### 开发环境设置

#### IDE 配置
1. **使用 IntelliJ IDEA**: 下载社区版并导入代码样式文件
2. **JDK 版本**: 严格使用 JDK 17，其他版本不兼容
3. **Gradle 配置**: 确保使用项目指定的 Gradle 版本

#### 常用开发命令
```bash
# 运行桌面版
./gradlew desktop:run

# 构建桌面版 JAR
./gradlew desktop:dist
# 输出: desktop/build/libs/Mindustry.jar

# 构建服务器版
./gradlew server:dist
# 输出: server/build/libs/server-release.jar

# 打包资源
./gradlew tools:pack

# 运行测试
./gradlew tests:test

# 清理缓存
./gradlew clearCache
```

### 代码质量检查

#### 静态分析
```bash
# 使用 IntelliJ 内置检查
# Code -> Inspect Code -> Whole Project

# 检查平台兼容性问题
# 在 IntelliJ 中会自动标注不兼容的 API
```

#### 代码审查清单
- [ ] 使用正确的代码格式（无括号空格、同行大括号）
- [ ] 避免不兼容的 Java 特性
- [ ] 使用 Arc 集合而非标准 Java 集合
- [ ] 避免在循环中创建对象
- [ ] 使用对象池和临时变量
- [ ] 添加适当的测试覆盖
- [ ] 遵循命名约定（camelCase）

## MOD 开发最佳实践

### MOD 项目结构
```
mod/
├── mod.hjson              # MOD 元数据
├── content/
│   ├── blocks/           # 建筑定义
│   ├── items/            # 物品定义
│   └── units/            # 单位定义
├── sprites/              # 贴图资源
├── sounds/               # 音效资源
└── scripts/              # JavaScript 脚本
```

### 内容定义最佳实践
```hjson
// 建筑定义示例
{
    name: "advanced-drill"
    type: "Drill"
    size: 3
    health: 800
    drillTime: 200
    tier: 4
    requirements: [
        "titanium/80"
        "silicon/60"
        "thorium/50"
    ]
    category: "production"
    research: "blast-drill"
}
```

### 脚本性能优化
```javascript
// ✅ 正确：缓存频繁使用的对象
const player = Vars.player;
const world = Vars.world;

// ✅ 正确：使用事件而非轮询
Events.on(BlockDestroyEvent, event => {
    // 处理建筑摧毁事件
});

// ❌ 错误：在更新循环中轮询
Events.on(Trigger.update, () => {
    // 避免在这里做复杂计算
});
```

## 常见问题和解决方案

### 编译问题

#### 平台兼容性错误
```
错误: java.util.stream 不支持
解决: 使用 arc.struct.Seq 的 select/each 等方法

错误: java.awt.Color 不存在
解决: 使用 arc.graphics.Color
```

#### 资源加载问题
```java
// ✅ 正确：相对路径资源加载
Pixmap pixmap = new Pixmap(Core.files.internal("sprites/block.png"));

// ❌ 错误：绝对路径
Pixmap pixmap = new Pixmap(new FileHandle("/path/to/sprite.png"));
```

### 性能问题

#### GC 频繁触发
```java
// 检查对象分配热点
// 使用 JProfiler 或 VisualVM 分析内存使用

// 常见原因和解决方案：
// 1. 字符串连接 -> 使用 StringBuilder 或 String.format
// 2. 临时 Vector2 对象 -> 使用 Tmp.v1, Tmp.v2
// 3. 集合扩容 -> 预设合适的初始容量
```

#### 渲染性能下降
```java
// 批次绘制
Draw.batch(() -> {
    for(Unit unit : units) {
        unit.draw();
    }
});

// 避免频繁状态切换
Draw.color(Color.white);
for(Effect effect : effects) {
    effect.draw();  // 相同颜色的效果一起绘制
}
```

### 网络同步问题

#### 客户端-服务器不一致
```java
// ✅ 正确：使用 @Remote 注解进行同步
@Remote(called = Loc.server)
public static void setBlockHealth(Building build, float health) {
    if(build != null) {
        build.health = health;
    }
}

// 调用同步方法
Call.setBlockHealth(building, newHealth);
```

## 贡献指南

### 提交代码前检查清单
1. **功能测试**: 确保代码在游戏中正常工作
2. **单元测试**: 添加或更新相关测试
3. **代码格式**: 使用 IntelliJ 格式化代码
4. **平台兼容**: 检查是否使用了不兼容的 API
5. **性能影响**: 评估对游戏性能的影响
6. **文档更新**: 必要时更新相关文档

### Git 提交规范
```bash
# 功能添加
git commit -m "Add liquid router block functionality"

# Bug 修复
git commit -m "Fix conveyor item duplication bug"

# 性能优化
git commit -m "Optimize unit pathfinding performance"

# 文档更新
git commit -m "Update building system documentation"
```

### Pull Request 标准
1. **描述清楚**: 说明更改的内容和原因
2. **测试结果**: 包含测试截图或结果
3. **影响范围**: 说明可能影响的系统
4. **向前兼容**: 确保不破坏现有功能

---

通过遵循这些开发实践，你将能够高效地参与 Mindustry 项目开发，同时保持代码质量和项目的长期可维护性。记住，一致性和性能是这个项目的核心价值，所有的开发决策都应该围绕这两个目标进行。