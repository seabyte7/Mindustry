# 图形和渲染系统

Mindustry采用基于Arc框架的现代图形渲染系统，支持高性能批量渲染、先进着色器效果、动态光照和复杂特效处理，为塔防RTS游戏提供了出色的视觉体验。

## 核心架构设计

### 1. 渲染系统层次架构

```
┌─────────────────────────────────────────┐
│              Renderer                   │
│          (核心渲染控制器)                 │
├─────────────────────────────────────────┤
│  BlockRenderer  │  LightRenderer        │
│   (方块渲染)     │   (光照渲染)           │
├─────────────────┬─────────────────────────┤
│  FloorRenderer  │  FogRenderer            │
│   (地板渲染)     │   (迷雾渲染)            │
├─────────────────┼─────────────────────────┤
│  OverlayRenderer │ MinimapRenderer       │
│   (覆盖渲染)     │   (小地图渲染)          │
├─────────────────┴─────────────────────────┤
│             Shaders                     │
│            (着色器系统)                  │
├─────────────────────────────────────────┤
│            Layer System                 │
│           (分层渲染系统)                  │
└─────────────────────────────────────────┘
```

### 2. 关键类说明

| 类名 | 文件位置 | 职责 |
|------|----------|------|
| `Renderer` | `mindustry/core/Renderer.java` | 核心渲染控制器，管理整体渲染流程 |
| `Shaders` | `mindustry/graphics/Shaders.java` | 着色器系统，管理所有GLSL着色器 |
| `Layer` | `mindustry/graphics/Layer.java` | 渲染层定义，控制绘制顺序 |
| `BlockRenderer` | `mindustry/graphics/BlockRenderer.java` | 方块和建筑渲染器 |
| `LightRenderer` | `mindustry/graphics/LightRenderer.java` | 动态光照渲染器 |
| `FloorRenderer` | `mindustry/graphics/FloorRenderer.java` | 地板和地形渲染器 |
| `FogRenderer` | `mindustry/graphics/FogRenderer.java` | 战争迷雾渲染器 |
| `Drawf` | `mindustry/graphics/Drawf.java` | 高级绘制工具和效果函数 |
| `PlanetRenderer` | `mindustry/graphics/g3d/PlanetRenderer.java` | 3D星球渲染器 |

## 核心渲染器 (Renderer)

### 1. 主渲染循环

```java
public class Renderer implements ApplicationListener{
    // 专业渲染器实例
    public final BlockRenderer blocks = new BlockRenderer();
    public final FogRenderer fog = new FogRenderer();
    public final MinimapRenderer minimap = new MinimapRenderer();
    public final OverlayRenderer overlays = new OverlayRenderer();
    public final LightRenderer lights = new LightRenderer();
    public final Pixelator pixelator = new Pixelator();
    public PlanetRenderer planets;

    // 特效系统
    public @Nullable Bloom bloom;                // 辉光效果
    public FrameBuffer effectBuffer = new FrameBuffer(); // 效果缓冲区
    public boolean animateShields, drawWeather = true;   // 效果开关

    // 摄像机控制
    public float minZoom = 1.5f, maxZoom = 6f;
    private float targetscale = Scl.scl(4);      // 目标缩放
    private float camerascale = targetscale;     // 当前缩放
    private Vec2 camShakeOffset = new Vec2();    // 屏幕震动偏移
}
```

### 2. 渲染管道流程

```java
// 主绘制方法 - 按层次顺序渲染
public void draw(){
    Events.fire(Trigger.preDraw);
    camera.update();
    graphics.clear(clearColor);

    // 设置投影矩阵
    Draw.proj(camera);

    // 方块系统预处理
    blocks.checkChanges();
    blocks.floor.checkChanges();
    blocks.processBlocks();

    // 启用深度排序
    Draw.sort(true);

    // 按层级依次渲染
    Draw.draw(Layer.background, this::drawBackground);
    Draw.draw(Layer.floor, blocks.floor::drawFloor);
    Draw.draw(Layer.block - 1, blocks::drawShadows);
    Draw.draw(Layer.block - 0.09f, () -> {
        blocks.floor.beginDraw();
        blocks.floor.drawLayer(CacheLayer.walls);
        blocks.floor.endDraw();
    });

    // 建造中方块使用特殊着色器
    Draw.drawRange(Layer.blockBuilding,
        () -> Draw.shader(Shaders.blockbuild, true),
        Draw::shader);

    // 环境渲染器
    for(var renderer : envRenderers){
        if((renderer.env & state.rules.env) == renderer.env){
            renderer.renderer.run();
        }
    }

    // 光照系统
    if(state.rules.lighting && drawLight){
        Draw.draw(Layer.light, lights::draw);
    }

    // 辉光效果
    if(bloom != null){
        bloom.resize(graphics.getWidth(), graphics.getHeight());
        bloom.setBloomIntensity(settings.getInt("bloomintensity", 6) / 4f + 1f);
        Draw.draw(Layer.bullet - 0.02f, bloom::capture);
        Draw.draw(Layer.effect + 0.02f, bloom::render);
    }

    // 护盾和建造光束效果
    if(animateShields && Shaders.shield != null){
        Draw.drawRange(Layer.shields, 1f,
            () -> effectBuffer.begin(Color.clear),
            () -> {
                effectBuffer.end();
                effectBuffer.blit(Shaders.shield);
            });
    }

    // 实体渲染
    Groups.draw.draw(Drawc::draw);

    Draw.flush();
    Events.fire(Trigger.postDraw);
}
```

### 3. 摄像机控制系统

```java
// 缩放控制
public void scaleCamera(float amount){
    targetscale *= (amount / 4) + 1;
    clampScale();
}

// 平滑缩放
@Override
public void update(){
    float dest = Mathf.clamp(Mathf.round(targetscale, 0.5f), minScale(), maxScale());
    camerascale = Mathf.lerpDelta(camerascale, dest, 0.1f);

    camera.width = graphics.getWidth() / camerascale;
    camera.height = graphics.getHeight() / camerascale;

    // 屏幕震动效果
    if(shakeTime > 0){
        float intensity = shakeIntensity * (settings.getInt("screenshake", 4) / 4f) * 0.75f;
        camShakeOffset.setToRandomDirection().scl(Mathf.random(intensity));
        camera.position.add(camShakeOffset);
        shakeIntensity -= shakeReduction * Time.delta;
        shakeTime -= Time.delta;
    }
}

// 屏幕震动
public void shake(float intensity, float duration){
    shakeIntensity = Math.max(shakeIntensity, Mathf.clamp(intensity, 0, 100));
    shakeTime = Math.max(shakeTime, duration);
    shakeReduction = shakeIntensity / shakeTime;
}
```

## 着色器系统 (Shaders)

### 1. 着色器类型和功能

```java
public class Shaders{
    // 基础着色器
    public static BlockBuildShader blockbuild;    // 建造进度着色器
    public static UnitBuildShader build;          // 单位建造着色器
    public static UnitArmorShader armor;          // 单位护甲着色器

    // 效果着色器
    public static @Nullable ShieldShader shield; // 护盾效果着色器
    public static BuildBeamShader buildBeam;      // 建造光束着色器
    public static ShockwaveShader shockwave;      // 冲击波效果着色器

    // 环境着色器
    public static LightShader light;              // 光照着色器
    public static DarknessShader darkness;        // 黑暗效果着色器
    public static FogShader fog;                  // 迷雾着色器

    // 表面材质着色器
    public static SurfaceShader water, mud, tar, slag, cryofluid, space, caustics, arkycite;

    // 3D渲染着色器
    public static PlanetShader planet;            // 星球着色器
    public static CloudShader clouds;             // 云层着色器
    public static AtmosphereShader atmosphere;    // 大气层着色器
    public static PlanetGridShader planetGrid;    // 星球网格着色器
    public static MeshShader mesh;                // 3D网格着色器
}
```

### 2. 建造进度着色器

```java
public static class BlockBuildShader extends LoadShader{
    public float progress;                        // 建造进度 [0-1]
    public float alpha = 1f;                     // 透明度
    public TextureRegion region = new TextureRegion(); // 纹理区域
    public float time;                           // 时间参数

    @Override
    public void apply(){
        setUniformf("u_progress", progress);
        setUniformf("u_time", time);
        setUniformf("u_alpha", alpha);

        // 纹理坐标传递
        setUniformf("u_uv", region.u, region.v);
        setUniformf("u_uv2", region.u2, region.v2);
        setUniformf("u_texsize", region.texture.width, region.texture.height);
    }
}
```

### 3. 护盾效果着色器

```java
public static class ShieldShader extends LoadShader{
    public ShieldShader(){
        super("shield", "screenspace");
    }

    @Override
    public void apply(){
        setUniformf("u_dp", Scl.scl(1f));
        setUniformf("u_time", Time.time / Scl.scl(1f));
        setUniformf("u_offset",
            Core.camera.position.x - Core.camera.width / 2,
            Core.camera.position.y - Core.camera.height / 2);
        setUniformf("u_texsize", Core.camera.width, Core.camera.height);
        setUniformf("u_invsize", 1f/Core.camera.width, 1f/Core.camera.height);
    }
}
```

### 4. 表面材质着色器

```java
public static class SurfaceShader extends Shader{
    Texture noiseTex;

    public SurfaceShader(String frag){
        super(getShaderFi("screenspace.vert"), getShaderFi(frag + ".frag"));
        loadNoise();
    }

    @Override
    public void apply(){
        setUniformf("u_campos", Core.camera.position.x - Core.camera.width / 2,
                                Core.camera.position.y - Core.camera.height / 2);
        setUniformf("u_resolution", Core.camera.width, Core.camera.height);
        setUniformf("u_time", Time.time);

        // 噪声纹理绑定
        if(hasUniform("u_noise")){
            if(noiseTex == null){
                noiseTex = Core.assets.get("sprites/" + textureName() + ".png", Texture.class);
            }
            noiseTex.bind(1);
            renderer.effectBuffer.getTexture().bind(0);
            setUniformi("u_noise", 1);
        }
    }
}
```

### 5. 3D星球着色器

```java
public static class PlanetShader extends LoadShader{
    public Vec3 lightDir = new Vec3(1, 1, 1).nor(); // 光照方向
    public Color ambientColor = Color.white.cpy();   // 环境光颜色
    public Vec3 camDir = new Vec3();                 // 摄像机方向
    public Planet planet;                            // 星球对象

    @Override
    public void apply(){
        camDir.set(renderer.planets.cam.direction).rotate(Vec3.Y, planet.getRotation());

        setUniformf("u_lightdir", lightDir);
        setUniformf("u_ambientColor", ambientColor.r, ambientColor.g, ambientColor.b);
        setUniformf("u_camdir", camDir);
        setUniformf("u_campos", renderer.planets.cam.position);
    }
}
```

## 分层渲染系统 (Layer)

### 1. 渲染层次定义

```java
public class Layer{
    // 背景层
    public static final float background = -10;     // 背景（星球或图像）

    // 地面层
    public static final float floor = 0;            // 地板瓦片
    public static final float scorch = 10;          // 灼烧痕迹
    public static final float debris = 20;          // 碎片和弹壳

    // 建筑层
    public static final float blockUnder = 29.5f;   // 建筑底层（管道连接）
    public static final float block = 30;           // 基础建筑层
    public static final float blockCracks = 30.1f;  // 建筑裂纹
    public static final float blockAfterCracks = 30.2f; // 裂纹后建筑
    public static final float blockAdditive = 31;   // 建筑叠加层
    public static final float blockProp = 32;       // 建筑装饰物
    public static final float blockOver = 35;       // 建筑覆盖层
    public static final float blockBuilding = 40;   // 建造中建筑（着色器）

    // 作战层
    public static final float turret = 50;          // 炮塔
    public static final float turretHeat = 50.1f;   // 炮塔发热效果
    public static final float groundUnit = 60;      // 地面单位
    public static final float power = 70;           // 电力线
    public static final float bullet = 100;         // 子弹（辉光开始）
    public static final float effect = 110;         // 特效（辉光结束）
    public static final float flyingUnit = 115;     // 飞行单位

    // 效果层
    public static final float buildBeam = 122;      // 建造光束
    public static final float shields = 125;        // 护盾效果
    public static final float weather = 130;        // 天气效果
    public static final float light = 140;          // 光照渲染（着色器）
    public static final float fogOfWar = 155;       // 战争迷雾
    public static final float space = 160;          // 太空效果

    // 界面层
    public static final float overlayUI = 120;      // 覆盖UI
    public static final float playerName = 150;     // 玩家名称
    public static final float endPixeled = 210;     // 像素化后层（文本）
}
```

### 2. 分层渲染实现

```java
// 分层绘制调用
Draw.draw(Layer.floor, blocks.floor::drawFloor);
Draw.draw(Layer.block, blocks::drawBlocks);
Draw.draw(Layer.effect, effects::drawEffects);

// 范围绘制（用于着色器效果）
Draw.drawRange(Layer.shields, 1f,
    () -> effectBuffer.begin(Color.clear),
    () -> {
        effectBuffer.end();
        effectBuffer.blit(Shaders.shield);
    });
```

## 方块渲染系统 (BlockRenderer)

### 1. 方块渲染架构

```java
public class BlockRenderer{
    public final FloorRenderer floor = new FloorRenderer(); // 地板渲染器
    public TextureRegion[][] cracks;                        // 裂纹纹理

    // 视域管理
    private Seq<Tile> tileview = new Seq<>(false, initialRequests, Tile.class);
    private Seq<Tile> lightview = new Seq<>(false, initialRequests, Tile.class);

    // 阴影和黑暗效果
    private FrameBuffer shadows = new FrameBuffer();
    private FrameBuffer dark = new FrameBuffer();

    // 空间索引优化
    private BlockQuadtree blockTree = new BlockQuadtree(new Rect(0, 0, 1, 1));
    private FloorQuadtree floorTree = new FloorQuadtree(new Rect(0, 0, 1, 1));
}
```

### 2. 阴影渲染系统

```java
// 阴影预渲染
Events.on(WorldLoadEvent.class, event -> {
    shadows.resize(world.width(), world.height());
    shadows.begin();
    Core.graphics.clear(Color.white);

    Draw.color(blendShadowColor);
    for(Tile tile : world.tiles){
        if(tile.block().hasShadow && (tile.build == null || tile.build.wasVisible)){
            Fill.rect(tile.x + 0.5f, tile.y + 0.5f, 1, 1);
        }
    }

    Draw.flush();
    shadows.end();
});

// 阴影绘制
public void drawShadows(){
    if(!shadowEvents.isEmpty()){
        updateShadows();
        shadowEvents.clear();
    }

    Draw.color(shadowColor);
    Draw.rect(Draw.wrap(shadows.getTexture()),
              world.unitWidth()/2f, world.unitHeight()/2f,
              world.unitWidth(), world.unitHeight());
}
```

### 3. 建筑裂纹系统

```java
// 裂纹纹理加载
Events.on(ClientLoadEvent.class, e -> {
    cracks = new TextureRegion[maxCrackSize][crackRegions];
    for(int size = 1; size <= maxCrackSize; size++){
        for(int i = 0; i < crackRegions; i++){
            cracks[size - 1][i] = Core.atlas.find("cracks-" + size + "-" + i);
        }
    }
});

// 裂纹绘制
public void drawCracks(Building build){
    if(build.damaged() && build.block.size <= maxCrackSize){
        int id = Mathf.randomSeed(build.pos()) % crackRegions;
        float intensity = build.healthf();

        Draw.alpha(1f - intensity);
        Draw.rect(cracks[build.block.size - 1][id],
                  build.x, build.y,
                  build.block.size * tilesize,
                  build.block.size * tilesize);
    }
}
```

## 光照渲染系统 (LightRenderer)

### 1. 动态光照架构

```java
public class LightRenderer{
    private static final int scaling = 4;           // 光照缩放因子

    private FrameBuffer buffer = new FrameBuffer(); // 光照缓冲区
    private Seq<Runnable> lights = new Seq<>();     // 光源列表
    private Seq<CircleLight> circles = new Seq<>(CircleLight.class); // 圆形光源池
    private int circleIndex = 0;
    private TextureRegion circleRegion;

    public void add(Runnable run){
        if(!enabled()) return;
        lights.add(run);
    }

    // 添加圆形光源
    public void add(float x, float y, float radius, Color color, float opacity){
        if(!enabled() || radius <= 0f) return;

        float res = Color.toFloatBits(color.r, color.g, color.b, opacity);

        if(circles.size <= circleIndex) circles.add(new CircleLight());

        var light = circles.items[circleIndex];
        light.set(x, y, res, radius);
        circleIndex++;
    }
}
```

### 2. 光照渲染管道

```java
public void draw(){
    if(!enabled()) return;

    // 重置光源索引
    circleIndex = 0;

    // 准备光照缓冲区
    buffer.resize(Core.graphics.getWidth() / scaling,
                  Core.graphics.getHeight() / scaling);
    buffer.begin(Color.clear);

    // 设置光照投影
    Draw.proj().setOrtho(0, 0, buffer.getWidth(), buffer.getHeight());

    // 绘制所有光源
    Draw.blend(Blending.additive);
    for(int i = 0; i < circleIndex; i++){
        var light = circles.items[i];
        Draw.color(light.color);
        Draw.rect(circleRegion, light.x / scaling, light.y / scaling,
                  light.radius / scaling * 2f, light.radius / scaling * 2f);
    }

    // 执行自定义光源
    for(var light : lights){
        light.run();
    }

    Draw.blend();
    buffer.end();

    // 应用光照着色器
    buffer.blit(Shaders.light);
    lights.clear();
}
```

### 3. 线性光源渲染

```java
public void line(float x, float y, float x2, float y2, float stroke, Color tint, float alpha){
    if(!enabled()) return;

    add(() -> {
        Draw.color(tint, alpha);

        float rot = Mathf.angleExact(x2 - x, y2 - y);
        TextureRegion ledge = Core.atlas.find("circle-end");
        TextureRegion lmid = Core.atlas.find("circle-mid");

        // 构建线段几何体
        Vec2 v1 = Tmp.v1.trnsExact(rot + 90f, stroke);
        float lx1 = x - v1.x, ly1 = y - v1.y;
        float lx2 = x + v1.x, ly2 = y + v1.y;
        float lx3 = x2 + v1.x, ly3 = y2 + v1.y;
        float lx4 = x2 - v1.x, ly4 = y2 - v1.y;

        // 构建顶点缓冲区并绘制
        buildLineVertices(lx1, ly1, lx2, ly2, lx3, ly3, lx4, ly4, ledge);
        Draw.vert(ledge.texture, vertices, 0, vertices.length);
    });
}
```

## 特效和后处理系统

### 1. 辉光效果 (Bloom)

```java
void setupBloom(){
    try{
        if(bloom != null){
            bloom.dispose();
            bloom = null;
        }
        bloom = new Bloom(true);
    }catch(Throwable e){
        settings.put("bloom", false);
        ui.showErrorMessage("@error.bloom");
        Log.err(e);
    }
}

// 辉光渲染
if(bloom != null){
    bloom.resize(graphics.getWidth(), graphics.getHeight());
    bloom.setBloomIntensity(settings.getInt("bloomintensity", 6) / 4f + 1f);
    bloom.blurPasses = settings.getInt("bloomblur", 1);

    // 捕获辉光区域（子弹层到特效层）
    Draw.draw(Layer.bullet - 0.02f, bloom::capture);
    // 渲染辉光效果
    Draw.draw(Layer.effect + 0.02f, bloom::render);
}
```

### 2. 像素化效果 (Pixelator)

```java
public class Pixelator{
    private FrameBuffer buffer = new FrameBuffer();
    private final int size = 3;

    public void drawPixelate(){
        if(!enabled()) return;

        buffer.resize(graphics.getWidth() / size, graphics.getHeight() / size);
        buffer.begin();
        draw(); // 正常渲染到缩小的缓冲区
        buffer.end();

        // 放大绘制回屏幕（产生像素化效果）
        Draw.blit(buffer, Shaders.screenspace);
    }
}
```

### 3. 冲击波效果

```java
public static class ShockwaveShader extends LoadShader{
    static final int max = 64;                     // 最大冲击波数量
    static final int size = 5;                     // 每个冲击波数据大小

    protected FloatSeq data = new FloatSeq();      // 冲击波数据 [x, y, radius, life, lifetime]
    protected FloatSeq uniforms = new FloatSeq();  // 着色器uniform数据

    public void add(float x, float y, float radius, float lifetime){
        if(data.size / size >= max){
            // 替换第一个条目
            var items = data.items;
            items[0] = x; items[1] = y; items[2] = radius;
            items[3] = 1f; items[4] = lifetime;
        }else{
            data.addAll(x, y, radius, 1f, lifetime);
        }
    }

    @Override
    public void apply(){
        int count = data.size / size;
        setUniformi("u_shockwave_count", count);

        if(count > 0){
            setUniformf("u_resolution", Core.camera.width, Core.camera.height);
            setUniformf("u_campos", Core.camera.position.x - Core.camera.width/2f,
                                   Core.camera.position.y - Core.camera.height/2f);

            // 构建uniform数组
            uniforms.clear();
            var items = data.items;
            for(int i = 0; i < count; i++){
                int offset = i * size;
                uniforms.add(
                    items[offset], items[offset + 1],           // xy
                    items[offset + 2] * (1f - items[offset + 3]), // radius * time
                    items[offset + 3]                           // time
                );
            }

            setUniform4fv("u_shockwaves", uniforms.items, 0, uniforms.size);
        }
    }
}
```

## 3D渲染系统

### 1. 星球渲染器

```java
public class PlanetRenderer{
    private Camera3D cam = new Camera3D();
    private Mat3D mat = new Mat3D();
    private FrameBuffer buffer = new FrameBuffer();

    public void render(PlanetParams params){
        buffer.resize(params.viewW, params.viewH);
        buffer.begin(Color.clear);

        // 设置3D摄像机
        cam.position.set(params.camPos);
        cam.direction.set(params.camDir);
        cam.up.set(params.camUp);
        cam.fov = params.fov;
        cam.update();

        // 渲染星球表面
        if(params.planet.mesh != null){
            Shaders.planet.camera = cam;
            Shaders.planet.planet = params.planet;
            Shaders.planet.lightDir.set(params.lightDir);
            Shaders.planet.ambientColor.set(params.ambientColor);

            params.planet.mesh.render(Shaders.planet, GL20.GL_TRIANGLES);
        }

        // 渲染大气层
        if(params.planet.hasAtmosphere){
            Shaders.atmosphere.camera = cam;
            Shaders.atmosphere.planet = params.planet;
            params.planet.atmosphereMesh.render(Shaders.atmosphere, GL20.GL_TRIANGLES);
        }

        buffer.end();
    }
}
```

### 2. 网格构建系统

```java
public class MeshBuilder{
    private FloatSeq vertices = new FloatSeq();
    private ShortSeq indices = new ShortSeq();

    public MeshBuilder vertex(float x, float y, float z, float nx, float ny, float nz, float u, float v){
        vertices.addAll(x, y, z, nx, ny, nz, u, v);
        return this;
    }

    public MeshBuilder triangle(int v1, int v2, int v3){
        indices.addAll((short)v1, (short)v2, (short)v3);
        return this;
    }

    public Mesh build(){
        Mesh mesh = new Mesh(true, vertices.size / 8, indices.size,
            VertexAttribute.position3D(),
            VertexAttribute.normal(),
            VertexAttribute.texCoords(0)
        );

        mesh.setVertices(vertices.toArray());
        mesh.setIndices(indices.toArray());
        return mesh;
    }
}
```

## 性能优化策略

### 1. 批量渲染优化

```java
// 方块批量渲染
public void drawBlocks(){
    // 按纹理分组以减少纹理切换
    Building.draw.sort(buildingComparator);

    String currentTexture = null;
    for(Building build : Building.draw){
        if(!Objects.equals(currentTexture, build.block.region.texture.toString())){
            Draw.flush(); // 提交当前批次
            currentTexture = build.block.region.texture.toString();
        }
        build.draw();
    }
    Draw.flush();
}
```

### 2. 视域裁剪优化

```java
// 仅渲染可见区域的方块
public void processBlocks(){
    int avgx = (int)(camera.position.x / tilesize);
    int avgy = (int)(camera.position.y / tilesize);
    int rangex = (int)(camera.width / tilesize / 2) + 3;
    int rangey = (int)(camera.height / tilesize / 2) + 3;

    if(avgx == lastCamX && avgy == lastCamY &&
       rangex == lastRangeX && rangey == lastRangeY) return;

    tileview.clear();

    // 使用四叉树加速可见性查询
    blockTree.getTiles(camera.position.x - camera.width/2,
                       camera.position.y - camera.height/2,
                       camera.width, camera.height, tileview);

    lastCamX = avgx; lastCamY = avgy;
    lastRangeX = rangex; lastRangeY = rangey;
}
```

### 3. 纹理优化

```java
// 流体动画纹理预加载
public void loadFluidFrames(){
    fluidFrames = new TextureRegion[2][Liquid.animationFrames];
    String[] fluidTypes = {"liquid", "gas"};

    for(int i = 0; i < fluidTypes.length; i++){
        for(int j = 0; j < Liquid.animationFrames; j++){
            fluidFrames[i][j] = atlas.find("fluid-" + fluidTypes[i] + "-" + j);
        }
    }
}

// 纹理过滤设置
Core.assets.load("sprites/clouds.png", Texture.class).loaded = t -> {
    t.setWrap(TextureWrap.repeat);
    t.setFilter(TextureFilter.linear);
};
```

### 4. 缓存策略

```java
// 阴影缓存
private FrameBuffer shadows = new FrameBuffer();

// 仅在方块变化时更新阴影
Events.on(TileChangeEvent.class, event -> {
    if(event.tile.build == null || !event.tile.build.inFogTo(player.team())){
        shadowEvents.add(event.tile);
    }
});

// 批量更新阴影
public void updateShadows(){
    if(shadowEvents.isEmpty()) return;

    shadows.begin();
    for(Tile tile : shadowEvents){
        if(tile.block().hasShadow){
            Draw.color(blendShadowColor);
            Fill.rect(tile.x + 0.5f, tile.y + 0.5f, 1, 1);
        }
    }
    shadows.end();
    shadowEvents.clear();
}
```

## 扩展性设计

### 1. 自定义着色器支持

```java
// 注册自定义着色器
public static void registerCustomShader(String name, String vertPath, String fragPath){
    Shader customShader = new Shader(Gdx.files.internal(vertPath),
                                     Gdx.files.internal(fragPath));
    customShaders.put(name, customShader);
}

// 使用自定义着色器
Draw.shader(customShaders.get("myCustomShader"));
// 渲染内容
Draw.shader();
```

### 2. 渲染器扩展

```java
// 添加环境渲染器
public void addEnvRenderer(int mask, Runnable render){
    envRenderers.add(new EnvRenderer(mask, render));
}

// 环境渲染器在特定环境下自动调用
for(var renderer : envRenderers){
    if((renderer.env & state.rules.env) == renderer.env){
        renderer.renderer.run();
    }
}
```

### 3. 自定义背景

```java
// 注册自定义背景
public void addCustomBackground(String name, Runnable render){
    customBackgrounds.put(name, render);
}

// 在规则中指定自定义背景
state.rules.customBackgroundCallback = "myCustomBackground";

// 背景渲染时自动调用
if(state.rules.customBackgroundCallback != null &&
   customBackgrounds.containsKey(state.rules.customBackgroundCallback)){
    customBackgrounds.get(state.rules.customBackgroundCallback).run();
}
```

## 总结

Mindustry的图形渲染系统展现了现代游戏引擎的优秀设计：

**核心优势：**
1. **分层渲染** - 清晰的渲染层次确保正确的深度排序
2. **着色器系统** - 丰富的GLSL着色器提供高质量视觉效果
3. **批量优化** - 智能批量渲染减少GPU状态切换
4. **视域裁剪** - 四叉树加速的可见性判断
5. **缓存策略** - 阴影、光照等效果的智能缓存
6. **3D支持** - 完整的3D渲染管道用于星球显示

**设计模式：**
- **策略模式** - 不同类型的渲染器策略
- **命令模式** - 光源和渲染命令队列
- **对象池模式** - 光源和特效对象复用
- **观察者模式** - 渲染事件和更新通知

这个渲染系统为Mindustry提供了出色的视觉表现，同时保持了优秀的性能和扩展性。开发者可以基于这个架构轻松添加新的视觉效果、着色器或渲染功能。