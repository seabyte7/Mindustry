# Mindustry 游戏逻辑功能综合文档

> 半策划案半程序文档：涵盖游戏机制设计理念与技术实现细节

## 文档概述

本文档从游戏设计和技术实现两个维度，全面阐述Mindustry的核心游戏逻辑功能。每个系统都会从"为什么设计成这样"和"如何技术实现"两个角度进行分析，帮助开发者理解游戏机制的设计意图和实现方法。

## 1. 核心游戏循环设计

### 设计理念
Mindustry采用实时策略塔防的混合玩法，核心循环为：**资源收集 → 建造防御 → 迎击敌人 → 扩展基地**。这个循环通过波次系统驱动，给玩家创造持续的紧张感和成就感。

### 技术实现架构

#### 主游戏循环 (Logic.java:415-503)
```java
// 核心更新循环
@Override
public void update(){
    Events.fire(Trigger.update);        // 触发全局更新事件
    universe.updateGlobal();           // 更新宇宙/战役状态

    if(state.isGame()){
        state.tick += Core.graphics.getDeltaTime() * 60f;  // 逻辑时钟
        state.teams.updateTeamStats();                     // 团队统计更新

        Time.update();                 // 时间系统更新
        logicVars.update();           // 逻辑变量更新
        Groups.update();              // 实体组更新

        checkGameState();             // 检查胜负条件
    }
}
```

#### 游戏状态管理 (GameState.java)
- **State枚举**: `menu`, `playing`, `paused` - 简单明确的状态机
- **游戏数据**: wave计数、时间、团队、规则等核心数据集中管理
- **事件驱动**: 状态变化通过事件系统通知各模块

### 系统交互设计
1. **事件系统**: `Events.fire()` 实现松耦合的模块通信
2. **ApplicationListener模式**: 各核心模块统一实现生命周期管理
3. **Groups系统**: 实体按类型分组，提供高效的批量操作

## 2. 波次与战斗系统

### 设计理念
波次系统是游戏的核心驱动力，设计目标是：
- **渐进式挑战**: 敌人强度逐步提升，给玩家适应时间
- **节奏控制**: 波间间隔让玩家有时间建设和准备
- **多样性**: 不同敌人类型组合，避免单调

### 波次生成算法 (Waves.java:258-444)

#### 设计参数化
```java
// 核心设计参数
UnitType[][] species = {
    {dagger, mace, fortress, scepter, reign},     // 地面重装
    {nova, pulsar, quasar, vela, corvus},         // 地面轻快
    {crawler, atrax, spiroct, arkyid, toxopid},   // 蜘蛛系
    {flare, horizon, zenith, antumbra, eclipse}   // 空中单位
};

float[] scaling = {1, 2f, 3f, 4f, 5f};          // 各层级单位强度倍数
int cap = 150;                                    // 最大波次上限
```

#### 渐进式难度曲线
```java
// 主序列生成 - 核心设计思想
for(int i = start; i < cap;){
    int next = rand.random(8, 16) + (int)Mathf.lerp(5f, 0f, difficulty) + curTier * 4;

    // 护盾值计算 - 线性增长确保挑战性
    float shieldAmount = Math.max((i - shieldStart) * shieldsPerWave, 0);

    out.add(new SpawnGroup(curSpecies[Math.min(curTier, curSpecies.length - 1)]){{
        unitAmount = f == start ? 1 : 6 / (int)scaling[ctier];      // 首波特殊处理
        unitScaling = (difficulty < 0.4f ? rand.random(2.5f, 5f) : rand.random(1f, 4f)) * scaling[ctier];
        shields = shieldAmount;
        shieldScaling = shieldsPerWave;
    }});
}
```

#### Boss战设计
```java
// Boss出现时机设计
int bossWave = (int)(rand.random(50, 70) * Mathf.lerp(1f, 0.5f, difficulty));
int bossSpacing = (int)(rand.random(25, 40) * Mathf.lerp(1f, 0.5f, difficulty));

// 最终Boss阶段 - 高密度Boss战
out.add(new SpawnGroup(...){{
    begin = finalBossStart;           // 120+波开始
    spacing = bossSpacing/2;          // 双倍频率
    shields = 500;                    // 高基础护盾
    shieldScaling = shieldsPerWave * 4; // 四倍护盾增长
    effect = StatusEffects.boss;      // Boss标记
}});
```

### 战斗状态管理

#### 胜负判定 (Logic.java:278-325)
```java
private void checkGameState(){
    // 战役模式胜利条件
    if(state.isCampaign()){
        // 玩家失败：核心被毁
        if(state.teams.playerCores().size == 0 && !state.gameOver){
            Events.fire(new GameOverEvent(state.rules.waveTeam));
        }

        // 胜利条件：达到胜利波次且无敌人
        if(state.enemies == 0 && state.wave >= state.rules.winWave && !spawner.isSpawning()){
            Call.sectorCapture();  // 触发区域征服
        }
    }
}
```

## 3. 资源与建造系统

### 设计理念
Mindustry的资源系统设计为**流式生产链**，而非传统RTS的存储式经济：
- **连续流动**: 资源通过传送带和管道连续传输
- **生产链**: 原料→中间产品→高级产品的复杂制造体系
- **物流挑战**: 传输效率成为游戏核心挑战之一

### 物品系统架构

#### 基础物品定义 (Items.java)
```java
// 物品分层设计
public static Item
    // 原料层
    copper, lead, sand, coal, titanium, thorium,
    // 中间产品层
    graphite, silicon, metaglass, plastanium,
    // 高级产品层
    surgeAlloy, phaseFabric, blastCompound;
```

#### 资源流动机制
1. **生产建筑**: 持续产出特定物品到输出端
2. **传输系统**: 传送带、管道、大型传送带等不同效率的传输方式
3. **消费建筑**: 从输入端持续消耗物品进行生产或功能

### 建造系统设计

#### 建筑分类体系
```java
// 功能性分类 (Blocks.java)
- 生产类: drill(钻头), pump(水泵), cultivator(培养器)
- 制造类: smelter(冶炼厂), kiln(熔炉), factory各级工厂
- 传输类: conveyor(传送带), junction(交叉口), router(分流器)
- 防御类: wall系列(城墙), turret系列(炮塔)
- 能源类: generator系列(发电机), battery(电池)
- 逻辑类: processor(逻辑处理器), display(显示器)
```

#### 建造约束设计
1. **资源需求**: 每个建筑有明确的物品消耗需求
2. **科技树**: 通过研究解锁高级建筑
3. **地形限制**: 某些建筑只能建在特定地形上
4. **能源依赖**: 高级建筑需要电力供应

## 4. 团队与多人游戏系统

### 设计理念
团队系统设计支持多种游戏模式：
- **合作模式**: 多玩家共同对抗AI敌人
- **对战模式**: 玩家之间竞争或PvP
- **观察模式**: 支持观战和回放功能

### 团队架构 (Teams.java)

#### 团队数据管理
```java
public class TeamData{
    public Team team;
    public CoreBuild core;                    // 核心建筑
    public Seq<CoreBuild> cores = new Seq<>(); // 多核心支持
    public Seq<BlockPlan> plans = new Seq<>(); // 建造计划队列
    public ItemStack[] items = new ItemStack[Item.all.size]; // 资源存储
    public BaseBuilderAI buildAi;             // 建造AI
    public RtsAI rtsAi;                       // RTS AI
}
```

#### AI团队行为设计
```java
// 敌人AI行为配置 (Logic.java:460-470)
if(data.team.rules().buildAi && !state.rules.pvp){
    if(data.buildAi == null) data.buildAi = new BaseBuilderAI(data);
    data.buildAi.update();   // 自动建造基地
}

if(data.team.rules().rtsAi){
    if(data.rtsAi == null) data.rtsAi = new RtsAI(data);
    data.rtsAi.update();     // RTS式策略AI
}
```

### 多人同步机制

#### 快照同步系统
- **状态快照**: 定期同步关键游戏状态
- **命令同步**: 玩家操作命令实时同步
- **回滚机制**: 处理网络延迟和丢包

## 5. 事件系统与模块通信

### 设计理念
事件系统实现**松耦合架构**，各模块通过事件进行通信而非直接调用，提高系统的可维护性和扩展性。

### 事件类型设计 (EventType.java)

#### 核心游戏事件
```java
// 生命周期事件
PlayEvent, ResetEvent, StateChangeEvent, WorldLoadEvent,

// 建造相关事件
BlockBuildEndEvent, BlockDestroyEvent, PayloadDropEvent,

// 战斗相关事件
UnitDestroyEvent, UnitCreateEvent, WaveEvent,

// 进度相关事件
UnlockEvent, SectorCaptureEvent, GameOverEvent
```

#### 事件监听机制 (Logic.java构造函数)
```java
// 建筑被摧毁时的幽灵建筑处理
Events.on(BlockDestroyEvent.class, event -> {
    if(!state.rules.ghostBlocks) return;
    Tile tile = event.tile;
    if(tile.build == null || !tile.block().rebuildable) return;
    tile.build.addPlan(true);  // 添加重建计划
});

// 建造完成时的统计更新
Events.on(BlockBuildEndEvent.class, event -> {
    if(event.team == state.rules.defaultTeam){
        state.stats.placedBlockCount.increment(event.tile.block());
    }
});
```

### 模块间通信模式
1. **事件发布**: `Events.fire(new SomeEvent(data))`
2. **事件监听**: `Events.on(EventType.class, handler)`
3. **触发器系统**: `Events.fire(Trigger.update)` 用于固定时机事件

## 6. 逻辑编程系统

### 设计理念
逻辑编程系统让玩家能够**编程控制**游戏中的建筑和单位，这是Mindustry独特的创新功能：
- **可视化编程**: 通过拖拽指令块创建程序
- **实时执行**: 逻辑在游戏中实时运行
- **硬件交互**: 可以控制炮塔、工厂、单位等游戏对象

### 逻辑执行器架构 (LExecutor.java)

#### 指令执行模式
```java
public class LExecutor{
    public LInstruction[] instructions;  // 指令数组
    public double[] vars;               // 变量数组
    public int counter;                 // 程序计数器

    public void runOnce(){
        instruction = instructions[counter];
        instruction.run(this);          // 执行当前指令
        if(counter >= instructions.length) counter = 0; // 循环执行
    }
}
```

#### 指令系统设计 (LStatements.java)
```java
// 基础指令类型
- set: 变量赋值
- op: 数学运算
- read: 读取建筑状态
- write: 控制建筑行为
- sensor: 传感器读取
- control: 单位控制
- jump: 条件跳转
```

### 逻辑与硬件交互
```java
// 炮塔控制示例
control.enabled building1 enabled    // 启用炮塔
control.shoot building1 x y enabled  // 向指定坐标射击

// 单位控制示例
control.move unit1 x y              // 移动单位
control.itemTake unit1 core1 copper  // 从核心取铜
```

## 7. 战役与宇宙系统

### 设计理念
战役系统提供**渐进式内容解锁**和**非线性探索**体验：
- **星球征服**: 玩家逐步征服不同星球上的区域
- **科技发展**: 通过研究解锁新的建筑和单位
- **资源管理**: 需要在不同区域间调配资源

### 宇宙架构 (Universe.java)

#### 星球-区域层级
```java
Planet -> Seq<Sector>              // 星球包含多个区域
Sector -> SectorInfo               // 区域包含详细信息
SectorInfo -> difficulty, threat   // 难度和威胁等级
```

#### 区域征服机制
```java
// 区域状态更新 (Logic.java:345-374)
@Remote(called = Loc.server)
public static void sectorCapture(){
    state.rules.waves = false;              // 停止波次
    state.rules.sector.info.wasCaptured = true; // 标记已征服
    Events.fire(new SectorCaptureEvent(state.rules.sector, initial));

    // 保存区域进度
    if(!headless && !net.client()){
        control.saves.saveSector(state.rules.sector);
    }
}
```

### 科技树系统

#### 研究解锁机制
```java
// 研究完成事件处理 (Logic.java:393-403)
@Remote
public static void researched(Content content){
    if(!(content instanceof UnlockableContent u)) return;

    boolean was = u.unlockedNowHost();
    state.rules.researched.add(u);          // 添加到已研究列表

    if(!was){
        Events.fire(new UnlockEvent(u));    // 触发解锁事件
    }
}
```

## 8. 性能优化与架构设计

### Groups系统优化

#### 实体分组管理
```java
// 按类型分组的实体管理
Groups.unit      // 所有单位
Groups.bullet    // 所有子弹
Groups.build     // 所有建筑
Groups.tile      // 所有瓦片
Groups.weather   // 天气效果
```

#### 空间分区优化
- **Quadtree**: 用于碰撞检测和邻近查找
- **分块更新**: 只更新活跃区域的实体
- **LOD系统**: 远距离实体降低更新频率

### 内存管理策略

#### 对象池模式
```java
// 避免频繁GC的关键设计
Pools.obtain(ClassName.class)  // 从对象池获取
Pools.free(object)             // 归还到对象池
Tmp.v1, Tmp.v2                 // 临时变量复用
```

#### Arc框架集合
```java
// 专门优化的集合类
Seq<T>           // 动态数组，比ArrayList更高效
ObjectMap<K,V>   // 哈希表
IntSeq           // 专门的int数组
```

## 9. 扩展性设计原则

### MOD系统支持
- **内容定义**: 通过继承基类添加新的建筑、单位、物品
- **脚本支持**: JavaScript脚本实现复杂逻辑
- **资源打包**: 自动处理贴图和音效资源

### 平台兼容性
- **输入抽象**: 统一的输入接口支持键鼠、触屏、手柄
- **渲染抽象**: 基于OpenGL的跨平台渲染
- **网络抽象**: 统一的网络接口支持不同平台

## 10. 开发实践总结

### 架构模式总结
1. **事件驱动**: 模块间通过事件通信，避免强耦合
2. **组件化**: 实体采用ECS架构，功能高度模块化
3. **数据驱动**: 游戏内容通过数据配置，便于调整和扩展
4. **状态机**: 清晰的状态管理，简化复杂逻辑

### 设计原则
1. **性能优先**: 大量使用对象池、临时变量复用等优化手段
2. **可扩展性**: 预留扩展接口，支持MOD开发
3. **平台兼容**: 避免平台特定API，确保跨平台运行
4. **代码可读性**: 简洁的命名和清晰的结构

### 技术债务管理
1. **版本兼容**: 存档格式向后兼容
2. **API稳定**: MOD接口尽量保持稳定
3. **重构策略**: 大型重构通过版本号管理影响范围

---

## 文档使用说明

本文档适用于以下开发场景：
1. **新功能设计**: 理解现有系统设计思路，确保新功能与整体架构一致
2. **系统调优**: 基于架构设计进行性能优化
3. **问题排查**: 通过理解系统交互关系快速定位问题
4. **MOD开发**: 了解游戏核心机制，开发高质量MOD
5. **代码维护**: 在修改代码时保持架构一致性

通过理解这些设计理念和实现细节，开发者能够更好地参与到Mindustry的开发和维护工作中。