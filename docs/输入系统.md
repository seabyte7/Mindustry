# 输入系统

Mindustry采用跨平台输入系统架构，通过抽象层和平台特定实现来支持桌面端（键盘鼠标）和移动端（触摸手势）的不同输入方式。

## 核心架构设计

### 1. 输入系统分层架构

```
┌─────────────────┬─────────────────┐
│   DesktopInput   │   MobileInput    │
│  (键盘鼠标输入)     │   (触摸手势输入)     │
├─────────────────┴─────────────────┤
│        InputHandler               │
│      (抽象输入处理器)                │
├───────────────────────────────────┤
│         Binding                   │
│      (按键绑定系统)                  │
├───────────────────────────────────┤
│         Core.input                │
│      (Arc框架输入层)                 │
└───────────────────────────────────┘
```

### 2. 关键类说明

| 类名 | 文件位置 | 职责 |
|------|----------|------|
| `Binding` | `mindustry/input/Binding.java` | 定义所有按键绑定和控制映射 |
| `InputHandler` | `mindustry/input/InputHandler.java` | 抽象输入处理器，包含RTS命令和建造系统 |
| `DesktopInput` | `mindustry/input/DesktopInput.java` | 桌面端输入实现 |
| `MobileInput` | `mindustry/input/MobileInput.java` | 移动端输入实现 |
| `PlaceMode` | `mindustry/input/PlaceMode.java` | 建造模式枚举 |
| `Placement` | `mindustry/input/Placement.java` | 建造放置工具类 |

## 按键绑定系统

### 1. 绑定分类体系

Mindustry使用枚举式按键绑定系统，将所有控制按键分为五大类：

```java
public enum Binding implements KeyBind{
    // 通用控制 (general)
    move_x(new Axis(KeyCode.a, KeyCode.d), "general"),
    move_y(new Axis(KeyCode.s, KeyCode.w)),
    mouse_move(new Axis(KeyCode.mouse_x, KeyCode.mouse_y)),

    // 命令控制 (command) - RTS指挥
    select(KeyCode.mouseLeft, "command"),
    deselect(KeyCode.mouseRight),
    command_mode(KeyCode.shiftLeft),

    // 建造控制 (blocks)
    category_prev(KeyCode.comma, "blocks"),
    category_next(KeyCode.period),
    block_select_01(KeyCode.num1),

    // 视角控制 (view)
    zoom_hold(KeyCode.controlLeft, "view"),
    zoom_in(KeyCode.scroll),
    zoom_out(KeyCode.scroll),

    // 多人游戏 (multiplayer)
    player_list(KeyCode.tab, "multiplayer"),
    chat(KeyCode.enter),
    chat_history_up(KeyCode.up)
}
```

### 2. 动态按键配置

```java
// 支持运行时重新绑定
public void rebind(Binding bind, KeyBind newkey){
    binds.put(bind, newkey);
    save();
}

// 轴控制支持（如WASD移动）
public class Axis implements KeyBind{
    public KeyCode min, max; // 负方向和正方向按键

    public float value(){
        return (max.isPressed() ? 1f : 0f) - (min.isPressed() ? 1f : 0f);
    }
}
```

## 输入处理核心逻辑

### 1. InputHandler抽象基类

`InputHandler`是所有输入处理的核心基类，包含超过2000行代码，涵盖：

```java
public abstract class InputHandler implements InputProcessor{
    // 核心状态管理
    public PlaceMode mode = PlaceMode.none;
    public Block block;
    public @Nullable BlockPlan lastSchematic;

    // 单位选择系统
    public Seq<Unit> selectedUnits = new Seq<>();
    public float playerSelectX, playerSelectY, playerSelectWidth, playerSelectHeight;

    // 建造规划系统
    public Seq<BuildPlan> plans = new Seq<>();
    public boolean planMatches(BuildPlan plan);

    // RTS命令系统
    public void commandUnits(Seq<Unit> units, Vec2 dest);
    public void selectUnits(float x, float y, float w, float h);

    // 抽象方法 - 由子类实现
    public abstract void buildPlacementUI(Table table);
    public abstract void buildUI(Group group);
}
```

### 2. 建造系统核心逻辑

#### 建造模式状态机

```java
public enum PlaceMode{
    none,           // 无操作
    breaking,       // 拆除模式
    placing,        // 建造模式
    schematicSelect,// 蓝图选择
    rebuildSelect   // 重建选择
}
```

#### 建造验证和放置

```java
// 建造计划验证
public boolean validPlace(int x, int y, Block type, int rotation){
    if(type == null) return false;

    // 检查建造条件
    if(!type.canPlaceOn(world.tile(x, y))) return false;
    if(!state.teams.get(player.team()).hasFlag(type.buildCostItems)) return false;

    // 检查覆盖规则
    Tile tile = world.tile(x, y);
    if(tile.block() != Blocks.air && !tile.block().replaceable) return false;

    return true;
}

// 建造计划队列管理
public void flushPlans(Seq<BuildPlan> plans){
    for(BuildPlan plan : plans){
        if(validPlan(plan)){
            Call.beginPlace(player, plan.block, plan.x, plan.y, plan.rotation);
        }
    }
}
```

### 3. RTS指挥系统

#### 单位选择机制

```java
// 框选单位
public void selectUnits(float x, float y, float w, float h){
    selectedUnits.clear();

    Units.nearby(player.team(), x, y, w, h, unit -> {
        if(unit.isPlayer()) return; // 排除玩家单位
        if(!unit.type.playerControllable) return; // 只选择可控单位

        selectedUnits.add(unit);
    });

    // 触发选择事件
    if(!selectedUnits.isEmpty()){
        Events.fire(new UnitSelectEvent(selectedUnits));
    }
}

// 单位分组系统
private ObjectMap<Integer, Seq<Unit>> unitGroups = new ObjectMap<>();

public void assignGroup(int number){
    if(selectedUnits.isEmpty()) return;

    Seq<Unit> group = new Seq<>(selectedUnits);
    unitGroups.put(number, group);
}

public void selectGroup(int number){
    Seq<Unit> group = unitGroups.get(number);
    if(group != null){
        selectedUnits.set(group);
        selectedUnits.removeAll(u -> u.dead());
    }
}
```

#### 命令队列系统

```java
// 移动命令
public void commandMove(Vec2 target){
    for(Unit unit : selectedUnits){
        if(unit.isCommandable()){
            Call.unitCommand(player, unit, UnitCommand.move, target.x, target.y);
        }
    }
}

// 攻击命令
public void commandAttack(Teamc target){
    for(Unit unit : selectedUnits){
        if(unit.canAttack(target)){
            Call.unitCommand(player, unit, UnitCommand.attack, target);
        }
    }
}

// 队列命令（Shift+点击）
public void queueCommand(UnitCommand command, float x, float y){
    for(Unit unit : selectedUnits){
        unit.plans.add(new CommandPlan(command, x, y));
    }
}
```

## 平台特定实现

### 1. 桌面端输入处理

`DesktopInput`专门处理键盘鼠标输入：

```java
public class DesktopInput extends InputHandler{
    // 鼠标状态追踪
    Vec2 movement = new Vec2();
    float mouseAngle;
    boolean panning, zooming;

    // 键盘快捷键处理
    @Override
    public boolean keyDown(int keycode){
        if(Core.input.keyDown(Binding.command_mode)){
            // Ctrl组合键处理
            if(keycode == KeyCode.s) state.saveWorld();
            if(keycode == KeyCode.z) undo();
            if(keycode == KeyCode.c) copySelection();
            if(keycode == KeyCode.v) pasteClipboard();
        }

        // 数字键选择建筑
        if(keycode >= KeyCode.num1 && keycode <= KeyCode.num9){
            int index = keycode - KeyCode.num1;
            selectBuilding(index);
        }

        return false;
    }

    // 鼠标滚轮缩放
    @Override
    public boolean scrolled(float amountX, float amountY){
        if(!state.isMenu()){
            renderer.scaleCamera(1f + amountY / 10f);
        }
        return true;
    }

    // 蓝图控制
    public void handleSchematic(){
        if(Core.input.keyTap(Binding.pick_schematic)){
            mode = PlaceMode.schematicSelect;
            schematics.showSelect();
        }

        if(mode == PlaceMode.schematicSelect){
            drawSchematicPreview();
        }
    }
}
```

### 2. 移动端输入处理

`MobileInput`处理触摸和手势输入：

```java
public class MobileInput extends InputHandler{
    // 触摸状态
    Vec2 vector = new Vec2();
    float lastZoom = 1f;
    boolean touching;

    // 多点触控手势
    @Override
    public boolean touchDown(int screenX, int screenY, int pointer, int button){
        if(pointer == 0){
            // 主触摸点 - 移动和选择
            handlePrimaryTouch(screenX, screenY);
        } else if(pointer == 1){
            // 双指触摸 - 缩放和平移
            handleSecondaryTouch(screenX, screenY);
        }

        return true;
    }

    // 手势识别
    public void detectGestures(float x, float y, int pointer){
        if(pointer == 0){
            // 长按检测
            if(touchTime > longPressTime){
                handleLongPress(x, y);
            }

            // 拖拽检测
            if(vector.len() > dragThreshold){
                handleDrag(x, y);
            }
        }
    }

    // 触摸UI适配
    @Override
    public void buildPlacementUI(Table table){
        // 移动端特殊UI布局
        table.button("@cancel", () -> mode = PlaceMode.none).size(120, 70);
        table.button("@confirm", this::confirmPlacement).size(120, 70);

        // 触摸友好的建筑选择网格
        buildBlockGrid(table, 4, 3); // 4x3网格布局
    }
}
```

### 3. 平台差异化处理

```java
// 根据平台选择输入处理器
public static InputHandler createHandler(){
    if(mobile){
        return new MobileInput();
    } else {
        return new DesktopInput();
    }
}

// 平台特定的控制提示
public void drawControlHints(){
    if(mobile){
        Draw.alpha(0.8f);
        font.draw("长按选择", x, y);
        font.draw("双指缩放", x, y - 40);
    } else {
        font.draw("右键取消", x, y);
        font.draw("滚轮缩放", x, y - 20);
        font.draw("Shift队列命令", x, y - 40);
    }
}
```

## 建造放置系统

### 1. 放置验证流程

```java
public class Placement{
    // 放置有效性检查
    public static boolean validPlace(Block block, Team team, int x, int y, int rotation){
        // 基础检查
        if(block == null || !block.canPlaceOn(world.tile(x, y))) return false;

        // 资源检查
        if(!team.hasFlag(block.buildCostItems)) return false;

        // 区域检查
        if(!block.canReplace(world.tile(x, y).block())) return false;

        // 特殊规则检查
        if(block.isMultiblock()){
            return validateMultiblock(block, x, y, rotation);
        }

        return true;
    }

    // 多块建筑验证
    public static boolean validateMultiblock(Block block, int x, int y, int rotation){
        int size = block.size;
        int offsetx = -(size-1)/2;
        int offsety = -(size-1)/2;

        for(int dx = 0; dx < size; dx++){
            for(int dy = 0; dy < size; dy++){
                int wx = x + dx + offsetx;
                int wy = y + dy + offsety;

                Tile tile = world.tile(wx, wy);
                if(tile == null || !tile.block().replaceable){
                    return false;
                }
            }
        }

        return true;
    }
}
```

### 2. 蓝图系统集成

```java
// 蓝图放置
public void placeSchematic(Schematic schem, int x, int y, int rotation){
    Seq<Stile> tiles = schem.tiles;

    for(Stile stile : tiles){
        int wx = x + stile.x;
        int wy = y + stile.y;
        int rot = (stile.rotation + rotation) % 4;

        if(Placement.validPlace(stile.block, player.team(), wx, wy, rot)){
            plans.add(new BuildPlan(wx, wy, rot, stile.block));
        }
    }

    // 执行建造计划
    flushPlans(plans);
}

// 蓝图预览渲染
public void drawSchematicPreview(Schematic schem, float x, float y){
    Draw.alpha(0.6f);

    for(Stile stile : schem.tiles){
        float wx = x + stile.x * tilesize;
        float wy = y + stile.y * tilesize;

        boolean valid = Placement.validPlace(stile.block, player.team(),
                                           (int)(x + stile.x), (int)(y + stile.y), stile.rotation);

        Draw.color(valid ? Color.white : Color.red);
        stile.block.drawBase(wx, wy);
    }

    Draw.reset();
}
```

## 输入事件流程

### 1. 事件处理管道

```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ 硬件输入事件   │───▶│ Arc输入处理   │───▶│ InputHandler │
└─────────────┘    └─────────────┘    └─────────────┘
                                            │
                                            ▼
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ 游戏逻辑响应   │◀───│ 事件分发      │◀───│ 具体输入处理   │
└─────────────┘    └─────────────┘    └─────────────┘
```

### 2. 输入优先级处理

```java
// 输入事件优先级队列
public boolean handleInput(InputEvent event){
    // 1. UI界面优先
    if(ui.chatfrag.shown() && event.isKeyboard()){
        return ui.chatfrag.keyDown(event.keyCode);
    }

    // 2. 暂停菜单优先
    if(state.isPaused() && ui.paused.shown()){
        return false; // 阻止游戏输入
    }

    // 3. 模态对话框优先
    if(ui.hasDialog()){
        return false;
    }

    // 4. 游戏输入处理
    return handleGameInput(event);
}

// 游戏输入上下文切换
public void switchInputContext(InputContext context){
    switch(context){
        case MENU:
            enableMenuControls();
            break;
        case GAME:
            enableGameControls();
            break;
        case EDITOR:
            enableEditorControls();
            break;
    }
}
```

## 性能优化

### 1. 输入事件池化

```java
// 避免频繁创建输入事件对象
private static final Pool<InputEvent> eventPool = Pools.get(InputEvent.class, InputEvent::new);

public void fireInputEvent(int type, float x, float y){
    InputEvent event = eventPool.obtain();
    event.set(type, x, y);

    handleEvent(event);

    eventPool.free(event); // 回收对象
}
```

### 2. 输入状态缓存

```java
// 缓存输入状态避免重复查询
private boolean[] keyStates = new boolean[256];
private long lastUpdateTime;

public boolean isKeyPressed(int keycode){
    long currentTime = Time.millis();
    if(currentTime - lastUpdateTime > 16){ // 60FPS更新
        updateKeyStates();
        lastUpdateTime = currentTime;
    }

    return keyStates[keycode];
}
```

## 总结

Mindustry的输入系统设计体现了优秀的跨平台架构思想：

**核心优势：**
1. **平台抽象化** - 通过InputHandler基类统一接口
2. **可配置绑定** - 用户可自定义所有按键映射
3. **RTS命令支持** - 完整的单位选择和命令系统
4. **建造系统集成** - 直观的建造放置和蓝图系统
5. **性能优化** - 对象池化和状态缓存

**设计模式：**
- **策略模式** - 不同平台的输入处理策略
- **命令模式** - RTS命令队列系统
- **状态模式** - 建造模式状态机
- **观察者模式** - 输入事件分发机制

这个输入系统为Mindustry提供了流畅的跨平台操作体验，同时保持了代码的可维护性和扩展性。开发者可以基于这个架构轻松添加新的输入方式或自定义控制方案。