# Mindustry 实体系统和代码生成

## 概述

Mindustry采用了创新的实体组件系统（ECS）架构，结合强大的注解处理器进行编译时代码生成。这种设计实现了高性能的实体管理、网络同步和模块化的功能组合，是整个游戏架构的核心创新。

## ECS架构设计

### 实体-组件-系统模式

Mindustry的ECS架构打破了传统的继承链，采用组合模式：

```
传统继承 (问题)：
Unit → FlyingUnit → ArmedFlyingUnit → HealerUnit

ECS组合 (解决方案)：
Entity + Unitc + Flyingc + Weaponc + Healc
```

### 组件定义

所有组件都继承自抽象类，使用`@Component`注解标记：

```java
@Component
@BaseComponent  // 标记为基础组件，所有实体都有
abstract class EntityComp {
    private transient boolean added;
    transient int id = EntityGroup.nextId();

    // 生命周期方法
    void update() {}     // 每帧更新
    void remove() {}     // 移除实体
    void add() {}        // 添加实体

    // 实体状态查询
    boolean isLocal() { return this == player; }
    boolean isRemote() { return this instanceof Unitc u && u.isPlayer() && !isLocal(); }

    // 序列化接口
    @InternalImpl abstract int classId();
    @InternalImpl abstract boolean serialize();
    void read(Reads read) {}
    void write(Writes write) {}
}
```

### 核心组件类型

#### 1. 位置组件（Posc）
```java
@Component
abstract class PosComp {
    transient float x, y;              // 世界坐标
    transient float lastX, lastY;      // 上一帧坐标
    transient float deltaX, deltaY;    // 位移增量

    void set(float x, float y) {
        this.x = x;
        this.y = y;
    }

    float dst(Posc other) {
        return Mathf.dst(x, y, other.x(), other.y());
    }
}
```

#### 2. 速度组件（Velc）
```java
@Component
abstract class VelComp implements Posc {
    @Import float x, y;    // 从Posc导入坐标
    transient float vel;    // 速度大小
    transient float vel;    // 速度角度

    void move(float vx, float vy) {
        x += vx;
        y += vy;
    }

    void lookAt(float x, float y) {
        rotation = Angles.angle(this.x, this.y, x, y);
    }
}
```

#### 3. 健康组件（Healthc）
```java
@Component
abstract class HealthComp {
    float health, maxHealth = 1f;
    transient boolean dead;

    void damage(float amount) {
        health -= amount;
        if(health <= 0 && !dead) {
            kill();
        }
    }

    void kill() {
        if(!dead) {
            dead = true;
            Events.fire(new UnitDestroyEvent(self()));
        }
    }

    void heal(float amount) {
        health = Math.min(health + amount, maxHealth);
    }
}
```

#### 4. 单位组件（Unitc）
```java
@Component
abstract class UnitComp implements Healthc, Velc, Rotc, Teamc, Statusc {
    UnitType type;
    transient float ammo;
    transient AIController controller;
    transient Seq<StatusEntry> statuses = new Seq<>();

    void lookAt(float angle) {
        rotation = Angles.angleDistSigned(rotation, angle) * Time.delta * type.rotateSpeed;
    }

    boolean canPass(int tileX, int tileY) {
        return type.flying || !world.solid(tileX, tileY);
    }

    void moveAt(Vec2 vector) {
        vel.set(vector).scl(type.speed);
    }
}
```

#### 5. 建筑组件（Buildingc）
```java
@Component(base = true)  // 建筑组件是基础组件
abstract class BuildingComp implements Posc, Teamc, Healthc, Buildingc {
    transient Tile tile;                  // 所在地块
    transient Block block;                // 方块类型
    transient Seq<Building> proximity;    // 相邻建筑
    transient int rotation;               // 朝向
    transient boolean enabled = true;     // 是否启用

    // 模块系统
    @Nullable PowerModule power;          // 电力模块
    @Nullable ItemModule items;           // 物品模块
    @Nullable LiquidModule liquids;       // 液体模块

    // 效率系统
    transient float efficiency;           // 基础效率
    transient float optionalEfficiency;   // 可选效率
    transient float potentialEfficiency;  // 潜在效率

    void updateTile() {
        // 建筑逻辑更新
        if(block.update && enabled) {
            block.updateTile(self());
        }
    }

    void onProximityUpdate() {
        // 邻接关系更新
        block.onProximityUpdate(self());
    }
}
```

## 注解处理器系统

### @EntityDef注解

实体通过`@EntityDef`注解定义，指定组件组合：

```java
// 地面机甲单位：基础单位 + 机甲移动
@EntityDef({Unitc.class, Mechc.class})
public static UnitType dagger;

// 飞行载具单位：基础单位 + 载具能力
@EntityDef({Unitc.class, Payloadc.class})
public static UnitType mega;

// 建筑实体：所有建筑的基础
@EntityDef(value = {Buildingc.class}, isFinal = false, genio = false, serialize = false)
abstract class BuildingComp;
```

**@EntityDef参数：**
- `value`: 组件接口列表
- `isFinal`: 是否为final类
- `pooled`: 是否使用对象池
- `serialize`: 是否生成序列化代码
- `genio`: 是否生成IO代码
- `legacy`: 是否为遗留类型

### 代码生成流程

#### 1. 编译时扫描
```java
@SupportedSourceVersion(SourceVersion.RELEASE_8)
public abstract class BaseProcessor extends AbstractProcessor {
    public static final String packageName = "mindustry.gen";

    @Override
    public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment env) {
        // 扫描所有@EntityDef注解
        for(Element elem : env.getElementsAnnotatedWith(EntityDef.class)) {
            processEntity(elem);
        }
        return false;
    }
}
```

#### 2. 实体类生成
```java
// 生成的实体类示例（简化版）
public class UnitEntity extends Unit implements Unitc, Mechc, Posc, Velc, Healthc {
    // 组合所有组件的字段
    private float x, y, vel, rotation, health, maxHealth;
    private UnitType type;
    private Team team;

    // 实现所有接口方法
    @Override public float x() { return x; }
    @Override public void x(float x) { this.x = x; }

    @Override public void update() {
        // 调用所有组件的update方法
        EntityComp_update();    // 基础实体更新
        UnitComp_update();      // 单位更新
        MechComp_update();      // 机甲更新
    }

    // 自动生成的序列化代码
    @Override
    public void write(Writes write) {
        write.f(x);
        write.f(y);
        write.f(health);
        write.s(type.id);
    }

    @Override
    public void read(Reads read) {
        x = read.f();
        y = read.f();
        health = read.f();
        type = content.unit(read.s());
    }
}
```

#### 3. 接口生成
```java
// 生成的组件接口
public interface Unitc extends Healthc, Velc, Rotc {
    UnitType type();
    void type(UnitType type);

    float ammo();
    void ammo(float ammo);

    AIController controller();
    void controller(AIController controller);

    // 默认实现
    default boolean canPass(int tileX, int tileY) {
        return type().flying || !Vars.world.solid(tileX, tileY);
    }
}
```

### @Import机制

组件可以通过`@Import`导入其他组件的字段：

```java
@Component
abstract class VelComp implements Posc {
    @Import float x, y;        // 从Posc导入坐标
    transient float velX, velY; // 自己的速度字段

    void move(float vx, float vy) {
        x += vx;  // 直接使用导入的坐标
        y += vy;
    }
}
```

### 方法优先级

使用`@MethodPriority`控制方法调用顺序：

```java
@MethodPriority(1)    // 低优先级，先执行
void updateMovement() {
    // 移动逻辑
}

@MethodPriority(10)   // 高优先级，后执行
void updateGraphics() {
    // 图形更新
}
```

## 网络同步系统

### @Remote注解

网络同步通过`@Remote`注解实现：

```java
public class UnitTypes {
    // 客户端调用，服务器执行
    @Remote(called = Loc.server)
    public static void unitCommand(Unit unit, UnitCommand command) {
        if(unit.team == player.team()) {
            unit.command(command);
        }
    }

    // 服务器调用，客户端执行
    @Remote(called = Loc.client, unreliable = true)
    public static void unitMove(Unit unit, float x, float y) {
        unit.set(x, y);
    }
}
```

### 网络包生成

注解处理器自动生成网络包类：

```java
// 自动生成的Call类
public class Call {
    // 客户端调用服务器方法
    public static void unitCommand(Unit unit, UnitCommand command) {
        if(Net.client()) {
            UnitCommandCallPacket packet = new UnitCommandCallPacket();
            packet.unit = unit.id;
            packet.command = command.id;
            Net.send(packet);
        } else {
            // 本地直接调用
            UnitTypes.unitCommand(unit, command);
        }
    }
}

// 自动生成的数据包类
public class UnitCommandCallPacket extends Packet {
    public int unit;
    public byte command;

    @Override
    public void read(Reads read) {
        unit = read.i();
        command = read.b();
    }

    @Override
    public void write(Writes write) {
        write.i(unit);
        write.b(command);
    }

    @Override
    public void handled() {
        Unit u = Groups.unit.getByID(unit);
        UnitCommand cmd = UnitCommand.all[command];
        if(u != null && cmd != null) {
            UnitTypes.unitCommand(u, cmd);
        }
    }
}
```

### 同步字段

使用`@SyncField`标记需要同步的字段：

```java
@Component
abstract class UnitComp {
    @SyncField(true)  // 线性插值
    float x, y;

    @SyncField(false) // 角度插值
    float rotation;

    @SyncField(value = true, clamped = true) // 限制在0-1
    float health;

    @SyncLocal       // 仅本地玩家不同步
    boolean selected;

    @NoSync          // 完全不同步
    transient float visualAlpha;
}
```

## 实体组管理

### Groups系统

自动生成的Groups类管理所有实体：

```java
public class Groups {
    // 类型化实体组
    public static EntityGroup<Unit> unit = new EntityGroup<>(Unit.class);
    public static EntityGroup<Bullet> bullet = new EntityGroup<>(Bullet.class);
    public static EntityGroup<Building> build = new EntityGroup<>(Building.class);

    // 特殊查询组
    public static EntityGroup<Unit> player = new EntityGroup<>(Unit.class);  // 玩家单位
    public static EntityGroup<Unit> boss = new EntityGroup<>(Unit.class);    // Boss单位

    // 空间索引组（用于碰撞检测）
    public static QuadTree<Unit> unitTree = new QuadTree<>();
    public static QuadTree<Bullet> bulletTree = new QuadTree<>();

    public static void update() {
        // 更新所有实体组
        unit.update();
        bullet.update();
        build.update();
    }

    public static void clear() {
        unit.clear();
        bullet.clear();
        build.clear();
    }
}
```

### @GroupDef注解

定义特殊的实体组：

```java
// 玩家单位组：包含Unitc且isPlayer=true的单位
@GroupDef(value = {Unitc.class}, mapping = true)
class PlayerGroup {
    boolean find(Unit unit) {
        return unit.isPlayer();
    }
}

// 碰撞组：具有空间索引的单位
@GroupDef(value = {Unitc.class}, spatial = true, collide = true)
class CollisionGroup {
}
```

## 性能优化

### 对象池化

```java
@EntityDef(value = {Bulletc.class}, pooled = true)
public static UnitType bulletType;

// 使用时从池中获取
Bullet bullet = Pools.obtain(Bullet.class, Bullet::new);
bullet.set(x, y);
bullet.add();

// 移除时归还池中
bullet.remove(); // 自动归还到池
```

### 内存布局优化

```java
// 组件字段按访问频率排序
@Component
abstract class UnitComp {
    // 高频访问字段放前面
    float x, y;                    // 位置（每帧访问）
    float health;                  // 血量（战斗时访问）

    // 低频访问字段放后面
    UnitType type;                 // 类型（偶尔访问）
    transient String lastCommand; // 调试信息（很少访问）
}
```

### 批量处理

```java
// 批量更新同类型实体
public void updateUnits() {
    // 按类型分组处理，提高缓存命中率
    for(UnitType type : content.units()) {
        Seq<Unit> units = Groups.unit.select(u -> u.type == type);
        for(Unit unit : units) {
            unit.update();
        }
    }
}
```

## 序列化系统

### 自动序列化

```java
@EntityDef(serialize = true)  // 自动生成序列化代码
public class Unit {
    // 自动生成的序列化方法
    @Override
    public void write(Writes write) {
        super.write(write);
        TypeIO.writeUnit(write, type);
        write.f(x);
        write.f(y);
        write.f(rotation);
        write.f(health);
        write.b(team.id);
    }

    @Override
    public void read(Reads read) {
        super.read(read);
        type = TypeIO.readUnit(read);
        x = read.f();
        y = read.f();
        rotation = read.f();
        health = read.f();
        team = Team.get(read.b());
        afterRead();
    }
}
```

### 版本兼容性

```java
// 序列化版本控制
public class EntityIO {
    public static final byte SAVE_VERSION = 1;

    public void writeEntity(Writes write, Entity entity) {
        write.b(SAVE_VERSION);
        write.s(entity.classId());
        entity.write(write);
    }

    public Entity readEntity(Reads read) {
        byte version = read.b();
        short classId = read.s();

        Entity entity = EntityMapping.map[classId].get();
        entity.read(read);
        return entity;
    }
}
```

## 调试和工具

### 实体查看器

```java
// 运行时实体信息
public class EntityDebugger {
    public void showEntityInfo(Entity entity) {
        Log.info("Entity: @ (@)", entity.getClass().getSimpleName(), entity.id);
        Log.info("Components: @", getComponentList(entity));
        Log.info("Position: (@, @)", entity.x(), entity.y());
        Log.info("Health: @/@", entity.health(), entity.maxHealth());
    }

    public Seq<String> getComponentList(Entity entity) {
        Seq<String> components = new Seq<>();
        if(entity instanceof Unitc) components.add("Unit");
        if(entity instanceof Buildingc) components.add("Building");
        if(entity instanceof Posc) components.add("Position");
        return components;
    }
}
```

### 代码生成调试

```java
// 注解处理器调试输出
public class EntityProcess {
    private void generateEntity(EntityDefinition def) {
        Log.info("Generating entity: @", def.name);
        Log.info("Components: @", def.components);
        Log.info("Generated methods: @", def.methods.size);

        // 输出生成的代码到调试文件
        writeDebugFile(def.name + ".debug", def.generatedCode);
    }
}
```

这个ECS系统和代码生成机制是Mindustry的核心创新，实现了高性能、类型安全和易于扩展的实体管理系统，为游戏的复杂功能提供了坚实的技术基础。