# Mindustry 内容系统

## 概述

Mindustry的内容系统是游戏的核心，定义了所有游戏元素：方块、物品、单位、液体、状态效果等。系统采用类型安全的设计，支持MOD扩展，并通过科技树系统控制解锁进度。

## 内容类型架构

### ContentType枚举

```java
public enum ContentType {
    item(Item.class),           // 物品：铜、铁、硅等资源
    block(Block.class),         // 方块：建筑、防御、生产设施
    bullet(BulletType.class),   // 子弹类型：不同的投射物
    liquid(Liquid.class),       // 液体：水、石油、岩浆等
    status(StatusEffect.class), // 状态效果：增益、减益效果
    unit(UnitType.class),       // 单位类型：各种作战单位
    weather(Weather.class),     // 天气系统：风暴、雨雪等
    sector(SectorPreset.class), // 预设关卡
    planet(Planet.class),       // 行星：不同的游戏世界
    team(TeamEntry.class),      // 队伍配置
    unitCommand(UnitCommand.class), // 单位指令
    unitStance(UnitStance.class),   // 单位姿态
}
```

### Content基类

所有游戏内容都继承自Content基类：

```java
public abstract class Content {
    public short id;                    // 唯一标识符
    public ModContentInfo minfo;        // MOD信息

    // 生命周期方法
    public void init() {}               // 初始化阶段
    public void postInit() {}           // 后初始化阶段
    public void load() {}               // 资源加载阶段
    public void loadIcon() {}           // 图标加载阶段

    public abstract ContentType getContentType();
}
```

## 内容定义系统

### 1. 物品系统（Items）

物品是游戏中的基础资源，具有多种属性：

```java
public class Items {
    public static Item copper, lead, titanium, thorium, silicon;

    public static void load() {
        copper = new Item("copper", Color.valueOf("d99d73")) {{
            hardness = 1;           // 硬度（影响开采难度）
            cost = 0.5f;           // 成本权重
            alwaysUnlocked = true; // 是否默认解锁
        }};

        titanium = new Item("titanium", Color.valueOf("8da1e3")) {{
            hardness = 3;          // 更高的硬度
            cost = 1.0f;          // 更高的成本
        }};

        thorium = new Item("thorium", Color.valueOf("f99e09")) {{
            explosiveness = 0.2f;  // 爆炸性
            radioactivity = 1f;    // 放射性
            flammability = 0f;     // 可燃性
        }};
    }
}
```

**物品属性详解：**
- `hardness`: 开采难度，影响钻头效率
- `cost`: 运输成本，影响AI优先级
- `explosiveness`: 爆炸威力
- `flammability`: 可燃性，影响火灾传播
- `radioactivity`: 放射性，造成伤害
- `color`: 显示颜色，用于UI和粒子效果

### 2. 方块系统（Blocks）

方块是游戏中的建筑元素，分为多个类别：

#### 生产方块
```java
// 钻头 - 开采资源
drill = new Drill("mechanical-drill") {{
    requirements(Category.production, with(Items.copper, 12));
    tier = 2;                  // 开采等级
    drillTime = 600f;         // 开采时间
    size = 2;                 // 占用空间
    drillEffect = Fx.pulverizeMedium; // 开采特效
}};

// 制造器 - 合成物品
siliconSmelter = new GenericCrafter("silicon-smelter") {{
    requirements(Category.crafting, with(Items.copper, 30, Items.lead, 25));
    outputItem = new ItemStack(Items.silicon, 1);
    size = 2;
    hasPower = true;
    hasLiquids = false;
    craftTime = 40f;
    updateEffect = Fx.smeltsmoke;
    consumes.power(0.50f);
    consumes.items(with(Items.coal, 1, Items.sand, 2));
}};
```

#### 防御方块
```java
// 墙体
copperWall = new Wall("copper-wall") {{
    requirements(Category.defense, with(Items.copper, 6));
    health = 80;
    insulated = true;     // 绝缘
    absorbLasers = true;  // 吸收激光
}};

// 炮塔
duo = new ItemTurret("duo") {{
    requirements(Category.turret, with(Items.copper, 35));
    ammo(
        Items.copper, Bullets.standardCopper,
        Items.graphite, Bullets.standardDense,
        Items.silicon, Bullets.standardHoming
    );
    spread = 4f;          // 散射角度
    shots = 2;            // 每次射击数量
    alternate = true;     // 交替射击
    reloadTime = 20f;     // 装填时间
    range = 100f;         // 射程
    shootCone = 15f;      // 射击圆锥角
}};
```

#### 分配方块
```java
// 传送带
conveyor = new Conveyor("conveyor") {{
    requirements(Category.distribution, with(Items.copper, 1));
    health = 45;
    speed = 0.03f;        // 传输速度
    displayedSpeed = 4.2f; // 显示速度
}};

// 路由器
router = new Router("router") {{
    requirements(Category.distribution, with(Items.copper, 3));
    buildCostMultiplier = 2f;
}};
```

### 3. 单位系统（UnitTypes）

单位使用组件系统定义，通过注解指定能力：

```java
public class UnitTypes {
    // 地面机甲单位
    @EntityDef({Unitc.class, Mechc.class})
    public static UnitType dagger, mace, fortress;

    // 腿部单位
    @EntityDef({Unitc.class, Legsc.class})
    public static UnitType crawler, atrax;

    // 飞行单位
    @EntityDef({Unitc.class})
    public static UnitType flare, horizon;

    // 载具单位
    @EntityDef({Unitc.class, Payloadc.class})
    public static UnitType mega;

    // 海军单位
    @EntityDef({Unitc.class, WaterMovec.class})
    public static UnitType risso;

    public static void load() {
        dagger = new UnitType("dagger") {{
            health = 130f;
            speed = 1.1f;
            accel = 0.5f;
            drag = 0.4f;
            hitSize = 8f;
            armor = 1f;

            weapons.add(new Weapon("dagger-weapon") {{
                length = 1.5f;
                reload = 15f;
                alternate = false;
                ejectEffect = Fx.shellEjectSmall;
                bullet = new BasicBulletType(2.5f, 9) {{
                    width = 7f;
                    height = 9f;
                    lifetime = 60f;
                }};
            }});
        }};
    }
}
```

**单位组件能力：**
- `Unitc`: 基础单位能力（移动、攻击）
- `Mechc`: 机甲能力（地面作战单位）
- `Legsc`: 腿部移动（复杂地形适应）
- `Payloadc`: 载具能力（运输其他单位/方块）
- `WaterMovec`: 水中移动能力
- `Tankc`: 坦克能力（重装甲单位）

### 4. 液体系统（Liquids）

```java
public class Liquids {
    public static void load() {
        water = new Liquid("water", Color.valueOf("596ab8")) {{
            heatCapacity = 0.4f;      // 热容量
            effect = StatusEffects.wet; // 附加状态效果
        }};

        slag = new Liquid("slag", Color.valueOf("ffa166")) {{
            temperature = 1f;          // 温度
            viscosity = 0.8f;         // 粘度
            effect = StatusEffects.melting;
            lightColor = Color.orange; // 发光颜色
        }};

        oil = new Liquid("oil", Color.valueOf("313131")) {{
            viscosity = 0.7f;
            flammability = 1.2f;      // 易燃性
            explosiveness = 1.2f;     // 爆炸性
            heatCapacity = 0.7f;
        }};
    }
}
```

## 科技树系统

### TechTree架构

科技树控制内容的解锁顺序，形成技术发展路径：

```java
public class TechTree {
    public static Seq<TechNode> all = new Seq<>();
    public static Seq<TechNode> roots = new Seq<>();

    // 科技节点定义
    public static TechNode node(UnlockableContent content, ItemStack[] requirements, Runnable children) {
        TechNode node = new TechNode(context, content, requirements);
        // 设置父子关系
        context = node;
        children.run(); // 执行子节点定义
        context = prev;
        return node;
    }
}
```

### 科技节点结构

```java
public static class TechNode {
    public int depth;                    // 科技树深度
    public UnlockableContent content;    // 关联的内容
    public ItemStack[] requirements;     // 研究需求
    public Seq<Objective> objectives;    // 额外目标
    public Seq<TechNode> children;       // 子节点
    public TechNode parent;              // 父节点
    public Planet planet;                // 关联行星
}
```

### 科技树示例

```java
public class SerpuloTechTree {
    public static void load() {
        // 根节点：核心
        nodeRoot("核心", Blocks.coreShard, () -> {
            // 基础生产
            node(Blocks.conveyor, () -> {
                node(Blocks.junction, () -> {
                    node(Blocks.router, () -> {
                        node(Blocks.launchPad, Seq.with(
                            new SectorComplete(SectorPresets.craters)
                        ), () -> {});

                        node(Blocks.distributor);
                        node(Blocks.sorter, () -> {
                            node(Blocks.invertedSorter);
                            node(Blocks.overflowGate, () -> {
                                node(Blocks.underflowGate);
                            });
                        });
                    });
                });
            });

            // 钻头科技线
            node(Blocks.mechanicalDrill, () -> {
                node(Blocks.mechanicalPump, () -> {
                    node(Blocks.conduit, () -> {
                        node(Blocks.liquidJunction);
                        node(Blocks.liquidRouter);
                        node(Blocks.liquidContainer);
                    });
                });

                node(Blocks.graphitePress, () -> {
                    node(Blocks.pneumaticDrill, () -> {
                        node(Blocks.cultivator, () -> {
                            node(Blocks.laserDrill);
                        });
                    });
                });
            });
        });
    }
}
```

### 研究目标系统

```java
public abstract class Objective {
    public boolean qualified() { return true; }
    public boolean complete() { return false; }
}

// 具体目标类型
public static class SectorComplete extends Objective {
    public SectorPreset preset;

    public boolean complete() {
        return preset.sector.isCaptured();
    }
}

public static class Produce extends Objective {
    public UnlockableContent content;

    public boolean complete() {
        return data.isUnlocked(content) &&
               state.stats.itemsDelivered.get(content, 0) > 0;
    }
}
```

## 内容加载流程

### 加载阶段

```java
public class ContentLoader {
    public void load() {
        // 阶段1：创建基础内容
        content.createBaseContent();

        // 阶段2：加载MOD脚本
        mods.loadScripts();

        // 阶段3：创建MOD内容
        content.createModContent();

        // 阶段4：初始化所有内容
        content.init();

        // 阶段5：加载图形资源
        content.load();
    }
}
```

### 内容注册机制

```java
public class ContentLoader {
    private Seq<Content>[] contentMap = new Seq[ContentType.all.length];

    public void handleContent(Content content) {
        contentMap[content.getContentType().ordinal()].add(content);
    }

    public <T extends Content> Seq<T> getBy(ContentType type) {
        return (Seq<T>)contentMap[type.ordinal()];
    }
}
```

## 内容配置系统

### 方块配置属性

```java
public abstract class Block extends UnlockableContent {
    // 基础属性
    public int size = 1;                    // 占用格子数
    public int health = -1;                 // 血量
    public float armor = 0f;                // 护甲
    public boolean solid = false;           // 是否实体
    public boolean destructible = true;     // 是否可破坏

    // 功能属性
    public boolean hasItems = false;        // 是否处理物品
    public boolean hasLiquids = false;      // 是否处理液体
    public boolean hasPower = false;        // 是否需要电力
    public boolean outputsPower = false;    // 是否产生电力

    // 经济属性
    public Category category;               // 建造分类
    public ItemStack[] requirements;        // 建造需求
    public float buildCostMultiplier = 1f;  // 建造成本倍数
}
```

### 消耗系统

```java
public class Consume {
    // 电力消耗
    consumes.power(1.5f);              // 消耗1.5单位电力
    consumes.powerCond(1.5f, enabled); // 条件电力消耗

    // 物品消耗
    consumes.item(Items.silicon);       // 消耗硅
    consumes.items(with(Items.copper, 2, Items.lead, 1)); // 多物品消耗

    // 液体消耗
    consumes.liquid(Liquids.water, 0.1f); // 消耗水

    // 可选消耗
    consumes.itemOptional(Items.coal);   // 可选燃料
}
```

### 生产系统

```java
public class Production {
    // 物品产出
    outputItem = new ItemStack(Items.graphite, 1);

    // 多物品产出
    outputItems = ItemStack.with(
        Items.metaglass, 2,
        Items.sand, 1
    );

    // 液体产出
    outputLiquid = new LiquidStack(Liquids.water, 12f);

    // 电力产出
    powerProduction = 2.5f;
}
```

## MOD内容扩展

### 内容定义文件

MOD可以通过JSON/HJSON文件定义新内容：

```json
{
    "type": "GenericCrafter",
    "name": "my-custom-crafter",
    "description": "自定义制造器",
    "size": 2,
    "hasPower": true,
    "hasItems": true,
    "craftTime": 60,
    "updateEffect": "smeltsmoke",
    "consumes": {
        "power": 1.5,
        "items": {
            "items": [
                {"item": "copper", "amount": 2},
                {"item": "silicon", "amount": 1}
            ]
        }
    },
    "outputItem": {"item": "surge-alloy", "amount": 1},
    "requirements": [
        {"item": "titanium", "amount": 50},
        {"item": "silicon", "amount": 80}
    ],
    "category": "crafting"
}
```

### 脚本扩展

```javascript
// MOD脚本示例
const myBlock = extend(GenericCrafter, "my-block", {
    init() {
        this.super$init();
        // 自定义初始化逻辑
    },

    updateTile() {
        this.super$updateTile();
        // 自定义更新逻辑
    }
});

myBlock.requirements = ItemStack.with(
    Items.copper, 50,
    Items.lead, 30
);
myBlock.size = 2;
myBlock.craftTime = 60;
```

## 性能优化

### 内容缓存

```java
// 内容ID映射，快速查找
private static ObjectIntMap<Content> contentIDs = new ObjectIntMap<>();

// 类型化访问，避免类型转换
public static <T extends Content> T content(int id, ContentType type) {
    return (T)contentMap[type.ordinal()].get(id);
}
```

### 延迟加载

```java
// 图形资源延迟加载
public void load() {
    if(!headless) {
        loadRegions();      // 只在有图形界面时加载
        loadSounds();       // 声音资源
        loadEffects();      // 特效资源
    }
}
```

这个内容系统为Mindustry提供了灵活而强大的游戏内容定义能力，支持复杂的科技发展路径和MOD扩展，是游戏核心玩法的基础。