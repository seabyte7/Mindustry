# Mindustry 游戏主循环系统设计文档

## 1. 游戏架构总览

### 1.1 多平台统一架构
Mindustry 采用基于Arc框架的多平台统一架构，通过模块化设计实现跨平台兼容：

**核心架构组件：**
- `ClientLauncher` - 客户端启动器，继承 `ApplicationCore`
- `DesktopLauncher` - 桌面端入口点
- 模块化系统设计，支持热插拔功能模块

**平台适配层：**
- 桌面端：Steam集成、Discord RPC、原生库加载
- 移动端：Android/iOS 特定优化
- 服务器：无头模式，纯逻辑处理

### 1.2 核心模块体系
游戏通过六大核心模块实现功能分离：

```
Logic (逻辑模块) → Control (控制模块) → Renderer (渲染模块) →
UI (界面模块) → NetServer (服务器网络) → NetClient (客户端网络)
```

## 2. 主循环系统架构

### 2.1 应用层主循环 (`ClientLauncher.update()`)

**循环职责：**
- FPS限制与性能控制
- 资源异步加载管理
- 模块调度与生命周期管理

**关键设计要点：**
1. **双阶段循环**：加载阶段 → 游戏运行阶段
2. **异步核心处理**：通过 `asyncCore` 处理并发任务
3. **帧率自适应**：根据设置动态调整目标FPS

### 2.2 逻辑层主循环 (`Logic.update()`)

这是游戏最核心的循环，负责整个游戏世界的状态推进：

**更新顺序与职责：**

#### 2.2.1 全局系统更新
- **事件系统触发**：`Events.fire(Trigger.update)`
- **宇宙系统更新**：`universe.updateGlobal()`
- **游戏状态检查**：确保处于游戏中且未暂停

#### 2.2.2 核心时间系统
```
时间推进计算：state.tick += delta * 60f
更新ID递增：state.updateId++
```
- **设计理念**：固定60FPS逻辑更新，与渲染帧率解耦
- **时间缩放**：支持游戏速度调节，影响所有时间相关计算

#### 2.2.3 团队与战争迷雾系统
- **团队统计更新**：`state.teams.updateTeamStats()`
- **战争迷雾计算**：`fogControl.update()`（仅在规则启用时）
- **视野系统**：动态计算各团队可见区域

#### 2.2.4 战役与宇宙系统
- **星球信息更新**：`state.rules.sector.info.update()`
- **科技树进度**：`universe.update()`
- **资源流通**：星球间贸易与资源传输

#### 2.2.5 AI系统调度
**基地建造AI** (`BaseBuilderAI`)：
- 建筑规划与布局优化
- 资源采集点选择
- 防御工事构建

**RTS战略AI** (`RtsAI`)：
- 宏观战略决策
- 单位编队管理
- 攻防节奏控制

#### 2.2.6 波次管理系统
- **波次计时器**：`state.wavetime` 倒计时
- **敌人生成触发**：`runWave()` → `spawner.spawnEnemies()`
- **难度曲线控制**：基于波次数和战役设置

#### 2.2.7 环境与天气系统
- **环境属性计算**：`state.envAttrs` 累积各种环境效果
- **天气效果更新**：`Groups.weather` 遍历所有天气实体
- **地形属性影响**：影响单位移动、建筑效率等

#### 2.2.8 实体系统核心更新
**关键调用**：`Groups.update()`
- 所有游戏实体的物理、AI、状态更新
- 实体间交互计算（碰撞、攻击、效果等）

### 2.3 渲染层循环 (`Renderer.update()` 与 `Renderer.draw()`)

#### 2.3.1 渲染更新阶段
**相机系统管理：**
- 镜头缩放插值：`camerascale = Mathf.lerpDelta(camerascale, dest, 0.1f)`
- 视口大小计算：基于屏幕分辨率和缩放比例
- 屏幕震动效果：战斗冲击感营造

**视觉设置同步：**
- 激光透明度、粒子密度等设置实时应用
- 画质选项动态调整

#### 2.3.2 层级渲染系统
**分层渲染设计：**
```
Layer.background (背景层)
↓
Layer.floor (地面层)
↓
Layer.block-1 (建筑阴影)
↓
Layer.block (建筑主体)
↓
Layer.units (单位层)
↓
Layer.bullet (子弹层)
↓
Layer.effect (特效层)
↓
Layer.light (光照层)
```

**设计优势：**
- 深度排序自动化
- 渲染批次优化
- 透明度混合控制

## 3. AI系统深度解析

### 3.1 波次生成系统 (`WaveSpawner`)

#### 3.1.1 生成规则设计
**SpawnGroup 配置系统：**
- **单位类型**：每波可包含多种不同敌人
- **数量计算**：`group.getSpawned(state.wave - 1)` 基于波次的指数增长
- **难度修正**：战役模式下应用 `campaignRules.difficulty.enemySpawnMultiplier`

#### 3.1.2 生成点选择算法
**飞行单位生成：**
- 地图边缘随机点生成
- 避开玩家防御区域
- 支持多点同时生成

**地面单位生成：**
- 预设生成点系统
- 路径可达性检查
- 生成点负载均衡

#### 3.1.3 生成时机控制
```
波次间隔计算：state.wavetime -= Time.delta
触发条件：wavetime <= 0 && rules.waves
生成冷却：Time.run(121f, () -> spawning = false)
```

### 3.2 基地建造AI (`BaseBuilderAI`)

#### 3.2.1 建筑规划算法
**资源点评估：**
- 资源密度分析
- 安全系数计算
- 运输距离优化

**防御布局策略：**
- 关键点位识别
- 火力覆盖计算
- 防御层次设计

**扩张决策逻辑：**
- 当前资源收入评估
- 威胁等级分析
- 扩张收益预测

#### 3.2.2 建造优先级系统
1. **生存需求**：核心建筑保护
2. **资源获取**：采集设施建设
3. **防御强化**：武器系统部署
4. **产能扩张**：生产设施升级

### 3.3 单位AI控制器系统

#### 3.3.1 寻路系统设计
**A*路径规划：**
- 动态障碍物避让
- 团队单位协调
- 地形成本计算

**群体移动算法：**
- 编队保持机制
- 拥挤避免策略
- 目标分配优化

#### 3.3.2 目标选择策略
**威胁评估模型：**
```
目标优先级 = 威胁系数 × 距离权重 × 价值系数
```

**目标类型优先级：**
1. 防御武器（直接威胁）
2. 生产设施（战略价值）
3. 资源建筑（经济打击）
4. 其他单位（战术清理）

#### 3.3.3 战斗行为树
**攻击模式选择：**
- 远程单位：保持安全距离
- 近战单位：快速突进
- 支援单位：位置优化

**生存策略：**
- 血量阈值判断
- 撤退路线规划
- 群体支援请求

### 3.4 RTS战略AI (`RtsAI`)

#### 3.4.1 宏观战略决策
**资源分配策略：**
- 攻防投入比例
- 科技发展方向
- 单位生产计划

**战术执行规划：**
- 攻击时机选择
- 兵力集结点
- 多线作战协调

#### 3.4.2 动态难度调节
**适应性算法：**
- 玩家实力评估
- AI强度动态调整
- 游戏节奏控制

## 4. 网络同步机制

### 4.1 同步策略设计

#### 4.1.1 快照同步系统
**全量同步：**
- 频率：每秒多次
- 内容：关键游戏状态
- 压缩：差分传输优化

**增量同步：**
- 建筑变化：~6分钟周期
- 血量更新：30秒周期
- 实时事件：立即同步

#### 4.1.2 冲突解决机制
**权威服务器模式：**
- 服务器为最终仲裁者
- 客户端预测 + 服务器确认
- 回滚机制处理延迟

### 4.2 性能优化策略
**数据压缩：**
- 位域压缩技术
- 预测编码减少传输量
- 批量操作合并

## 5. 关键系统交互流程

### 5.1 波次生成完整流程
```
1. Logic.update() 检查波次时间
2. runWave() 触发波次开始
3. WaveSpawner.spawnEnemies() 执行生成
4. SpawnGroup 规则解析
5. 单位实体创建和初始化
6. AI控制器分配
7. 加入Groups系统管理
```

### 5.2 AI决策执行链
```
1. BaseBuilderAI.update() 宏观规划
2. 建筑任务分解
3. 资源需求计算
4. 建造指令下发
5. 实体系统执行
6. 建筑状态更新
7. 下一周期规划调整
```

### 5.3 玩家输入响应流程
```
1. Control.update() 输入捕获
2. 操作类型识别
3. 权限验证
4. 网络同步（多人模式）
5. Logic系统执行
6. 实体状态变更
7. UI反馈更新
```

## 6. 性能优化设计

### 6.1 实体管理优化
**分组管理策略：**
- 按类型分组：units, buildings, bullets
- 按团队分组：team-based iteration
- 按激活状态分组：active/inactive separation

**更新优化：**
- 距离剔除：远距离实体简化更新
- LOD系统：不同详细级别的更新
- 时间片轮转：分帧处理大量实体

### 6.2 渲染性能优化
**批次渲染：**
- 相同纹理实体合并绘制
- 实例化渲染技术
- 遮挡剔除算法

**内存管理：**
- 对象池技术：避免频繁GC
- Tmp变量复用：减少临时对象
- 专用集合类：arc.struct.*

## 7. 扩展性设计

### 7.1 模组系统支持
**Hot-reload机制：**
- 脚本动态加载
- 内容定义外化
- 事件系统开放

**API设计：**
- 最小化核心修改
- 钩子函数体系
- 安全性沙箱

### 7.2 多平台适配
**抽象层设计：**
- Platform接口统一差异
- 条件编译机制
- 性能配置文件

## 8. 总结

Mindustry的主循环系统体现了优秀的游戏架构设计原则：

1. **清晰的职责分离**：逻辑、渲染、网络、AI各司其职
2. **高效的性能优化**：实体管理、渲染批次、内存控制
3. **强大的AI系统**：多层次AI决策，从战略到战术完整覆盖
4. **稳定的网络同步**：权威服务器模式保证一致性
5. **优秀的扩展性**：模组系统支持与多平台适配

这种设计使得游戏能够支持大规模的实时战略游戏玩法，同时保持流畅的性能表现和稳定的多人游戏体验。对于RTS游戏开发而言，这是一个值得深入学习的优秀架构范例。