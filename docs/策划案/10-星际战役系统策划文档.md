# Mindustry 星际战役系统策划文档

## 文档概述

本文档深入分析Mindustry星际战役系统的核心机制，包括扇区间物流运输、跨星球战略系统、资源经济模型和战役进程设计。通过对LaunchPad、LandingPad、Accelerator等核心设施的机制分析，阐述系统如何在三个空间尺度上创造深度的战略决策空间。

## 1. 系统总览：三重空间尺度的战略架构

### 1.1 空间层次设计

星际战役系统构建了三个层次的空间战略体系：

#### 扇区内部层（Local Scale）
- **空间范围**：单个扇区内的建设和防御
- **时间尺度**：分钟级的战术决策
- **核心机制**：资源生产、防御布局、科技发展
- **玩家行为**：实时建设、战术调整、资源优化

#### 扇区间层（Regional Scale）
- **空间范围**：同一星球的多个扇区
- **时间尺度**：小时级的资源调配
- **核心机制**：发射台/着陆台物流网络
- **玩家行为**：供应链规划、资源调配、扇区专化

#### 星球间层（Galactic Scale）
- **空间范围**：不同星球间的战略布局
- **时间尺度**：长期的发展规划
- **核心机制**：行星际加速器发射
- **玩家行为**：星球开拓、科技解锁、长期战略

### 1.2 系统协同关系

三个层次通过**资源流动**和**科技依赖**形成有机整体：

**向上传导**：扇区内的资源生产→扇区间的物流网络→星球间的技术突破
**向下反馈**：星球间的科技解锁→扇区间的新设施→扇区内的生产升级

这种设计确保了玩家在不同尺度上的决策都有意义，同时保持了系统的整体连贯性。

## 2. 扇区间物流系统：精密的供应链网络

### 2.1 发射台机制设计（LaunchPad）

#### 核心运作机制
```java
// 发射条件检查
(launchCounter += edelta()) >= launchTime && items.total() >= itemCapacity
```

**设计要素分析**：
- **时间门槛**：`launchTime = 1f`（1秒）确保发射不会过于频繁
- **容量要求**：必须填满才能发射，强制玩家进行批量规划
- **目标选择**：通过UI选择`destination`，支持动态调整供应路线

#### 发射负载系统
```java
LaunchPayload entity = LaunchPayload.create();
items.each((item, amount) -> entity.stacks.add(new ItemStack(item, amount)));
entity.lifetime(120f);  // 2秒飞行时间
```

**策划意图**：
- **可视化反馈**：120帧的飞行动画增强空间连接感
- **多元素发射**：支持混合物品发射，简化物流复杂度
- **即时清空**：发射后立即清空容器，避免重复发射

#### 多重物品支持
通过`acceptMultipleItems`参数控制是否允许混合发射：
- **专用发射台**：只发射单一物品，用于精准供应
- **混合发射台**：发射多种物品，用于综合补给

### 2.2 着陆台接收机制（LandingPad）

#### 接收排队系统
```java
static ObjectMap<Item, Seq<LandingPadBuild>> waiting = new ObjectMap<>();
// 优先级处理
pads.sort(p -> p.priority);
var first = pads.first();
```

**优先级机制设计**：
- **冲突解决**：多个着陆台请求同一物品时，按优先级分配
- **优先级循环**：使用后优先级后移，确保公平分配
- **动态调整**：`priority = Mathf.rand.nextInt()`提供基础随机性

#### 冷却剂消耗系统
```java
float consumeLiquidAmount = 100f;
Liquid consumeLiquid = Liquids.water;
```

**资源成本设计**：
- **运营成本**：着陆需要消耗冷却液体，增加运维考量
- **效率门槛**：`efficiency > 0f`确保只有正常供应的着陆台才能工作
- **容量限制**：单次着陆固定获得`itemCapacity`数量物品

#### 着陆动画与反馈
```java
float arrivalDuration = 150f;  // 2.5秒着陆过程
arrivingTimer += Time.delta / arrivalDuration;
```

**视觉设计价值**：
- **预期管理**：2.5秒着陆动画让玩家提前准备
- **沉浸感**：粒子效果和音效增强太空物流的真实感
- **进度反馈**：渐进式冷却液消耗提供明确的进度指示

### 2.3 供应链网络设计

#### 导入速率计算（SectorInfo.java）
```java
float importedPerFrame = imports[item.id]/60f;  // 每帧导入量
float framesBetweenArrival = itemCapacity / importedPerFrame;  // 到达间隔
```

**经济平衡机制**：
- **速率限制**：基于实际导出量计算导入频率，防止无限供应
- **容量约束**：单次运输量固定，大需求需要多次运输
- **时间成本**：运输间隔创造供应压力和规划需求

#### 供应链重定向功能
```java
// 自动重定向其他扇区的出口
for(Sector sector : state.getPlanet().sectors){
    if(sector.hasBase() && sector.info.hasExport(config)){
        sector.info.destination = state.getSector();
    }
}
```

**策略深度设计**：
- **一键整合**：自动重定向所有相关供应，简化管理
- **供应竞争**：多个着陆台可能争夺同一资源，需要协调
- **动态调整**：支持运行时修改供应网络拓扑

## 3. 跨星球战略系统：文明的太空扩张

### 3.1 行星际加速器机制（Accelerator）

#### 建造与充能系统
```java
consumeItems(launchBlock.requirements);  // 消耗核心建造材料
float powerBufferRequirement;  // 电力储备需求
```

**资源投资设计**：
- **前期投入**：需要建造完整的核心单元（如coreNucleus）
- **电力门槛**：`powerBufferRequirement`确保有足够电力支持发射
- **进度保存**：`progress`系统允许分阶段建造

#### 发射动画与体验
```java
float launchDuration = 120f;    // 发射持续时间
float chargeDuration = 220f;    // 充电持续时间
float buildDuration = 120f;     // 建造显示时间
```

**仪式感设计**：
- **分阶段体验**：建造→充电→发射的三阶段仪式
- **视觉震撼**：多层次粒子效果、镜头震动、音效配合
- **期待感营造**：长达5.5秒的完整流程增强成就感

#### 充电环特效系统
```java
int chargeRings = 4;  // 充电环数量
float ringRadBase = 60f, ringRadSpacing = 25f;  // 环形参数
```

**视觉层次设计**：
- **能量聚集感**：4个同心环由外向内收缩
- **技术感表达**：几何图形和动态效果表现高科技
- **进度可视化**：环形收缩直观表示充能进度

### 3.2 星球解锁路径

#### 候选星球系统
```java
public Seq<Planet> launchCandidates = new Seq<>();
boolean allowSelfSectorLaunch;  // 是否允许本星球内发射
```

**解锁机制设计**：
- **渐进开放**：`launchCandidates`控制可访问的星球列表
- **科技门槛**：不同星球需要不同的技术水平
- **本地探索**：`allowSelfSectorLaunch`支持星球内的远程建立前哨

#### 登陆时科技解锁
```java
sector.planet.unlockedOnLand.each(UnlockableContent::unlock);
```

**激励机制设计**：
- **即时奖励**：登陆时立即解锁相关科技
- **探索激励**：新科技激励玩家前往未知星球
- **差异化发展**：不同星球解锁不同的科技路线

### 3.3 核心载荷系统

#### 起始资源设计
```java
float launchCapacityMultiplier = 0.25f;  // 发射容量倍数
universe.updateLoadout((CoreBlock)launchBlock);
```

**平衡性考量**：
- **容量限制**：只能携带25%的常规容量，迫使精心规划
- **核心依赖**：发射的核心类型决定初始产能
- **重新开始感**：有限资源创造在新环境中的挑战感

## 4. 资源经济模型：精密的统计与平衡

### 4.1 生产统计系统（SectorInfo）

#### 多维度统计追踪
```java
ObjectMap<Item, ExportStat> production = new ObjectMap<>();     // 核心输入统计
ObjectMap<Item, ExportStat> rawProduction = new ObjectMap<>();  // 原始生产统计
ObjectMap<Item, ExportStat> export = new ObjectMap<>();         // 导出统计
ObjectMap<Item, ExportStat> imports = new ObjectMap<>();        // 导入统计
```

**数据驱动设计**：
- **生产链追踪**：区分原始生产和核心净输入，识别真实产能
- **进出口平衡**：独立统计导入导出，监控贸易平衡
- **移动平均**：使用`WindowedMean`平滑短期波动

#### 统计更新机制
```java
private static final int valueWindow = 60;  // 平均窗口大小
private static final float refreshPeriod = 60;  // 刷新周期（帧）
```

**时间尺度设计**：
- **秒级采样**：每秒更新一次统计数据
- **分钟级平均**：60秒窗口平滑短期波动
- **实时响应**：统计变化快速反映在供应决策中

### 4.2 经济平衡算法

#### 生产上限约束
```java
// 产能不能超过原始生产
production.get(item).mean = Math.min(production.get(item).mean, rawProduction.get(item).mean);

// 导出不能超过生产+库存输出
export.get(item).mean = Math.min(export.get(item).mean,
    rawProduction.get(item).mean + Math.max(-production.get(item).mean, 0));
```

**防作弊设计**：
- **物理约束**：不能导出超过实际生产的物品
- **库存流出**：允许导出库存物品，但限制在合理范围
- **数据一致性**：多重检查确保经济数据的逻辑一致性

#### 导入速率限制
```java
imports.get(item).mean = Math.min(imports.get(item).mean, getImportRate(state.getPlanet(), item));
```

**供应链现实性**：
- **运输能力限制**：导入不能超过运输网络的最大吞吐量
- **星球级约束**：考虑整个星球的运输能力
- **动态调整**：运输能力变化时自动调整导入上限

### 4.3 经济可视化系统

#### 实时数据展示
```java
() -> Core.bundle.format("landing.import", config.emoji(), (int)(perSecond * 60f))
```

**信息设计**：
- **直观表示**：使用表情符号和数字直观显示供应状况
- **时间单位**：统一使用"每分钟"为单位，符合玩家认知
- **动态更新**：实时反映供应网络的变化

## 5. 战役进程设计：层次化的征服体验

### 5.1 扇区威胁等级系统

#### 威胁度计算（Sector.java）
```java
public float threat;  // 0-1威胁等级
public boolean generateEnemyBase;  // 是否生成敌人基地

String[] threats = {"low", "medium", "high", "extreme", "eradication"};
int index = Math.min((int)(threat / 0.25f), threats.length - 1);
```

**难度递进设计**：
- **0.25步进**：威胁等级以25%为步进，提供5个明确的难度档次
- **视觉反馈**：威胁等级通过颜色变化直观表示
- **挑战激励**：高威胁等级通常伴随更好的资源回报

#### 扇区解锁机制
```java
public boolean unlocked(){
    return hasBase() || (preset != null && preset.alwaysUnlocked);
}
```

**渐进式开放**：
- **邻接解锁**：占领的扇区解锁相邻扇区
- **预设扇区**：关键位置可以直接解锁，作为战略要点
- **基地依赖**：只有建立基地的扇区才算真正控制

### 5.2 基地保卫与攻击模式

#### 攻击模式判定
```java
public boolean isAttacked(){
    if(isBeingPlayed()) return state.rules.waves || state.rules.attackMode;
    return save != null && (info.waves || info.attack) && info.hasCore;
}
```

**多重威胁来源**：
- **波次攻击**：传统的定时敌人波次
- **攻击模式**：持续的敌人压力
- **基地前提**：只有有核心的扇区才会被攻击

#### 敌人基地生成
```java
public boolean hasEnemyBase(){
    return ((generateEnemyBase && preset == null) || (preset != null && preset.captureWave == 0))
           && (save == null || info.attack);
}
```

**动态威胁**：
- **程序化生成**：大部分扇区的敌人基地由算法生成
- **预设控制**：重要位置可以手动设计敌人基地
- **状态依赖**：敌人基地的存在依赖于扇区的攻击状态

### 5.3 科技树集成

#### 星球特化科技
```java
public @Nullable TechNode techTree;  // 星球科技树根节点
public Seq<UnlockableContent> unlockedOnLand = new Seq<>();  // 登陆解锁内容
```

**科技分层**：
- **星球特色**：每个星球有独特的科技路线
- **探索奖励**：登陆新星球立即解锁部分科技
- **差异化发展**：不同星球的科技侧重不同

## 6. 数值设计与平衡

### 6.1 时间成本设计

#### 运输时间平衡
```java
LaunchPad.launchTime = 1f;          // 发射冷却：1秒
LandingPad.arrivalDuration = 150f;  // 着陆时间：2.5秒
LandingPad.cooldownTime = 150f;     // 着陆冷却：2.5秒
```

**时间层次设计**：
- **发射快速**：1秒冷却保证发射的流畅性
- **着陆缓慢**：2.5秒着陆增加仪式感和预期管理
- **冷却平衡**：2.5秒冷却防止过度频繁的运输

#### 建造时间设计
```java
Accelerator.launchDuration = 120f;  // 发射：2秒
Accelerator.chargeDuration = 220f;  // 充电：3.67秒
Accelerator.buildDuration = 120f;   // 建造：2秒
```

**仪式感营造**：
- **总时长控制**：7.67秒的完整流程，足够长以产生仪式感
- **分阶段体验**：三个阶段各有特色，避免单调等待
- **可中断性**：各阶段可被其他事件中断，保持游戏流畅性

### 6.2 容量与效率平衡

#### 运输容量设计
```java
LaunchPad.itemCapacity = 8000;      // 发射台容量
LandingPad.itemCapacity = variable; // 着陆台容量（依赖设施等级）
```

**批量运输激励**：
- **高容量设计**：鼓励玩家积累大批物品后批量运输
- **效率门槛**：必须填满才能发射，提高运输效率
- **规模经济**：大批量运输降低单位运输成本

#### 电力需求设计
```java
Accelerator.powerBufferRequirement;  // 电力储备需求
```

**技术门槛**：
- **电力缓冲**：需要大量电力储备，要求先进的电力系统
- **瞬时需求**：发射瞬间消耗全部储备，需要考虑电力规划
- **基础设施依赖**：跨星球发射需要强大的基础设施支撑

### 6.3 资源流动控制

#### 冷却剂消耗
```java
LandingPad.consumeLiquidAmount = 100f;  // 着陆冷却剂消耗
```

**运营成本设计**：
- **持续成本**：每次着陆都需要消耗冷却剂
- **资源门槛**：需要稳定的液体供应链支持
- **效率驱动**：鼓励玩家提高运输效率以降低运营成本

## 7. 玩家体验设计

### 7.1 决策层次设计

#### 短期战术决策（秒-分钟级）
- **资源分配**：当前生产的物品优先级
- **防御布局**：应对即将到来的敌人波次
- **运输时机**：何时发射物品到其他扇区

#### 中期战略规划（小时级）
- **供应链优化**：如何构建高效的扇区间物流网络
- **扇区专化**：不同扇区的功能定位和发展方向
- **资源均衡**：如何平衡不同扇区的资源需求

#### 长期发展战略（游戏周期级）
- **星球开拓序列**：选择下一个探索的星球
- **科技发展路线**：优先发展哪些技术分支
- **文明扩张策略**：如何在星系中建立统治地位

### 7.2 风险管理机制

#### 供应链脆弱性
- **单点故障**：关键扇区的丢失可能导致供应链断裂
- **运输延迟**：着陆台故障或资源不足导致供应中断
- **敌人威胁**：敌人攻击可能破坏供应网络

#### 风险应对策略
- **冗余设计**：建立多条供应路线避免单点故障
- **缓冲储备**：在关键位置建立资源储备
- **快速响应**：开发快速重建和修复能力

### 7.3 成就感塑造

#### 征服体验
- **扇区解放**：每个扇区的占领都带来即时的成就感
- **供应网络建成**：看到资源在自己构建的网络中流动
- **星球解锁**：踏足新星球的探索成就感

#### 掌控感培养
- **数据透明**：详细的统计数据让玩家了解系统状态
- **精确控制**：可以精确调整每个环节的参数
- **预测能力**：系统的确定性让有经验的玩家能够预测结果

#### 创造性表达
- **网络设计**：供应链网络的拓扑结构体现玩家的设计思路
- **效率追求**：追求最优的资源利用率和运输效率
- **风格选择**：不同的发展策略体现不同的游戏风格

## 8. 系统扩展性分析

### 8.1 内容扩展能力

#### 新星球集成
- **生成器系统**：新星球只需提供PlanetGenerator即可集成
- **科技路线**：独立的科技树支持差异化的星球特色
- **环境系统**：灵活的环境属性系统支持多样化的星球类型

#### 新设施类型
- **接口标准化**：Block系统的模块化设计支持新设施类型
- **功能扩展**：可以轻松添加新的运输、生产、防御设施
- **平衡整合**：新设施可以无缝集成到现有的经济平衡中

### 8.2 社区内容支持

#### 模组兼容性
- **开放架构**：核心系统对模组开放，支持深度定制
- **数据驱动**：大部分参数通过数据文件配置，便于修改
- **接口稳定**：核心接口设计考虑向后兼容性

#### 内容创作工具
- **地图编辑器**：支持自定义扇区和星球
- **平衡工具**：提供数值调整和测试工具
- **分享机制**：支持用户创作内容的分享和发布

## 结论

Mindustry的星际战役系统展现了在有限的技术框架内构建复杂战略体验的成功实践。该系统的核心价值在于：

1. **多尺度战略整合**：从扇区建设到星际扩张的完整战略体验
2. **经济系统的深度**：精密的资源流动控制和经济平衡机制
3. **渐进式复杂度**：从简单到复杂的学习曲线和挑战递增
4. **决策空间的丰富性**：在不同时间尺度上提供有意义的选择

对于策划设计而言，该系统提供了宝贵的经验：如何在保持系统简洁性的同时创造深度的策略空间，如何通过数据驱动的方式实现精确的经济平衡，以及如何通过仪式感的营造增强玩家的成就感。

星际战役系统的成功证明了，优秀的策略游戏系统不在于机制的复杂度，而在于机制间的有机整合和对玩家体验的深度理解。