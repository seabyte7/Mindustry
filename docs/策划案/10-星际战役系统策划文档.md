# Mindustry 星际战役系统策划文档

## 文档概述

本文档深入分析Mindustry星际战役系统的核心机制，包括扇区间物流运输、跨星球战略系统、资源经济模型和战役进程设计。通过对LaunchPad、LandingPad、Accelerator等核心设施的机制分析，阐述系统如何在三个空间尺度上创造深度的战略决策空间。

## 1. 系统总览：三重空间尺度的战略架构

### 1.1 空间层次设计

星际战役系统构建了三个层次的空间战略体系：

#### 扇区内部层（Local Scale）
- **空间范围**：单个扇区内的建设和防御
- **时间尺度**：分钟级的战术决策
- **核心机制**：资源生产、防御布局、科技发展
- **玩家行为**：实时建设、战术调整、资源优化

#### 扇区间层（Regional Scale）
- **空间范围**：同一星球的多个扇区
- **时间尺度**：小时级的资源调配
- **核心机制**：发射台/着陆台物流网络
- **玩家行为**：供应链规划、资源调配、扇区专化

#### 星球间层（Galactic Scale）
- **空间范围**：不同星球间的战略布局
- **时间尺度**：长期的发展规划
- **核心机制**：行星际加速器发射
- **玩家行为**：星球开拓、科技解锁、长期战略

### 1.2 系统协同关系

三个层次通过**资源流动**和**科技依赖**形成有机整体：

**向上传导**：扇区内的资源生产→扇区间的物流网络→星球间的技术突破
**向下反馈**：星球间的科技解锁→扇区间的新设施→扇区内的生产升级

这种设计确保了玩家在不同尺度上的决策都有意义，同时保持了系统的整体连贯性。

## 2. 扇区间物流系统：精密的供应链网络

### 2.1 发射台机制设计（LaunchPad）

#### 核心运作机制
```java
// 发射条件检查
(launchCounter += edelta()) >= launchTime && items.total() >= itemCapacity
```

**设计要素分析**：
- **时间门槛**：`launchTime = 1f`（1秒）确保发射不会过于频繁
- **容量要求**：必须填满才能发射，强制玩家进行批量规划
- **目标选择**：通过UI选择`destination`，支持动态调整供应路线

#### 发射负载系统的完整生命周期

发射负载系统涉及一个复杂的实体生命周期管理：

```java
// 1. 创建发射负载实体
LaunchPayload entity = LaunchPayload.create();
items.each((item, amount) -> entity.stacks.add(new ItemStack(item, amount)));
entity.lifetime(120f);  // 2秒飞行时间
entity.team(team);
entity.set(this);  // 设置起始位置
entity.add();      // 添加到世界中
```

**实体生命周期详解**：

1. **创建阶段**：
   - 复制发射台中的所有物品到载荷中
   - 设置120帧（2秒）的生存时间
   - 继承发射台的队伍属性

2. **飞行阶段**：
   - 载荷实体在世界中移动和渲染
   - 播放粒子效果和音效
   - 玩家可以看到物品在空中飞行

3. **到达处理**（LaunchPayload.remove()）：
```java
@Override
public void remove(){
    if(!state.isCampaign() || net.client()) return;

    Sector destsec = state.rules.sector.info.destination;

    if(team() == state.rules.defaultTeam && destsec != null && destsec != state.rules.sector){
        ItemSeq dest = new ItemSeq();

        for(ItemStack stack : stacks){
            dest.add(stack);
            // 关键：更新导出统计
            state.rules.sector.info.handleItemExport(stack);
            Events.fire(new LaunchItemEvent(stack));
        }

        // 两种模式的物品处理
        if(state.getPlanet().campaignRules.legacyLaunchPads){
            destsec.addItems(dest);  // 遗留模式：直接添加到目标扇区
        }
        // 新模式：等待着陆台接收
    }
}
```

**两种传输模式的深层区别**：

1. **遗留模式（Legacy Mode）**：
   - 物品直接传送到目标扇区的核心
   - 简单直接，类似传送门
   - 适用于简化的游戏模式

2. **现代模式（Modern Mode）**：
   - 物品进入着陆台的等待队列
   - 需要着陆台主动接收
   - 受限于着陆台的容量和冷却剂
   - 创造更真实的物流体验

#### 多重物品支持
通过`acceptMultipleItems`参数控制是否允许混合发射：
- **专用发射台**：只发射单一物品，用于精准供应
- **混合发射台**：发射多种物品，用于综合补给

### 2.2 着陆台接收机制（LandingPad）

#### 复杂的导入速率计算系统

着陆台最复杂的部分是其导入速率计算，这是一个多层次的经济平衡算法：

```java
// 每帧更新计时器
float[] imports = state.rules.sector.info.getImportRates(state.getPlanet());
for(Item item : content.items()){
    float importedPerFrame = imports[item.id]/60f;  // 每帧导入量
    if(importedPerFrame > 0f){
        float framesBetweenArrival = itemCapacity / importedPerFrame;  // 计算到达间隔
        state.rules.sector.info.importCooldownTimers.increment(item, 0f,
            1f / framesBetweenArrival * Time.delta);  // 增加计时器
    }
}
```

**算法深度解析**：

1. **基于帧率的精确计算**：
   - `imports[item.id]/60f`：将每秒导入量转换为每帧导入量（游戏运行在60FPS）
   - 这确保了无论游戏帧率如何变化，导入速率都保持一致

2. **容量驱动的间隔计算**：
   - `framesBetweenArrival = itemCapacity / importedPerFrame`
   - 例如：如果着陆台容量1000，每帧导入0.5个物品，则需要2000帧（33.3秒）到达一次
   - 这创造了**批量运输**而非连续流动的效果

3. **冷却计时器机制**：
   - `1f / framesBetweenArrival * Time.delta`：计算每帧应该增加的计时器值
   - 当计时器达到1.0时，触发一次着陆
   - `Time.delta`确保了暂停时计时器不会继续增长

#### 精妙的优先级轮换系统

当多个着陆台竞争同一物品时，系统使用了一个巧妙的优先级轮换机制：

```java
waiting.each((item, pads) -> {
    if(pads.size > 0){
        pads.sort(p -> p.priority);  // 按优先级排序

        var first = pads.first();  // 获得优先权的着陆台
        var head = pads.peek();    // 列表中的最后一个

        Call.landingPadLanded(first.tile);  // 执行着陆

        // 关键：优先级交换，确保公平轮换
        var tmp = first.priority;
        first.priority = head.priority;
        head.priority = tmp;

        pads.clear();  // 清空等待队列
    }
});
```

**轮换机制的精妙之处**：

1. **公平性保证**：获得物品的着陆台会被移到队列末尾
2. **避免饥饿**：防止某个着陆台永远得不到物品
3. **简单高效**：只需要交换两个数值，不需要复杂的队列操作
4. **一次性处理**：每种物品每帧只处理一次，避免重复分配

#### "假"着陆台机制的设计哲学

```java
public boolean isFake(){
    return team != state.rules.defaultTeam || !state.isCampaign();
}

if(isFake()){
    // 假着陆台：立即着陆，无需排队
    Call.landingPadLanded(tile);
}else{
    // 真着陆台：加入等待队列
    waiting.get(config, Seq::new).add(this);
}
```

**双重模式设计**：

1. **战役模式（真着陆台）**：
   - 严格遵循经济规律，需要真实的供应来源
   - 受限于导入速率和冷却计时器
   - 需要排队等待，体现资源稀缺性

2. **沙盒/敌人模式（假着陆台）**：
   - 作为无限物品源，立即满足需求
   - 用于自定义地图或敌人AI的需求
   - 简化了非战役模式的复杂度

#### 冷却剂消耗的渐进式设计

```java
// 着陆过程中渐进式消耗冷却剂
float toRemove = Math.min(consumeLiquidAmount / arrivalDuration * Time.delta,
                         consumeLiquidAmount - liquidRemoved);
liquidRemoved += toRemove;
liquids.remove(consumeLiquid, toRemove);
```

**渐进式消耗的策划价值**：

1. **过程可视化**：玩家可以看到冷却剂在着陆过程中逐渐消耗
2. **中断机制**：如果冷却剂不足，着陆会失败（隐含设计）
3. **精确控制**：确保每次着陆消耗恰好100单位冷却剂
4. **时间同步**：消耗速率与着陆动画完美同步

#### 着陆动画的数学美学

```java
// 着陆舱的位置计算
float cx = x;  // X坐标固定
float cy = y + Interp.pow4In.apply(fout) * (100f + Mathf.randomSeedRange(id() + 2, 30f));

// 旋转角度计算
float rotation = fout * (90f + Mathf.randomSeedRange(id(), 50f));
```

**数学插值的视觉效果**：

1. **pow4In插值**：创造加速下降的效果，模拟重力
2. **随机化高度**：100+随机30，让每个着陆台的着陆高度略有不同
3. **旋转效果**：基于剩余时间的旋转，创造螺旋下降感
4. **种子随机化**：使用建筑ID作为种子，确保每个着陆台有固定但不同的动画

### 2.3 供应链网络设计

#### 星球级经济统计的复杂算法（SectorInfo.java）

星球级的经济统计系统是整个供应链的大脑，它通过复杂的算法计算每个扇区的导入潜力：

```java
// 第一步：收集所有供应源的导出数据
public void refreshImportRates(Planet planet){
    if(importRateCache == null || importRateCache.length != content.items().size){
        importRateCache = new float[content.items().size];
    }else{
        Arrays.fill(importRateCache, 0f);  // 清零缓存
    }

    // 遍历所有可能的供应扇区
    eachImport(planet, sector -> sector.info.export.each((item, stat) -> {
        importRateCache[item.id] += stat.mean;  // 累加导出速率
    }));
}

// 第二步：查找所有导入来源
public void eachImport(Planet planet, Cons<Sector> cons){
    for(Sector sector : planet.sectors){
        Sector dest = sector.info.destination;
        // 复杂的条件判断
        if(sector.hasBase() &&                           // 必须有基地
           sector.info != this &&                        // 不是自己
           dest != null && dest.info == this &&          // 目标是当前扇区
           sector.info.anyExports()){                    // 有实际导出
            cons.get(sector);  // 找到一个供应源
        }
    }
}
```

**算法的多层复杂性**：

1. **全图扫描机制**：
   - 系统扫描整个星球的所有扇区
   - 识别哪些扇区设置了当前扇区作为目标
   - 这是一个O(n²)的算法，但通过缓存优化性能

2. **条件过滤系统**：
   - `hasBase()`：供应扇区必须有玩家基地
   - `anyExports()`：必须有实际的导出产量
   - `destination == this`：供应路线必须指向当前扇区
   - 多重条件确保只计算有效的供应链

3. **导入速率聚合**：
   - 将所有供应源的导出速率相加
   - 得到理论最大导入速率
   - 这个速率决定了着陆台的工作频率

#### 实时经济平衡的精密算法

经济系统还有一个复杂的平衡检查机制，防止数据不一致：

```java
// 生产上限约束 - 防止"凭空"生产
production.each((item, stat) -> {
    stat.mean = Math.min(stat.mean, rawProduction.get(item, ExportStat::new).mean);
});

// 导出上限约束 - 防止导出超过生产能力
export.each((item, stat) -> {
    float maxExport = rawProduction.get(item, ExportStat::new).mean +
                      Math.max(-production.get(item, ExportStat::new).mean, 0);
    stat.mean = Math.min(stat.mean, maxExport);
});

// 导入上限约束 - 防止导入超过运输能力
imports.each((item, stat) -> {
    stat.mean = Math.min(stat.mean, getImportRate(state.getPlanet(), item));
});
```

**三重约束机制**：

1. **生产约束**：核心物品变化不能超过实际工厂产量
2. **导出约束**：导出量 ≤ 工厂产量 + 核心库存消耗
3. **导入约束**：实际导入不能超过理论运输能力

这个三重约束确保了经济数据的物理一致性，防止了各种exploit和数据异常。

#### 供应链重定向功能
```java
// 自动重定向其他扇区的出口
for(Sector sector : state.getPlanet().sectors){
    if(sector.hasBase() && sector.info.hasExport(config)){
        sector.info.destination = state.getSector();
    }
}
```

**策略深度设计**：
- **一键整合**：自动重定向所有相关供应，简化管理
- **供应竞争**：多个着陆台可能争夺同一资源，需要协调
- **动态调整**：支持运行时修改供应网络拓扑

## 3. 跨星球战略系统：文明的太空扩张

### 3.1 行星际加速器机制（Accelerator）

#### 复杂的三阶段发射系统

加速器实现了一个精密的三阶段发射流程，每个阶段都有独特的机制和视觉表现：

```java
// 三个关键时长参数
float launchDuration = 120f;    // 发射阶段：2秒
float chargeDuration = 220f;    // 充电阶段：3.67秒
float buildDuration = 120f;     // 建造阶段：2秒
```

**阶段1：建造阶段（Build Phase）**
```java
// 建造进度计算
if(efficiency >= 0f){
    progress += Time.delta * efficiency / buildDuration;
    progress = Math.min(progress, 1f);
}

// 核心容量动态计算
for(ItemStack stack : launchBlock.requirements){
    capacities[stack.item.id] = stack.amount;  // 设置每种物品的容量限制
    itemCapacity += stack.amount;              // 累加总容量
}
```

**建造阶段的精密设计**：
1. **动态容量系统**：容量不是固定的，而是根据要发射的核心类型动态计算
2. **效率影响进度**：建造进度受电力效率影响，停电时暂停建造
3. **材料限制**：`consumeItems(launchBlock.requirements)`确保只有提供足够材料才能开始
4. **进度可视化**：通过`Shaders.blockbuild`着色器实现建造动画

**阶段2：充电阶段（Charge Phase）**
```java
// 充电条件检查
public boolean canLaunch(){
    return isValid() && state.isCampaign() && efficiency > 0f &&
           power.graph.getBatteryStored() >= powerBufferRequirement-0.00001f &&
           progress >= 1f && !launching;
}

// 电力消耗执行
power.graph.useBatteries(powerBufferRequirement);
```

**电力系统的深层复杂性**：
1. **缓冲区机制**：不是检查瞬时电力，而是检查电力网络的总储备
2. **精度处理**：使用`-0.00001f`的小偏移值处理浮点精度问题
3. **网络级消耗**：`useBatteries()`一次性消耗整个电力网络的储备
4. **多重条件**：同时检查战役状态、效率、进度、发射状态

**阶段3：发射阶段（Launch Phase）**
```java
// 发射序列启动
Time.runTask(launchDuration() - 6f, () -> {
    launching = false;
    sector.planet.unlockedOnLand.each(UnlockableContent::unlock);  // 解锁科技
    universe.clearLoadoutInfo();
    universe.updateLoadout((CoreBlock)launchBlock);                // 更新装备
    control.playSector(sector);                                    // 切换到目标扇区
});
```

**发射序列的精密时序**：
1. **提前解锁**：在实际到达前6帧解锁科技，避免过渡卡顿
2. **装备重置**：清空并重新计算携带物品，确保数据一致性
3. **场景切换**：在动画的最佳时机切换到目标扇区

#### 动态电力缓冲系统

```java
// 电力缓冲UI显示
addBar("powerBufferRequirement", b -> new Bar(
    () -> Core.bundle.format("bar.powerbuffer",
        UI.formatAmount((long)b.power.graph.getBatteryStored()),
        UI.formatAmount((long)powerBufferRequirement)),
    () -> Pal.powerBar,
    () -> b.power.graph.getBatteryStored() / powerBufferRequirement
));
```

**电力管理的策略深度**：
1. **网络级思考**：需要考虑整个电力网络的储备，而非单一建筑
2. **资源规划**：高电力需求迫使玩家提前规划电力基础设施
3. **时机选择**：什么时候发射成为战略决策，需要平衡电力积累和发射需求
4. **视觉反馈**：实时显示当前储备与需求的比例，辅助决策

#### 复杂的充电环动画系统

```java
// 充电环渲染算法
float spacing = 1f / (chargeRings + chargeRingMerge);
for(int i = 0; i < chargeRings; i++){
    float cfin = Mathf.clamp((chargeFout*ringSpeedup - spacing * i) /
                            (spacing * (1f + chargeRingMerge)));
    if(cfin > 0){
        drawRing(ringRadBase + ringRadSpacing * Mathf.pow(i, ringRadPow), cfin);
    }
}
```

**环形动画的数学美学**：
1. **时间分层**：4个环按照不同的时间偏移依次激活
2. **非线性半径**：`Mathf.pow(i, ringRadPow)`创造幂函数分布，外环更稀疏
3. **重叠效果**：`chargeRingMerge`参数控制环之间的重叠，创造流畅过渡
4. **加速效果**：`ringSpeedup = 1.4f`让动画比实际充电稍快，增强紧迫感

#### 环形绘制的几何算法

```java
protected void drawRing(float radius, float fin){
    float fout = 1f - fin;
    float rotate = Interp.pow4In.apply(fout) * 90f;  // 旋转角度计算
    float rad = radius + 20f * Interp.pow4In.apply(fout);  // 半径动态变化

    // 把手绘制
    for(int i = 0; i < 4; i++){
        float angle = i * 90f + 45f + rotate;
        Lines.beginLine();
        Lines.linePoint(Tmp.v1.trns(angle - ringHandleLen, rad * ringHandleTilt).add(x, y));
        Lines.linePoint(Tmp.v2.trns(angle, rad).add(x, y));
        Lines.linePoint(Tmp.v3.trns(angle + ringHandleLen, rad * ringHandleTilt).add(x, y));
        Lines.endLine(false);
    }
}
```

**几何设计的细节考量**：
1. **pow4In插值**：创造加速收缩效果，模拟能量聚集
2. **动态半径**：环在收缩过程中半径逐渐减小，增强聚集感
3. **把手机制**：四个把手（handles）创造机械感，每个把手由三个点连成折线
4. **倾斜效果**：`ringHandleTilt = 0.8f`让把手稍微向内倾斜，增强立体感

#### 闪电特效的随机化系统

```java
// 发射时的闪电效果
for(int i = 0; i < launchLightning; i++){
    float a = Mathf.random(360f);
    Lightning.create(team, lightningColor, lightningDamage,
        x + Angles.trnsx(a, lightningOffset),
        y + Angles.trnsy(a, lightningOffset),
        a, Mathf.random(lightningLengthMin, lightningLengthMax));
}

// 充电过程中的概率闪电
if(Mathf.chanceDelta(lightningLaunchChance * Interp.pow3In.apply(chargeFout))){
    // 创建随机闪电
}
```

**闪电系统的概率设计**：
1. **发射闪电**：确定性的20道闪电，营造发射瞬间的能量爆发
2. **充电闪电**：概率性闪电，频率随充电进度增加
3. **伤害机制**：闪电不仅是视觉效果，还会对周围单位造成伤害
4. **随机化参数**：角度、长度、位置都有随机性，避免重复感

#### 镜头控制的动态算法

```java
@Override
public float zoomLaunch(){
    float rawTime = launchDuration() - renderer.getLandTime();
    float shake = rawTime < chargeDuration ? Interp.pow10In.apply(Mathf.clamp(rawTime/chargeDuration)) : 0f;

    Core.camera.position.set(x, y).add(Tmp.v1.setToRandomDirection().scl(shake * 2f));

    if(rawTime < chargeDuration){
        // 充电阶段：从正常缩放到充电缩放
        float fin = rawTime / chargeDuration;
        return chargeZoomInterp.apply(Scl.scl(landZoomTo), Scl.scl(chargeZoomTo), fin);
    }else{
        // 发射阶段：从最小缩放到着陆缩放
        float rawFin = renderer.getLandTimeIn();
        float fin = 1f - Mathf.clamp((1f - rawFin) - (chargeDuration / (launchDuration + chargeDuration))) /
                                   (1f - (chargeDuration / (launchDuration + chargeDuration)));
        return landZoomInterp.apply(Scl.scl(landZoomFrom), Scl.scl(landZoomTo), fin);
    }
}
```

**镜头控制的电影级体验**：
1. **动态震动**：充电时震动强度逐渐增加，模拟能量积累
2. **分阶段缩放**：充电和发射使用不同的缩放曲线
3. **插值选择**：`pow4In`和`pow10In`创造不同的加速感受
4. **时间归一化**：复杂的时间计算确保缩放在正确的时机触发

### 3.2 星球解锁与科技集成

#### 候选星球筛选机制
```java
ui.planet.showPlanetLaunch(state.rules.sector,
    launchCandidates == null ? state.rules.sector.planet.launchCandidates : launchCandidates,
    sector -> {
        // 发射到选定星球
    });
```

**星球访问控制设计**：
1. **双重候选系统**：加速器可以覆盖星球的默认候选列表
2. **渐进解锁**：通过`launchCandidates`控制玩家可以访问的星球
3. **技术门槛**：不同的加速器可能有不同的发射能力

#### 科技解锁的精确时机
```java
// 在发射序列中的特定时机解锁科技
Time.runTask(launchDuration() - 6f, () -> {
    launching = false;
    sector.planet.unlockedOnLand.each(UnlockableContent::unlock);
    universe.clearLoadoutInfo();
    universe.updateLoadout((CoreBlock)launchBlock);
    control.playSector(sector);
});
```

**时机控制的微妙平衡**：
1. **提前解锁**：在实际到达前6帧解锁，确保UI状态正确
2. **原子操作**：科技解锁、装备更新、场景切换作为一个原子操作
3. **状态重置**：清空现有装备信息，避免数据污染

#### 装备传输的容量限制
```java
// 核心载荷系统（来自启动参数）
float launchCapacityMultiplier = 0.25f;  // 只能携带25%的容量
universe.updateLoadout((CoreBlock)launchBlock);
```

**容量限制的战略意义**：
1. **重新开始感**：有限的初始资源创造在新环境中的挑战
2. **核心选择重要性**：不同等级的核心提供不同的初始资源
3. **规划激励**：迫使玩家精心选择要携带的物品

### 3.3 核心着陆渲染系统

#### 复杂的着陆动画算法

```java
protected void drawLanding(float fin, float x, float y){
    float fout = 1f - fin;
    float scl = rawTime < chargeDuration ? 1f : Scl.scl(4f) / renderer.getDisplayScale();
    float s = launchBlock.region.width * launchBlock.region.scl() * scl * 3.6f * Interp.pow2Out.apply(fout);
    float rotation = Interp.pow2In.apply(fout) * 135f;

    // 推进器开启时机
    float thrustOpen = 0.25f;
    float thrusterFrame = fin >= thrustOpen ? 1f : fin / thrustOpen;
    float thrusterSize = Mathf.sample(CoreBlock.thrusterSizes, fin);
}
```

**着陆视觉的物理真实感**：
1. **大小变化**：核心随着接近地面逐渐变大，模拟透视效果
2. **旋转效果**：135度的旋转创造螺旋下降感
3. **推进器延迟**：推进器在着陆进行到25%时才开启，增强真实感
4. **动态推进器**：推进器大小根据着陆进度动态变化

#### 推进器火焰的层次渲染

```java
// 四个推进器火焰
for(int i = 0; i < 4; i++){
    Tmp.v1.trns(i * 90 + rotation, 1f);

    // 外层火焰（队伍颜色）
    Tmp.v1.setLength((launchBlock.size * tilesize/2f + 1f)*scl + strength*2f + offset);
    Draw.color(team.color);
    Fill.circle(Tmp.v1.x + x, Tmp.v1.y + y, 6f * strength);

    // 内层火焰（白色）
    Tmp.v1.setLength((launchBlock.size * tilesize/2f + 1f)*scl + strength*0.5f + offset);
    Draw.color(Color.white);
    Fill.circle(Tmp.v1.x + x, Tmp.v1.y + y, 3.5f * strength);
}
```

**火焰效果的层次设计**：
1. **双层结构**：外层队伍颜色，内层白色，模拟真实火焰
2. **动态强度**：火焰强度根据核心大小和推进器状态计算
3. **位置偏移**：考虑核心大小的偏移，确保火焰位置正确
4. **随机抖动**：`Mathf.absin(2f, 0.1f)`添加细微的抖动效果

#### 推进器的立体渲染系统

```java
protected void drawLandingThrusters(float x, float y, float rotation, float frame){
    CoreBlock core = (CoreBlock)launchBlock;
    float length = core.thrusterLength * (frame - 1f) - 1f/4f;

    // 两次渲染实现立体效果
    for(int j = 0; j < 2; j++){
        for(int i = 0; i < 4; i++){
            var reg = i >= 2 ? core.thruster2 : core.thruster1;  // 两种推进器材质
            float rot = (i * 90) + rotation % 90f;

            if(j == 1){
                // 第二次渲染：添加阴影效果
                Tmp.v1.rotate(-90f);
                Draw.alpha((rotation % 90f) / 90f * alpha);
                rot -= 90f;
            }
        }
    }
}
```

**立体推进器的渲染技巧**：
1. **双通道渲染**：两次渲染创造阴影和立体感
2. **材质交替**：四个推进器使用两种不同材质，增加细节
3. **动态透明度**：第二次渲染的透明度根据旋转角度动态变化
4. **长度计算**：推进器伸出长度根据着陆进度精确计算

## 4. 资源经济模型：精密的统计与平衡

### 4.1 多层次经济统计架构

#### 生产与消费的精确追踪

经济系统的核心是对每个扇区的资源流动进行精确追踪，这创造了一个**数据驱动的战略决策环境**：

**原始生产vs净产出区分**：
- **原始生产**：工厂的纯产出能力，不考虑本地消耗
- **净产出**：扣除本地消耗后的实际可供输出量
- **设计价值**：让玩家清楚了解扇区的真实经济能力

**移动窗口平滑机制**：
- **60秒统计窗口**：避免短期波动影响长期规划
- **实时更新**：每秒刷新数据，保持策略决策的时效性
- **设计哲学**：在数据精确性和实用性之间取得平衡

#### 经济数据的战略价值

这种精密的统计系统为玩家提供了**基于数据的战略规划能力**：

**扇区专化决策支持**：
- 玩家可以看到每个扇区在不同资源上的比较优势
- 数据驱动的扇区功能规划（生产基地vs中转站vs储备基地）
- 投资回报的量化分析

**供应链优化指导**：
- 实时的进出口数据帮助识别瓶颈
- 运输效率的可视化分析
- 供需匹配的精确调节

### 4.2 三重约束的经济平衡设计

#### 物理现实性约束

系统通过三重约束确保经济数据的物理可信性，防止各种exploit：

**生产约束原理**：
- **基本逻辑**：核心库存变化不能超过实际工厂产量
- **防止exploit**：阻止玩家通过"魔法生产"获得无限资源
- **策略影响**：迫使玩家真实构建生产线

**导出约束机制**：
- **核心思想**：导出量≤工厂产量+库存消耗
- **现实模拟**：允许短期消耗库存维持导出，但有上限
- **平衡考量**：在经济灵活性和现实性之间平衡

**导入约束体系**：
- **运输限制**：导入受到运输网络物理容量限制
- **星球级统筹**：考虑整个星球的总运输能力
- **动态调整**：运输基础设施变化时约束随之调整

#### 经济循环的设计哲学

这种约束体系创造了一个**自洽的经济生态**：

**正反馈循环控制**：
- 防止"雪球效应"：富裕扇区无法无限制地变得更富
- 投资回报递减：过度投资单一扇区的效益递减
- 多样化激励：鼓励平衡发展而非极端专化

**风险与机遇平衡**：
- 短期库存消耗允许应急响应
- 长期必须建立可持续的生产能力
- 投机性贸易有收益但也有风险

### 4.3 玩家认知友好的信息设计

#### 直观化数据呈现

复杂的经济系统需要直观的呈现方式，让玩家能够快速理解和决策：

**表情符号语言系统**：
- 每种资源用独特表情符号表示，建立视觉语言
- 颜色编码传达资源状态（充足、紧缺、平衡）
- 即时识别：经验玩家可以快速"阅读"经济状态

**分钟制时间单位**：
- 统一使用"每分钟"而非"每秒"，符合人类时间认知
- 便于心算和快速估算
- 与游戏的中期决策时间尺度匹配

**实时反馈系统**：
- 决策结果快速体现在数据中
- 趋势变化通过动画和颜色变化表现
- 异常情况通过警告色彩突出显示

#### 决策支持信息架构

信息设计的最终目标是**支持玩家做出更好的战略决策**：

**分层信息展示**：
- **概览层**：总体经济健康状况
- **细节层**：具体资源的进出口数据
- **趋势层**：变化方向和发展预测

**关键指标突出**：
- 优先显示影响决策的关键数据
- 隐藏或弱化技术性细节
- 通过视觉权重引导关注重点

**情境化信息**：
- 根据当前游戏阶段调整信息重点
- 在不同操作模式下突出相关信息
- 问题诊断时提供具体的数据支持

## 5. 战役进程设计：层次化的征服体验

### 5.1 威胁等级的心理设计学

#### 五档难度的认知映射

威胁等级系统通过精心设计的难度梯度，创造了**循序渐进的挑战体验**：

**难度命名的心理暗示**：
- **Low**：新手友好，建立信心的起点
- **Medium**：考验基础技能，确认学习成果
- **High**：挑战进阶技巧，需要策略思考
- **Extreme**：测试精通程度，要求完美执行
- **Eradication**：终极挑战，象征性的最高难度

**0.25步进的设计哲学**：
- **认知负担控制**：5个等级正好符合人类短期记忆容量
- **明确的进步感**：每个等级的跨越都有明显的成就感
- **避免选择困难**：选项不多不少，降低决策焦虑

#### 风险回报的经济学原理

威胁等级系统实现了**风险与回报的精确匹配**：

**资源激励设计**：
- 高威胁扇区通常拥有更丰富的资源或更有利的地理位置
- 稀有资源倾向于分布在危险区域，迫使玩家做出风险决策
- 资源回报的递增幅度确保玩家有动机挑战更高难度

**长期发展驱动**：
- 舒适区停留会导致发展瓶颈
- 科技解锁往往需要控制特定威胁等级的扇区
- 创造"被迫冒险"的战略压力

### 5.2 渐进式世界开放的设计智慧

#### 邻接解锁的空间心理学

扇区解锁机制遵循**空间认知的自然规律**：

**地理连续性原则**：
- 从已知区域向未知区域的自然扩张
- 符合人类对领土控制的直觉认知
- 避免了传统关卡式的突兀跳跃感

**控制感的渐进建立**：
- 每个新扇区都是已有领域的自然延伸
- 玩家可以预见下一步的扩张方向
- 创造"画地为王"的满足感

#### 基地建立的仪式感设计

基地建设不仅是游戏机制，更是**占领仪式的象征**：

**象征意义层面**：
- 核心建设代表文明在该地区的立足
- 基地完成标志着该扇区的正式归属
- 创造了"开拓者"的身份认同

**战略意义层面**：
- 基地是该扇区防御体系的核心
- 代表玩家在该地区的长期投资
- 成为后续扩张的稳定后方

### 5.3 动态威胁的紧张感营造

#### 多模式威胁的设计哲学

系统通过**多种威胁模式的组合**，创造了丰富的紧张感层次：

**波次攻击模式**：
- **节奏可控**：玩家可以在波次间隙进行建设和规划
- **准备时间**：允许玩家为下一波攻击做准备
- **预期管理**：明确的时间间隔降低焦虑感

**持续攻击模式**：
- **持续压力**：不间断的威胁迫使玩家保持警觉
- **效率要求**：必须在战斗中完成建设，考验多任务能力
- **极限体验**：为寻求挑战的玩家提供高强度体验

**敌人基地机制**：
- **主动威胁**：不再是被动防御，需要主动进攻
- **战略目标**：给玩家明确的攻击目标
- **胜利条件**：提供除了"生存"之外的胜利方式

#### 威胁状态的动态平衡

系统通过**威胁状态的动态调整**，保持长期的游戏张力：

**扇区状态转换**：
- 和平扇区可能因为特定事件变得危险
- 危险扇区在玩家强化防御后可能变得安全
- 动态变化防止玩家过度舒适

**威胁传播机制**：
- 邻近扇区的威胁可能相互影响
- 失去关键扇区可能导致连锁反应
- 创造了"多米诺骨牌"式的战略考量

### 5.4 科技解锁的激励机制设计

#### 探索驱动的科技发现

科技系统与探索紧密结合，创造了**知识发现的愉悦感**：

**星球特化科技的设计价值**：
- **环境适应性**：不同星球的科技反映其环境特色
- **探索奖励**：登陆新星球立即获得技术突破
- **差异化发展**：避免所有星球的千篇一律发展

**即时解锁机制**：
- **及时奖励**：在玩家付出探索成本后立即给予回报
- **能力扩展**：新科技为玩家提供新的战略选择
- **进步感强化**：技术突破创造明显的能力提升感受

#### 科技依赖的战略深度

科技系统通过**依赖关系网络**，创造了复杂的战略决策空间：

**探索序列的选择价值**：
- 不同的探索路线会解锁不同的科技分支
- 玩家需要根据发展需要规划探索顺序
- 早期的科技选择影响后期的发展路径

**资源与科技的互动**：
- 某些科技需要特定星球的资源才能充分发挥
- 科技解锁可能改变资源的相对价值
- 创造了探索、资源、科技三者间的循环互动

## 6. 数值设计与平衡：精密的用户体验调优

### 6.1 时间感知的心理学应用

#### 多层次时间体验的设计哲学

时间设计不仅是技术参数，更是**塑造玩家心理感受的关键工具**：

**发射台的即时满足设计**：
- **1秒冷却**的背后是"即时反馈"的心理学原理
- 短冷却时间让玩家的操作意图快速转化为游戏行动
- 避免了"等待焦虑"，保持操作流畅感
- **设计目标**：让玩家感觉自己在主动"推动"事件发生

**着陆台的期待管理**：
- **2.5秒着陆时间**创造了"期待-满足"的心理循环
- 足够短以维持注意力，足够长以建立仪式感
- 配合视觉效果创造"从天而降"的震撼体验
- **设计目标**：让资源到达成为值得期待的事件

#### 跨星球发射的仪式感工程

加速器的**7.67秒总流程**是精心设计的仪式感体验：

**三阶段心理节奏**：
- **建造阶段（2秒）**：准备期，建立紧张感
- **充电阶段（3.67秒）**：高潮期，积累到巅峰
- **发射阶段（2秒）**：释放期，情感爆发

**时间比例的黄金分割**：
- 充电阶段占总时长的48%，符合注意力的最佳持续时间
- 分阶段设计避免了单调的长时间等待
- 每个阶段都有独特的视觉和听觉反馈

### 6.2 容量设计的行为引导

#### 批量思维的培养

8000单位的发射台容量不是随意设定，而是**引导玩家建立批量思维**的策略工具：

**认知负荷管理**：
- 大容量迫使玩家从"零散运输"转向"批量规划"
- 减少微操作，增强战略思考的重要性
- 提高单次决策的影响力和重要性

**规模经济教育**：
- 通过游戏机制教育玩家"规模经济"概念
- 批量运输提供更好的效率，模拟现实经济规律
- 培养玩家的长期规划能力

#### 运输效率的激励设计

"必须填满才能发射"的机制创造了**效率优化的内在动机**：

**完美主义的利用**：
- 利用玩家追求完美的心理，推动效率优化
- 部分满载运输在心理上产生"浪费感"
- 鼓励玩家优化生产和运输的时序匹配

**资源管理技能培养**：
- 迫使玩家学会预测和规划资源需求
- 发展库存管理和供应链优化能力
- 这些技能在游戏内外都有价值

### 6.3 成本结构的战略深度

#### 多维成本的平衡艺术

星际战役系统通过**多维成本结构**创造了丰富的战略选择空间：

**电力成本的门槛效应**：
- 大量电力储备需求创造了"技术门槛"
- 不是每个扇区都能支持跨星球发射
- 迫使玩家在不同扇区间进行功能分工

**冷却剂成本的持续压力**：
- 每次着陆的100单位冷却剂消耗
- 创造了"运营成本"的概念
- 让运输变成需要经济支撑的活动，而非免费行为

#### 成本敏感度的玩家分层

不同类型的玩家对成本的敏感度不同，系统通过**渐进式成本设计**满足不同需求：

**新手友好的入门门槛**：
- 基础运输成本相对较低
- 容错空间足够大，失误不会造成灾难性后果
- 学习曲线平缓，避免挫败感

**高手向的优化空间**：
- 精密的成本优化为高级玩家提供挑战
- 效率极限的追求创造了"速通"和"完美运营"的可能
- 为长期游戏提供持续的优化动机

### 6.4 数值反馈的心理强化

#### 数字的心理魔力

星际战役系统巧妙利用了**数字对人类心理的影响**：

**整数的认知友好性**：
- 100单位冷却剂、8000容量等整数易于记忆和计算
- 减少认知负荷，让玩家专注于战略决策
- 便于心算和快速估算

**进度的可视化**：
- 明确的数值变化创造了"进步感"
- 容量填充、倒计时等可视化元素增强参与感
- 让抽象的游戏机制变得具体可感

#### 成就感的数值化包装

系统通过**数值化的成就展示**，放大玩家的成就感：

**效率指标的正反馈**：
- "每分钟X单位"的显示方式直观展示效率
- 效率提升的数值化表现创造明确的进步感
- 便于玩家间的比较和竞争

**规模感的数字震撼**：
- 大数字（8000、100000+）创造"工业规模"的震撼感
- 数字增长的视觉化表现增强掌控感
- 让玩家感受到文明发展的宏大规模

## 7. 玩家体验设计：多层次的心流体验

### 7.1 认知负荷的精密管理

#### 决策层次的时间分离设计

星际战役系统通过**时间尺度分离**，避免了认知过载，创造了清晰的决策层次：

**即时反应层（秒级）**：
- **直觉性决策**：敌人攻击时的应急响应，依靠肌肉记忆
- **操作流畅性**：建设、修理、资源调配的即时操作
- **反馈即时性**：行动结果立即可见，满足即时成就感
- **设计价值**：让玩家在紧张时刻仍能保持控制感

**战术思考层（分钟级）**：
- **局部优化**：单个扇区内的布局优化和效率提升
- **资源平衡**：生产线的协调和瓶颈识别
- **时机判断**：何时发射物资、何时强化防御
- **设计价值**：培养玩家的系统思维和优化能力

**战略规划层（小时-天级）**：
- **全局视野**：跨扇区的发展规划和资源配置
- **长期投资**：科技路线选择和星球开拓序列
- **风险管理**：供应链冗余设计和危机预案
- **设计价值**：给予玩家"文明领袖"的宏大体验

#### 认知切换的无缝衔接

系统设计了**平滑的认知模式切换机制**，避免玩家在不同思维层次间的突兀跳跃：

**视觉缩放的心理暗示**：
- 从局部建设视角到全球战略视角的视觉过渡
- UI元素的层次化显示，不同缩放级别显示不同信息
- 信息密度的渐进变化，避免信息爆炸

**时间感知的节奏调节**：
- 紧急事件会自动拉回玩家的注意力到即时层
- 和平时期自然引导玩家进入规划模式
- 关键决策点通过视觉和听觉提示强调重要性

### 7.2 掌控感的渐进构建

#### 从混沌到秩序的征服体验

星际战役系统巧妙地设计了**从混沌走向秩序**的心理历程：

**初期的不确定性**：
- 新扇区的探索带来未知感和紧张感
- 资源分布的随机性创造发现的惊喜
- 敌人威胁的不可预测性增加挑战感

**中期的掌控建立**：
- 供应网络的建成创造"万物皆在掌控"的感受
- 数据统计系统让玩家"看透"经济运行规律
- 威胁等级的明确化让风险变得可管理

**后期的完美追求**：
- 效率优化成为新的挑战源泉
- 系统性能的极限探索满足完美主义倾向
- 创造性表达通过独特的网络设计实现

#### 失控与重控的动态平衡

系统通过**适度的混沌注入**，防止玩家过度舒适：

**威胁的动态性**：
- 新的敌人攻击模式打破既有防御体系
- 资源枯竭迫使供应链重构
- 技术解锁改变现有的最优策略

**机遇的随机性**：
- 新星球的发现带来发展机遇
- 资源丰富区域的偶然发现
- 敌人弱点的意外暴露

### 7.3 社交认同与个性表达

#### 策略风格的个性化空间

虽然是单人游戏，但系统为玩家提供了**丰富的个性表达空间**：

**发展哲学的体现**：
- **扩张主义者**：快速占领新领土，承担高风险
- **完美主义者**：精细优化每个环节，追求极致效率
- **保守主义者**：稳扎稳打，建立坚实的防御体系
- **冒险主义者**：优先探索新技术和新星球

**网络拓扑的创意表达**：
- 供应链网络的设计反映玩家的空间思维
- 扇区功能分工体现资源管理哲学
- 应急预案的设计展现风险管理风格

#### 成就分享的社区价值

系统设计支持**隐性的社区互动**：

**数据化成就的可比性**：
- 效率指标便于玩家间的非直接竞争
- 建设截图分享展示创意设计
- 攻略分享促进策略交流

**学习榜样的激励作用**：
- 高水平玩家的策略成为学习目标
- 不同风格的成功案例提供多样化参考
- 社区讨论深化对系统的理解

## 8. 系统设计哲学：可持续的深度体验

### 8.1 复杂性的渐进释放

#### 学习曲线的人性化设计

星际战役系统遵循**"易学难精"**的设计哲学：

**入门门槛的精心控制**：
- 前几个扇区的威胁等级刻意降低
- 基础机制通过引导逐步介绍
- 错误容忍度在新手阶段特意提高

**深度的延迟满足**：
- 复杂功能在玩家建立基础理解后逐步开放
- 高级策略需要玩家自主发现和实验
- 精通需要长期的实践和思考

#### 系统内在逻辑的一致性

所有机制都遵循**统一的设计原则**：

**物理直觉的尊重**：
- 资源流动遵循现实世界的物理规律
- 时间和空间的限制创造真实感
- 因果关系的明确性便于理解和预测

**经济规律的模拟**：
- 供需关系决定资源价值
- 规模经济效应鼓励批量思维
- 机会成本让每个决策都有意义

### 8.2 长期参与的动机设计

#### 内在动机的培养

系统着重培养玩家的**内在驱动力**：

**胜任感的逐步建立**：
- 从简单任务的成功完成开始
- 逐步增加挑战难度，保持适度紧张
- 技能提升的可感知性增强自信

**自主性的充分保障**：
- 多条发展路径避免唯一解
- 玩家可以按照自己的节奏推进
- 策略选择的丰富性支持个性化发展

**目标感的多层次构建**：
- 短期目标提供即时满足
- 中期目标维持持续参与
- 长期目标创造深度投入

#### 重玩价值的系统设计

系统通过**多重变化因素**确保重玩价值：

**程序化内容的随机性**：
- 地图生成的随机性创造新鲜感
- 资源分布的变化要求策略调整
- 威胁模式的多样性避免套路化

**策略空间的开放性**：
- 多种有效策略的并存
- 不同发展路径的可行性
- 创新策略的发现空间

### 8.3 设计传承与创新启示

#### 对策略游戏设计的贡献

星际战役系统的成功为策略游戏设计提供了宝贵经验：

**多尺度整合的方法论**：
- 不同时间和空间尺度的有机结合
- 局部与全局决策的层次化设计
- 即时与长期利益的平衡考量

**数据驱动决策的实现**：
- 复杂信息的简化呈现
- 关键指标的突出强调
- 趋势变化的可视化表达

#### 对游戏行业的启发意义

该系统展现了**深度策略体验的现代化表达**：

**传统策略游戏的现代化改造**：
- 保留深度思考的核心价值
- 适配现代玩家的注意力特点
- 融入当代的技术表现手段

**单机游戏的社交化元素**：
- 在单机框架下创造社区价值
- 通过间接方式实现玩家互动
- 维持个人体验的完整性

**教育价值的游戏化实现**：
- 通过游戏机制教授复杂概念
- 让抽象思维变得具体可感
- 在娱乐中实现能力培养

## 结论：深度策略设计的现代典范

Mindustry的星际战役系统为现代策略游戏设计提供了一个**深度与可及性并重**的成功范例。该系统的核心价值不在于技术复杂度，而在于对**人类认知规律和心理需求**的深刻理解。

### 核心设计价值

**1. 多层次决策空间的构建**
- 通过时间尺度分离，创造了从即时反应到长期规划的完整决策体系
- 每个层次都有独特的挑战和满足感，避免了认知过载
- 不同类型玩家可以在不同层次找到适合的挑战深度

**2. 心理学驱动的用户体验设计**
- 从混沌到秩序的征服体验满足了人类的掌控欲望
- 数值化的成就展示放大了玩家的成就感
- 多样化的个性表达空间支持不同游戏风格的发展

**3. 经济系统的现实性模拟**
- 三重约束机制确保了经济数据的物理可信性
- 供需关系和规模经济效应教育玩家理解现实经济规律
- 风险回报的精确匹配创造了有意义的战略选择

**4. 可持续参与的动机设计**
- 内在动机的培养超越了外在奖励的短期刺激
- 程序化内容的随机性确保了长期重玩价值
- "易学难精"的设计哲学平衡了新手友好性和深度体验

### 对策略游戏设计的启示

**设计哲学层面**：
- **人本主义设计**：以玩家的认知能力和心理需求为出发点
- **系统性思维**：关注机制间的有机整合而非单一功能的复杂化
- **渐进式复杂度**：通过学习曲线的精心设计实现可及性与深度的平衡

**技术实现层面**：
- **数据驱动决策**：通过清晰的信息呈现支持玩家的战略思考
- **视觉化反馈**：将抽象的游戏机制转化为具体可感的体验
- **模块化架构**：为长期扩展和社区参与预留空间

### 超越游戏的价值意义

星际战役系统的成功不仅在于游戏娱乐价值，更在于其**教育和启发意义**：

**认知能力的培养**：
- 系统思维：理解复杂系统中各部分的相互关系
- 长期规划：平衡短期利益与长期发展的能力
- 风险管理：在不确定性中做出最优决策

**现代管理智慧的体现**：
- 供应链管理的直观化教学
- 资源配置优化的实践训练
- 多维度数据分析的思维培养

### 对未来设计的指导价值

该系统为未来的策略游戏设计指明了方向：

**深度体验的现代化表达**：
- 保持策略游戏的核心价值——深度思考和长期规划
- 适应现代玩家的注意力特点和学习习惯
- 融合当代技术手段增强表现力和沉浸感

**单机游戏的社交化创新**：
- 在个人体验框架下创造社区价值
- 通过分享和交流延伸游戏的生命周期
- 平衡个人沉浸与社交互动的需求

**教育娱乐的完美结合**：
- 在娱乐中实现能力培养和知识传授
- 让复杂概念通过游戏机制变得可理解
- 创造有持久价值的游戏体验

---

**最终评价**：Mindustry的星际战役系统证明了优秀的策略游戏设计不是技术炫技，而是对人性的深刻洞察和对体验的精心雕琢。它为整个游戏行业展示了如何在复杂性与可及性之间找到最佳平衡点，为策略游戏的未来发展提供了宝贵的参考范本。