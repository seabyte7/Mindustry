# Mindustry 武器与战斗系统策划案

## 概述

本文档基于对Mindustry源码的深入分析，详细阐述了游戏的武器系统、战斗机制、伤害计算、瞄准AI和平衡策略。该系统通过多样化的武器类型、精密的伤害计算和智能的瞄准机制，为玩家提供了丰富的战术选择空间。

## 1. 武器系统架构

### 1.1 核心武器属性

#### 基础参数设计
```java
// 射击参数
reload: float              // 重载时间(帧)
inaccuracy: float         // 散射角度(度)
rotate: boolean           // 独立旋转能力
controllable: boolean     // 玩家可控制
aiControllable: boolean   // AI可控制
predictTarget: boolean    // 预判移动目标

// 瞄准参数
shootCone: float = 5f     // 开火锥角(度)
rotationLimit: float = 361f // 旋转限制(度)
minRange: float           // 最小射程
range: float              // 最大射程
```

#### 炮塔专用参数
```java
// 目标获取
targetInterval: float = 20f    // 目标刷新间隔(帧)
targetAir: boolean = true      // 可攻击空中单位
targetGround: boolean = true   // 可攻击地面单位
targetBlocks: boolean = true   // 可攻击建筑

// 精度控制
shootCone: float = 8f          // 射击锥角
velocityRnd: float = 0.1f      // 速度随机性
```

### 1.2 武器分类体系

#### 1.2.1 直射武器 (Direct Fire)
**BasicBulletType - 标准弹药**
```java
// 基础属性
lifetime: 40f              // 存活时间(帧)
speed: 1f                  // 飞行速度
damage: 1f                 // 基础伤害
hitSize: 4f               // 碰撞体积
drag: 0f                   // 空气阻力
```

**特性分析:**
- 轨迹直线可预测
- 受距离影响有弹道下坠
- 适合近中距离精确打击

#### 1.2.2 激光武器 (Laser Weapons)
**LaserBulletType - 激光束**
```java
length: 160f               // 激光射程
width: 15f                 // 激光宽度
pierce: true               // 穿透能力
speed: 0f                  // 瞬时命中
```

**ContinuousLaserBulletType - 持续激光**
```java
// 持续伤害输出
// 能量消耗持续进行
// 需要持续瞄准目标
```

**特性分析:**
- 瞬时命中，无弹道时间
- 穿透多个目标
- 适合对付集群敌人

#### 1.2.3 导弹武器 (Missile Systems)
**MissileBulletType - 制导导弹**
```java
homingPower: 0.08f         // 制导能力
homingRange: 50f           // 制导范围
homingDelay: 0f            // 制导延迟
trailChance: 0.2f          // 尾迹效果概率
```

**特性分析:**
- 主动制导追踪目标
- 适合攻击移动目标
- 可绕过障碍物

#### 1.2.4 火炮武器 (Artillery)
**ArtilleryBulletType - 火炮弹药**
```java
// 高弧度弹道
// 大范围溅射伤害
// 攻击远距离目标
```

**特性分析:**
- 高弧度弹道越过障碍
- 大范围溅射效果
- 攻城克敌利器

#### 1.2.5 防空武器 (Anti-Air)
**FlakBulletType - 防空炮弹**
```java
// 近距离自动引爆
// 专门对付空中目标
// 时间/距离引爆机制
```

#### 1.2.6 特殊武器 (Special Weapons)
**LightningBulletType - 闪电武器**
```java
lightning: int             // 闪电分支数
lightningLength: float     // 闪电长度
lightningDamage: float     // 闪电伤害
```

## 2. 弹药系统设计

### 2.1 弹药属性框架

#### 基础物理属性
```java
// 飞行特性
lifetime: float            // 存活时间(帧)
speed: float              // 初始速度
drag: float               // 阻力系数
pierce: boolean           // 穿透能力
pierceCap: int            // 最大穿透数

// 伤害属性
damage: float             // 直接伤害
splashDamage: float       // 溅射伤害
splashDamageRadius: float // 溅射半径
```

#### 高级效果属性
```java
// 分裂效果
fragBullet: BulletType    // 分裂弹药类型
fragBullets: int = 9      // 分裂数量
fragRandomSpread: float = 360f // 分裂角度

// 状态效果
status: StatusEffect      // 附加状态
statusDuration: float = 8f * 60f // 状态持续时间

// 特殊效果
lightning: int            // 闪电数量
homingPower: float        // 制导能力
```

### 2.2 弹药效果机制

#### 穿透机制
```java
// 每次穿透伤害递减
damage *= pierceDamageFactor; // 默认0.8
hits++;
if(hits >= pierceCap) despawn();
```

#### 分裂机制
```java
// 命中后生成分裂弹药
for(int i = 0; i < fragBullets; i++){
    float angle = rotation + Mathf.range(fragRandomSpread);
    fragBullet.create(x, y, angle);
}
```

#### 制导机制
```java
// 每帧更新制导方向
if(homingPower > 0 && target != null){
    float targetAngle = angleTo(target);
    rotation = Mathf.slerpDelta(rotation, targetAngle, homingPower);
}
```

## 3. 伤害计算系统

### 3.1 基础伤害公式

#### 护甲减伤计算
```java
// 基础护甲减伤公式
finalDamage = Math.max(damage - armor, minArmorDamage * damage);

// 护甲穿透
if(pierceArmor) {
    finalDamage = damage; // 无视护甲
}

// 状态效果修正护甲
if(armorOverride >= 0) {
    armor = armorOverride; // 状态效果覆盖护甲值
}
```

#### 溅射伤害衰减
```java
// 距离衰减公式(最小保留40%)
float falloff = 0.4f;
float distanceRatio = distance / splashRadius;
float scaledDamage = damage * Mathf.lerp(1f - distanceRatio, 1f, falloff);
```

### 3.2 伤害类型分类

#### 直接伤害 (Direct Damage)
- 弹药直接命中造成的伤害
- 受护甲完全影响
- 单目标精确打击

#### 溅射伤害 (Splash Damage)
- 爆炸范围内的区域伤害
- 距离越远伤害越低
- 最小保留40%伤害

#### 穿透伤害 (Pierce Damage)
- 穿透多个目标的伤害
- 每次穿透递减`pierceDamageFactor`
- 可设置最大穿透数

#### 闪电伤害 (Lightning Damage)
- 在目标间跳跃的链式伤害
- 每次跳跃伤害递减
- 自动寻找最近目标

#### 状态伤害 (Status Damage)
- 持续时间内的周期性伤害
- 每帧造成固定伤害
- 可叠加多种状态效果

### 3.3 护甲系统设计

#### 护甲值设计原则
```java
// 单位护甲示例
轻装单位: armor = 2-5     // 基础防护
重装单位: armor = 10-20   // 中等防护
超重单位: armor = 30+     // 高级防护

// 建筑护甲示例
基础建筑: armor = 3       // 轻微保护
防御建筑: armor = 8-15    // 中等保护
核心建筑: armor = 20+     // 重度保护
```

#### 最小伤害保证
```java
// 确保最小伤害输出(默认10%)
float minArmorDamage = 0.1f;
finalDamage = Math.max(damage - armor, minArmorDamage * damage);
```

## 4. 瞄准与AI系统

### 4.1 目标获取系统

#### 目标优先级排序
```java
// 默认排序策略
Sortf unitSort = UnitSorts.closest;    // 最近优先
Sortf unitSort = UnitSorts.strongest;  // 最强优先
Sortf unitSort = UnitSorts.weakest;    // 最弱优先
```

#### 目标筛选条件
```java
// 单位筛选器
Boolf<Unit> unitFilter = u -> {
    return u.team != team &&           // 敌方单位
           u.within(x, y, range) &&    // 射程范围内
           (targetAir || !u.isFlying()) && // 空中目标限制
           (targetGround || u.isFlying()); // 地面目标限制
};

// 建筑筛选器
Boolf<Building> buildingFilter = b -> {
    return targetBlocks &&             // 允许攻击建筑
           (targetUnderBlocks || !b.block.underBullets); // 子弹可达
};
```

#### 最优目标选择算法
```java
target = Units.bestTarget(team, x, y, range,
    unitFilter, buildingFilter, unitSort);
```

### 4.2 预判射击系统

#### 弹道预测算法
```java
// 预测拦截点计算
if(predictTarget && bullet.speed >= 0.01f){
    Vec2 targetPos = Predict.intercept(
        shooter.x, shooter.y,           // 发射位置
        target.x, target.y,             // 目标位置
        target.vel.x, target.vel.y,     // 目标速度
        bullet.speed                    // 弹药速度
    );
}
```

#### 精度控制机制
```java
// 总体散射角度
float totalInaccuracy = inaccuracy + bullet.inaccuracy;
float shootAngle = angleTo(target) + Mathf.range(totalInaccuracy);

// 速度随机性
float randomVelocity = (1f - velocityRnd) + Mathf.random(velocityRnd);
bullet.vel.setLength(bullet.speed * randomVelocity);
```

### 4.3 AI行为系统

#### 4.3.1 地面单位AI (GroundAI)
```java
// 行为优先级
1. 攻击敌方目标(最高优先级)
2. 移动到目标点
3. 躲避敌方火力
4. 寻找掩护位置
```

#### 4.3.2 飞行单位AI (FlyingAI)
```java
// 飞行战术
1. 环绕攻击(Circle Strafing)
2. 俯冲攻击(Dive Attack)
3. 编队飞行(Formation Flying)
4. 撤退机制(Retreat Logic)
```

#### 4.3.3 防御AI (DefenderAI)
```java
// 防御策略
1. 守护重要建筑
2. 拦截入侵者
3. 巡逻警戒路线
4. 支援友军单位
```

## 5. 战斗平衡设计

### 5.1 DPS平衡公式

#### 武器DPS计算
```java
// 基础DPS公式
float weaponDPS = (bullet.estimateDPS() / reload) * shoot.shots * 60f;

// 考虑效率的实际DPS
float realDPS = weaponDPS * efficiency * uptime;

// 炮塔DPS估算
float turretDPS = shoot.shots / reload * 60f * ammo.estimateDPS() * efficiency;
```

#### 弹药DPS估算
```java
// 直接伤害DPS
float directDPS = damage / Math.max(lifetime, 1f);

// 溅射伤害期望
float splashDPS = splashDamage * expectedTargetsInRadius;

// 分裂效果期望
float fragDPS = fragBullets * fragBullet.estimateDPS() * fragHitRate;
```

### 5.2 平衡策略矩阵

#### 武器类型平衡表
```
武器类型    | 射程 | 精度 | 伤害 | 射速 | 成本 | 特殊能力
----------|------|------|------|------|------|----------
机枪      | 短   | 高   | 低   | 高   | 低   | 连续火力
狙击枪    | 长   | 极高 | 高   | 低   | 中   | 穿透
火炮      | 长   | 低   | 极高 | 极低 | 高   | 溅射
激光      | 中   | 极高 | 中   | 中   | 中   | 穿透+瞬命中
导弹      | 长   | 中   | 高   | 低   | 高   | 制导+溅射
防空      | 中   | 中   | 中   | 高   | 中   | 对空特化
```

#### 射程与精度反比关系
```java
// 射程越远，精度要求越高的补偿
inaccuracy = baseInaccuracy * (1f + range / 100f * inaccuracyScale);
```

#### 伤害与射速平衡
```java
// 高伤害武器必须有长重载时间
reload = baseDamage * damageToReloadRatio;
```

### 5.3 反制关系设计

#### 岩石剪刀布机制
```
轻装单位 → 克制 → 重装单位 → 克制 → 防空单位 → 克制 → 轻装单位
   ↓                ↓                ↓
空中单位 ← 克制 ← 建筑防御 ← 克制 ← 地面单位
```

#### 护甲穿透分级
```java
// 不同等级武器的护甲穿透能力
Tier1武器: 可穿透护甲≤5
Tier2武器: 可穿透护甲≤15
Tier3武器: 可穿透护甲≤30
特殊武器: pierceArmor = true (无视护甲)
```

## 6. 状态效果系统

### 6.1 状态效果分类

#### 6.1.1 伤害型状态
```java
// 燃烧效果
burning: {
    damage: 0.06f,              // 每帧伤害
    effect: Fx.burning,         // 视觉效果
    permanent: false            // 可消除
}

// 腐蚀效果
corroded: {
    damage: 0.1f,               // 高腐蚀伤害
    armorOverride: 0f          // 无视护甲
}
```

#### 6.1.2 能力修正型状态
```java
// 冰冻效果
freezing: {
    speedMultiplier: 0.6f,      // 移动速度60%
    reloadMultiplier: 0.6f,     // 攻击速度60%
    damageMultiplier: 0.8f      // 受伤害增加20%
}

// 加速效果
overclock: {
    speedMultiplier: 1.5f,      // 移动速度150%
    reloadMultiplier: 1.3f,     // 攻击速度130%
    buildSpeedMultiplier: 1.5f  // 建造速度150%
}
```

#### 6.1.3 控制型状态
```java
// 缴械效果
disarmed: {
    disarm: true,               // 完全禁用武器
    permanent: false            // 临时效果
}

// 电击眩晕
shocked: {
    speedMultiplier: 0.1f,      // 几乎无法移动
    reloadMultiplier: 0.1f      // 几乎无法攻击
}
```

### 6.2 状态效果组合机制

#### 状态叠加规则
```java
// 相同状态刷新持续时间
if(hasStatus(status)) {
    statusTime = Math.max(statusTime, newDuration);
}

// 不同状态可同时存在
// 效果按乘法叠加
finalSpeed = baseSpeed * freezeMultiplier * overclockMultiplier;
```

#### 状态互动关系
```java
// 冰冻与燃烧相互抵消
if(hasStatus(freezing) && newStatus == burning) {
    removeStatus(freezing);
    // 不添加燃烧状态
}
```

## 7. 高级战术系统

### 7.1 编队战术

#### 单位编队控制
```java
// 编队移动算法
formation.updatePositions();
for(Unit unit : formation.units) {
    unit.moveToFormationPosition();
}
```

#### 协同攻击机制
```java
// 集火目标选择
target = formation.selectPriorityTarget();
formation.focusFireOn(target);
```

### 7.2 地形战术

#### 掩体利用
```java
// 掩体计算
boolean hasCover = World.raycast(unit.x, unit.y, enemy.x, enemy.y) != null;
```

#### 高地优势
```java
// 高度差影响射程
float heightAdvantage = (unit.elevation - target.elevation) * 0.1f;
float effectiveRange = baseRange * (1f + heightAdvantage);
```

### 7.3 资源与战斗平衡

#### 弹药经济系统
```java
// 弹药消耗成本
ammoCost = ammoType.cost * shotsPerSecond * 60f; // 每分钟弹药成本
```

#### 维护成本
```java
// 武器维护
maintenanceCost = weaponValue * maintenanceRate; // 武器价值的百分比
```

## 8. 策划设计指导原则

### 8.1 平衡设计原则

#### 没有绝对最优解
- 每种武器都有适用场景
- 成本效益需要权衡
- 反制关系形成循环

#### 策略深度递增
```
初级: 单一武器类型
中级: 武器类型组合
高级: 时机与位置选择
专家: 资源分配优化
```

### 8.2 玩家体验设计

#### 即时反馈机制
- 伤害数字显示
- 命中效果明显
- 状态效果可视化

#### 渐进式学习曲线
```
第1阶段: 基础射击操作
第2阶段: 目标优先级选择
第3阶段: 武器类型搭配
第4阶段: 高级战术运用
```

### 8.3 可扩展性设计

#### 模块化武器系统
- 武器组件可独立配置
- 弹药效果可自由组合
- AI行为可插件化扩展

#### 数据驱动平衡
- 所有数值参数外部配置
- 支持运行时调整
- A/B测试友好

## 结论

Mindustry的武器与战斗系统通过精密的数学模型、多样化的武器类型、智能的AI系统和精心设计的平衡机制，创造了一个既有深度又有广度的战术游戏环境。该系统的核心优势在于：

1. **多样性**: 丰富的武器类型和战术选择
2. **平衡性**: 没有绝对优势的武器组合
3. **深度**: 从基础操作到高级战术的渐进式复杂度
4. **可扩展性**: 模块化设计支持持续内容更新

这种设计方法为战术游戏的武器系统设计提供了优秀的参考模板。