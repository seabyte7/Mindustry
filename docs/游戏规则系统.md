# 游戏规则系统

Mindustry的游戏规则系统是一个高度可配置的架构，支持多种游戏模式、难度设置和自定义规则配置，为塔防RTS游戏提供了灵活的规则引擎。

## 核心架构设计

### 1. 规则系统层次结构

```
┌─────────────────────────────────────┐
│            Rules                    │
│         (核心规则配置)                 │
├─────────────────────────────────────┤
│          Gamemode                   │
│         (游戏模式预设)                 │
├─────────────────────────────────────┤
│         TeamRules                   │
│         (队伍特定规则)                 │
├─────────────────────────────────────┤
│     CampaignRules                   │
│      (战役规则配置)                   │
├─────────────────────────────────────┤
│        Difficulty                   │
│         (难度设置)                    │
└─────────────────────────────────────┘
```

### 2. 关键类说明

| 类名 | 文件位置 | 职责 |
|------|----------|------|
| `Rules` | `mindustry/game/Rules.java` | 核心规则配置，定义游戏行为 |
| `Gamemode` | `mindustry/game/Gamemode.java` | 预设游戏模式（生存、沙盒、PvP等） |
| `Team` | `mindustry/game/Team.java` | 队伍系统和队伍特定规则 |
| `Waves` | `mindustry/game/Waves.java` | 波次生成算法 |
| `SpawnGroup` | `mindustry/game/SpawnGroup.java` | 敌人生成组配置 |
| `Objectives` | `mindustry/game/Objectives.java` | 战役目标系统 |
| `MapObjectives` | `mindustry/game/MapObjectives.java` | 地图内目标和标记 |
| `CampaignRules` | `mindustry/game/CampaignRules.java` | 战役模式规则 |
| `Difficulty` | `mindustry/game/Difficulty.java` | 难度等级设置 |

## 核心规则系统 (Rules)

### 1. 基础规则配置

```java
public class Rules{
    // 游戏模式标识
    public boolean infiniteResources;    // 沙盒模式：无限资源
    public boolean pvp;                  // PvP模式
    public boolean editor;               // 编辑器模式
    public boolean attackMode;           // 攻击模式

    // 波次系统配置
    public boolean waves;                // 是否启用波次
    public boolean waveTimer;            // 是否自动波次计时
    public boolean waveSending;          // 是否允许手动召唤波次
    public float waveSpacing = 2 * Time.toMinutes; // 波次间隔

    // 游戏机制控制
    public boolean canGameOver = true;   // 是否允许游戏结束
    public boolean coreCapture = false; // 核心占领模式
    public boolean ghostBlocks = true;  // 幽灵方块（重建提示）
    public boolean schematicsAllowed = true; // 蓝图系统

    // 性能和平衡参数
    public float unitDamageMultiplier = 1f;     // 单位伤害倍数
    public float unitHealthMultiplier = 1f;     // 单位血量倍数
    public float blockHealthMultiplier = 1f;    // 建筑血量倍数
    public float buildSpeedMultiplier = 1f;     // 建造速度倍数
    public float buildCostMultiplier = 1f;      // 建造成本倍数

    // 环境设置
    public boolean fog = false;          // 战争迷雾
    public boolean lighting = false;     // 环境光照
    public int env = Vars.defaultEnv;    // 环境标志
    public Attributes attributes = new Attributes(); // 环境属性
}
```

### 2. 队伍特定规则

```java
public static class TeamRule{
    // 作弊模式
    public boolean cheat;               // 无限资源和能量
    public boolean infiniteResources;   // 无限资源
    public boolean infiniteAmmo;        // 无限弹药

    // AI配置
    public boolean buildAi;             // 建造AI
    public float buildAiTier = 1f;      // AI建造等级
    public boolean rtsAi;               // RTS AI
    public int rtsMinSquad = 4;         // 最小攻击小队规模
    public int rtsMaxSquad = 1000;      // 最大攻击小队规模
    public float rtsMinWeight = 1.2f;   // 攻击优势权重

    // 性能倍数
    public float unitDamageMultiplier = 1f;
    public float unitHealthMultiplier = 1f;
    public float blockHealthMultiplier = 1f;
    public float buildSpeedMultiplier = 1f;
    public float extraCoreBuildRadius = 0f; // 额外建造保护区
}
```

## 游戏模式系统 (Gamemode)

### 1. 预设游戏模式

```java
public enum Gamemode{
    survival(rules -> {
        rules.waveTimer = true;          // 自动波次
        rules.waves = true;              // 启用波次
    }),

    sandbox(rules -> {
        rules.infiniteResources = true;  // 无限资源
        rules.allowEditRules = true;     // 允许编辑规则
        rules.waves = true;
        rules.waveTimer = false;         // 手动波次
    }),

    attack(rules -> {
        rules.attackMode = true;
        rules.waveTimer = true;
        rules.waveSpacing = 2f * Time.toMinutes;
        rules.waveTeam.rules().infiniteResources = true; // 敌人无限资源
    }),

    pvp(rules -> {
        rules.pvp = true;
        rules.enemyCoreBuildRadius = 600f; // PvP建造保护区
        rules.unitBuildSpeedMultiplier = 2f; // 加速单位建造
        rules.attackMode = true;
    }),

    editor(rules -> {
        rules.infiniteResources = true;
        rules.instantBuild = true;       // 即时建造
        rules.editor = true;
        rules.waves = false;
    });
}
```

### 2. 模式验证和应用

```java
// 验证地图是否支持某模式
public boolean valid(Map map){
    return validator.get(map);
}

// 应用模式规则
public Rules apply(Rules in){
    rules.get(in);
    return in;
}

// 根据规则推断游戏模式
public Gamemode mode(){
    if(pvp) return Gamemode.pvp;
    else if(editor) return Gamemode.editor;
    else if(attackMode) return Gamemode.attack;
    else if(infiniteResources) return Gamemode.sandbox;
    else return Gamemode.survival;
}
```

## 队伍系统 (Team)

### 1. 队伍层次结构

```java
public class Team implements Comparable<Team>, Senseable{
    public final int id;                // 队伍ID (0-255)
    public final Color color = new Color(); // 队伍颜色
    public final Color[] palette = new Color[3]; // 调色板
    public String name;                 // 队伍名称
    public String emoji = "";           // 队伍表情符号

    // 预定义基础队伍
    public final static Team
        derelict = new Team(0, "derelict", Color.valueOf("4d4e58")),    // 废弃队伍
        sharded = new Team(1, "sharded", Pal.accent.cpy()),             // 玩家队伍
        crux = new Team(2, "crux", Color.valueOf("f25555")),            // 敌人队伍
        malis = new Team(3, "malis", Color.valueOf("a27ce5")),          // 敌人队伍2
        green = new Team(4, "green", Color.valueOf("54d67d")),          // 绿队
        blue = new Team(5, "blue", Color.valueOf("6c87fd"));            // 蓝队
}
```

### 2. 队伍功能和状态

```java
// 获取队伍核心
public CoreBuild core(){
    return data().core();
}

// 队伍资源管理
public ItemModule items(){
    return core() == null ? ItemModule.empty : core().items;
}

// AI控制判断
public boolean isAI(){
    return (state.rules.waves || state.rules.attackMode)
           && this != state.rules.defaultTeam
           && !state.rules.pvp;
}

// 是否需要流场寻路
public boolean needsFlowField(){
    return isAI() && !rules().rtsAi;
}

// 获取队伍规则
public TeamRule rules(){
    return state.rules.teams.get(this);
}
```

## 波次系统 (Waves)

### 1. 波次生成架构

```java
public class Waves{
    // 预定义波次配置
    public Seq<SpawnGroup> get(){
        return Seq.with(
            new SpawnGroup(dagger){{
                end = 10;                // 结束波次
                unitScaling = 2f;        // 单位数量缩放
                max = 30;                // 最大单位数
            }},

            new SpawnGroup(crawler){{
                begin = 4;               // 开始波次
                end = 13;
                unitAmount = 2;          // 基础单位数
                unitScaling = 1.5f;
            }}
        );
    }
}
```

### 2. 程序化波次生成

```java
// 根据难度生成波次
public static Seq<SpawnGroup> generate(float difficulty, Rand rand, boolean attack, boolean airOnly, boolean naval){
    // 单位种类矩阵
    UnitType[][] species = {
        {dagger, mace, fortress, scepter, reign},      // 地面作战单位
        {nova, pulsar, quasar, vela, corvus},          // 地面支援单位
        {crawler, atrax, spiroct, arkyid, toxopid},    // 爬行单位
        {risso, minke, bryde, sei, omura},             // 海军单位
        {flare, horizon, zenith, antumbra, eclipse}    // 空军单位
    };

    // 护盾配置
    float shieldStart = 30;
    float shieldsPerWave = 20 + difficulty * 30f;

    // 创建主要进程序列
    Intc createProgression = start -> {
        UnitType[] curSpecies = Structs.random(rand, species);
        int curTier = 0;

        for(int i = start; i < 150; i += next){
            int next = rand.random(8, 16) + curTier * 4;
            float shieldAmount = Math.max((i - shieldStart) * shieldsPerWave, 0);

            // 主要波次
            out.add(new SpawnGroup(curSpecies[curTier]){{
                unitAmount = 6 / (int)scaling[ctier];
                begin = i;
                end = i + next;
                shields = shieldAmount;
                shieldScaling = shieldsPerWave;
            }});
        }
    };

    return out;
}
```

### 3. 生成组配置

```java
public class SpawnGroup{
    public UnitType type = UnitTypes.dagger; // 单位类型
    public int begin, end = never;           // 开始和结束波次
    public int spacing = 1;                  // 波次间隔
    public int max = 40;                     // 最大单位数
    public float unitScaling = never;        // 单位数量缩放
    public float shields = 0f;               // 护盾值
    public float shieldScaling = 0f;         // 护盾增长
    public int unitAmount = 1;               // 基础单位数
    public StatusEffect effect;              // 状态效果
    public ItemStack items;                  // 携带物品

    // 计算指定波次的生成数量
    public int getSpawned(int wave){
        if(wave < begin || wave > end || (wave - begin) % spacing != 0){
            return 0;
        }
        return Math.min(unitAmount + (int)(((wave - begin) / spacing) / unitScaling), max);
    }

    // 创建单位
    public Unit createUnit(Team team, int wave){
        Unit unit = type.create(team);
        if(effect != null) unit.apply(effect, 999999f);
        if(items != null) unit.addItem(items.item, items.amount);
        unit.shield = getShield(wave);
        return unit;
    }
}
```

## 目标系统 (Objectives)

### 1. 战役目标类型

```java
// 研究目标
public static class Research implements Objective{
    public UnlockableContent content;

    @Override
    public boolean complete(){
        return content.unlockedHost();
    }

    @Override
    public String display(){
        return Core.bundle.format("requirement.research", content.localizedName);
    }
}

// 生产目标
public static class Produce implements Objective{
    public UnlockableContent content;

    @Override
    public boolean complete(){
        return content.unlockedHost();
    }
}

// 区域完成目标
public static class SectorComplete implements Objective{
    public SectorPreset preset;

    @Override
    public boolean complete(){
        return preset.sector.isCaptured() && preset.sector.hasBase();
    }
}
```

### 2. 地图内目标系统

```java
public class MapObjectives implements Iterable<MapObjective>{
    // 注册的目标类型
    public static final Seq<Prov<? extends MapObjective>> allObjectiveTypes = new Seq<>();

    static{
        registerObjective(
            ResearchObjective::new,      // 研究目标
            ProduceObjective::new,       // 生产目标
            ItemObjective::new,          // 物品目标
            CoreItemObjective::new,      // 核心物品目标
            BuildCountObjective::new,    // 建造数量目标
            UnitCountObjective::new,     // 单位数量目标
            DestroyUnitsObjective::new,  // 摧毁单位目标
            TimerObjective::new,         // 计时目标
            DestroyBlockObjective::new,  // 摧毁建筑目标
            DestroyCoreObjective::new,   // 摧毁核心目标
            CommandModeObjective::new,   // 指挥模式目标
            FlagObjective::new           // 标志目标
        );
    }

    // 执行所有运行中的目标
    public void eachRunning(Cons<MapObjective> cons){
        for(MapObjective obj : all){
            if(obj.active()) cons.get(obj);
        }
    }
}
```

## 难度系统 (Difficulty)

### 1. 难度等级定义

```java
public enum Difficulty{
    casual(0.75f, 0.5f, 2f),        // 休闲：敌人血量75%，生成50%，波次间隔200%
    easy(1f, 0.75f, 1.5f),          // 简单：敌人血量100%，生成75%，波次间隔150%
    normal(1f, 1f, 1f),             // 普通：基准难度
    hard(1.25f, 1.5f, 0.8f),        // 困难：敌人血量125%，生成150%，波次间隔80%
    eradication(1.5f, 2f, 0.6f);    // 根除：敌人血量150%，生成200%，波次间隔60%

    public float enemyHealthMultiplier;   // 敌人血量倍数
    public float enemySpawnMultiplier;    // 敌人生成倍数
    public float waveTimeMultiplier;      // 波次时间倍数
}
```

### 2. 战役规则应用

```java
public class CampaignRules{
    public Difficulty difficulty = Difficulty.normal;
    public boolean fog;              // 战争迷雾
    public boolean showSpawns;       // 显示生成点
    public boolean sectorInvasion;   // 区域入侵
    public boolean randomWaveAI;     // 随机波次AI

    public void apply(Planet planet, Rules rules){
        rules.fog = fog;
        rules.showSpawns = showSpawns;
        rules.randomWaveAI = randomWaveAI;
        rules.objectiveTimerMultiplier = difficulty.waveTimeMultiplier;

        // 应用难度到敌人队伍
        TeamRule enemyRules = rules.teams.get(rules.waveTeam);
        enemyRules.blockHealthMultiplier = difficulty.enemyHealthMultiplier;
        enemyRules.unitHealthMultiplier = difficulty.enemyHealthMultiplier;
        enemyRules.unitCostMultiplier = 1f / difficulty.enemySpawnMultiplier;
        enemyRules.unitBuildSpeedMultiplier = difficulty.enemySpawnMultiplier;
    }
}
```

## 规则验证和应用流程

### 1. 规则应用管道

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   基础游戏模式    │───▶│   战役规则应用    │───▶│   队伍规则配置    │
│   (Gamemode)    │    │ (CampaignRules) │    │  (TeamRules)   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   环境属性设置    │◀───│   难度应用      │◀───│   最终规则生效    │
│  (Attributes)   │    │  (Difficulty)   │    │    (Rules)     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### 2. 规则验证机制

```java
// 建造限制验证
public boolean isBanned(Block block){
    return blockWhitelist != bannedBlocks.contains(block);
}

// 单位限制验证
public boolean isBanned(UnitType unit){
    return unitWhitelist != bannedUnits.contains(unit);
}

// 环境兼容性检查
public boolean hasEnv(int env){
    return (this.env & env) != 0;
}

// 队伍特定参数计算
public float unitHealth(Team team){
    return Math.max(unitHealthMultiplier * teams.get(team).unitHealthMultiplier, 0.000001f);
}

public float buildSpeed(Team team){
    return buildSpeedMultiplier * teams.get(team).buildSpeedMultiplier;
}
```

### 3. 动态规则调整

```java
// 实时规则修改（仅在允许的情况下）
if(state.rules.allowEditRules){
    state.rules.infiniteResources = true;
    state.rules.buildSpeedMultiplier = 5f;
    state.rules.unitBuildSpeedMultiplier = 10f;
}

// 队伍规则动态调整
TeamRule playerRules = state.rules.teams.get(player.team());
playerRules.cheat = true;
playerRules.infiniteResources = true;

// 环境效果应用
state.rules.attributes.set(Attribute.heat, 0.8f);
state.rules.weather.add(new WeatherEntry(Weathers.sandstorm));
```

## 性能优化策略

### 1. 规则缓存机制

```java
// 缓存计算结果避免重复计算
private final ObjectMap<Team, Float> cachedBuildSpeeds = new ObjectMap<>();

public float buildSpeed(Team team){
    Float cached = cachedBuildSpeeds.get(team);
    if(cached == null){
        cached = buildSpeedMultiplier * teams.get(team).buildSpeedMultiplier;
        cachedBuildSpeeds.put(team, cached);
    }
    return cached;
}

// 规则变更时清除缓存
public void invalidateCache(){
    cachedBuildSpeeds.clear();
}
```

### 2. 波次预计算

```java
// 预计算波次生成信息
private final IntMap<SpawnData> precomputedWaves = new IntMap<>();

public void precomputeWaves(int maxWave){
    for(int wave = 1; wave <= maxWave; wave++){
        SpawnData data = new SpawnData();
        for(SpawnGroup group : spawns){
            data.totalUnits += group.getSpawned(wave);
        }
        precomputedWaves.put(wave, data);
    }
}
```

## 扩展性设计

### 1. 自定义规则支持

```java
// 通过标签系统支持自定义规则
public StringMap tags = new StringMap();

// 设置自定义规则
state.rules.tags.put("customDamageMultiplier", "2.5");
state.rules.tags.put("enableSpecialMode", "true");

// 读取自定义规则
float customDamage = Float.parseFloat(state.rules.tags.get("customDamageMultiplier", "1.0"));
boolean specialMode = Boolean.parseBoolean(state.rules.tags.get("enableSpecialMode", "false"));
```

### 2. MOD集成支持

```java
// MOD可以注册自定义目标类型
MapObjectives.registerObjective(CustomObjective::new);

// MOD可以修改现有规则
Events.on(EventType.GameOverEvent.class, e -> {
    if(state.rules.tags.get("enableRespawn", "false").equals("true")){
        // 自定义复活逻辑
        revivePlayer();
    }
});
```

## 总结

Mindustry的游戏规则系统体现了出色的模块化设计：

**核心优势：**
1. **高度可配置** - 支持从简单开关到复杂倍数的全方位配置
2. **模式化设计** - 预设游戏模式简化了规则配置
3. **队伍特异性** - 每个队伍可以有独立的规则配置
4. **动态调整** - 支持游戏过程中的规则修改
5. **扩展友好** - MOD可以轻松添加自定义规则和目标

**设计模式：**
- **策略模式** - 不同游戏模式的规则策略
- **组合模式** - 规则、队伍规则、战役规则的组合
- **观察者模式** - 目标完成状态监控
- **建造者模式** - 复杂规则配置的构建

这个规则系统为Mindustry提供了从休闲沙盒到硬核PvP的全方位游戏体验，同时保持了优秀的性能和可扩展性。开发者可以基于这个架构轻松创建自定义游戏模式或调整现有规则以适应不同的游戏需求。