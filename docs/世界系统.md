# Mindustry 世界系统

## 概述

Mindustry的世界系统是游戏的物理基础，由Block（方块定义）、Building（建筑实例）和Tile（地图单元）三层架构组成。这个系统实现了复杂的工业自动化逻辑，包括资源生产、运输、消耗和管理。

## 三层架构设计

### 架构关系图

```
Tile (地图单元)
 ├── Floor (地板类型)
 ├── Overlay (覆盖层)
 └── Block (方块类型) ──creates──> Building (建筑实例)
      ├── PowerModule (电力模块)
      ├── ItemModule (物品模块)
      └── LiquidModule (液体模块)
```

### 1. Tile - 地图基础单元

Tile是世界网格的基本单位，每个地图坐标对应一个Tile：

```java
public class Tile implements Position, QuadTreeObject, Displayable {
    public short x, y;                    // 地图坐标
    protected Block block;                // 放置的方块
    protected Floor floor;                // 地板类型
    protected Floor overlay;              // 覆盖层（矿物等）
    public @Nullable Building build;      // 建筑实例
    public byte data;                     // 额外数据

    public Tile(int x, int y) {
        this.x = (short)x;
        this.y = (short)y;
        block = floor = overlay = (Floor)Blocks.air;
    }

    // 设置方块并创建建筑
    public void setBlock(Block type, Team team, int rotation) {
        preChanged();
        this.block = type;
        changeBuild(team, type::newBuilding, rotation);
        changed();
    }

    // 地形查询
    public boolean passable() {
        return !block.solid || block.underBullets;
    }

    public boolean solid() {
        return block.solid;
    }

    public boolean breakable() {
        return block.destructible && block.breakable;
    }
}
```

**Tile的核心功能：**
- **坐标管理**：提供世界坐标系中的精确位置
- **地形信息**：floor（基础地形）+ overlay（资源层）+ block（建筑层）
- **建筑生命周期**：管理Building的创建、更新和销毁
- **物理属性**：可通行性、可破坏性、遮挡等

### 2. Block - 方块类型定义

Block定义了建筑的所有静态属性和行为模式：

```java
public class Block extends UnlockableContent {
    // 基础属性
    public int size = 1;                      // 占用格子数（1x1, 2x2, 3x3）
    public int health = -1;                   // 默认血量
    public float armor = 0f;                  // 护甲值
    public boolean solid = false;             // 是否阻挡移动
    public boolean destructible = true;       // 是否可破坏

    // 功能属性
    public boolean hasItems = false;          // 是否处理物品
    public boolean hasLiquids = false;        // 是否处理液体
    public boolean hasPower = false;          // 是否需要电力
    public boolean outputsPower = false;      // 是否产生电力
    public boolean acceptsItems = false;      // 是否接受物品输入

    // 容量属性
    public int itemCapacity = 10;             // 物品容量
    public float liquidCapacity = 10f;        // 液体容量
    public float liquidPressure = 1f;         // 液体压力

    // 消耗系统
    public Consumes consumes = new Consumes();

    // 渲染系统
    public DrawBlock drawer = new DrawDefault();

    // 生命周期方法
    public void init() {
        // 方块初始化
        if(hasItems) itemCapacity = Math.max(itemCapacity, 1);
        if(hasLiquids) liquidCapacity = Math.max(liquidCapacity, 1f);
    }

    public void load() {
        // 加载纹理资源
        region = Core.atlas.find(name);
        drawer.load(this);
    }

    // 建筑创建
    public Building newBuilding() {
        return new Building();
    }

    // 游戏逻辑
    public void updateTile(Building build) {
        // 建筑更新逻辑
        if(hasItems) build.items.update();
        if(hasLiquids) build.liquids.update();
        if(hasPower) build.power.update();
    }

    public boolean canPlaceOn(Tile tile, Team team) {
        // 放置条件检查
        return tile.block() == Blocks.air || tile.block().replaceable;
    }
}
```

### 3. Building - 建筑实例

Building是Block的运行时实例，包含具体的状态和行为：

```java
@EntityDef(value = {Buildingc.class}, isFinal = false)
@Component(base = true)
public abstract class BuildingComp implements Posc, Teamc, Healthc, Buildingc {
    // 基础属性
    transient Tile tile;                      // 所在地块
    transient Block block;                    // 方块类型
    transient int rotation;                   // 朝向
    transient boolean enabled = true;         // 是否启用

    // 模块系统
    @Nullable PowerModule power;              // 电力模块
    @Nullable ItemModule items;               // 物品模块
    @Nullable LiquidModule liquids;           // 液体模块

    // 效率系统
    transient float efficiency;               // 当前效率
    transient float optionalEfficiency;       // 可选效率
    transient float potentialEfficiency;      // 潜在效率
    transient boolean shouldConsumePower;     // 是否需要消耗电力

    // 邻接系统
    transient Seq<Building> proximity = new Seq<>(6); // 相邻建筑

    public void updateTile() {
        // 更新建筑逻辑
        if(block.update && enabled) {
            block.updateTile(self());

            // 更新效率
            updateEfficiency();

            // 模块更新
            if(block.hasItems && items != null) items.updateFlow();
            if(block.hasLiquids && liquids != null) liquids.update();
            if(block.hasPower && power != null) power.graph.update();
        }
    }

    void updateEfficiency() {
        float minEfficiency = 1f;
        boolean update = shouldConsumePower = false;

        // 计算所有消费者的效率
        for(Consume cons : block.consumes.all()) {
            if(cons.optional) continue;

            float eff = cons.efficiency(self());
            if(eff < minEfficiency) minEfficiency = eff;
            if(eff > 0f && cons != block.consumes.getPower()) update = true;
        }

        efficiency = minEfficiency;
        shouldConsumePower = update;
    }
}
```

## 模块系统

### 模块架构

Building使用模块系统管理不同类型的资源：

```java
public abstract class BlockModule {
    public abstract void write(Writes write);
    public abstract void read(Reads read);
}
```

#### 1. ItemModule - 物品管理

```java
public class ItemModule extends BlockModule {
    protected int[] items = new int[content.items().size]; // 物品数组
    protected int total;                                   // 总数量
    protected int takeRotation;                           // 取出轮转

    // 物品操作
    public void add(Item item, int amount) {
        items[item.id] = Math.min(items[item.id] + amount, itemCapacity);
        total += amount;
    }

    public int remove(Item item, int amount) {
        amount = Math.min(amount, items[item.id]);
        items[item.id] -= amount;
        total -= amount;
        return amount;
    }

    public boolean has(Item item, int amount) {
        return items[item.id] >= amount;
    }

    public boolean hasAny() {
        return total > 0;
    }

    // 流量计算
    public void updateFlow() {
        // 计算物品流量用于显示
        if(flowTimer.get(1, pollScl)) {
            // 更新流量统计
        }
    }

    // 均匀取出（用于多输出端口）
    public Item takeStack(int amount, Item item) {
        if(items[item.id] >= amount) {
            remove(item, amount);
            return item;
        }
        return null;
    }
}
```

#### 2. PowerModule - 电力管理

```java
public class PowerModule extends BlockModule {
    public float status = 0.0f;              // 电力状态（0-1）
    public boolean init;                     // 是否已初始化
    public PowerGraph graph = new PowerGraph(); // 电力网络
    public IntSeq links = new IntSeq();      // 连接的建筑

    // 电力网络管理
    public class PowerGraph {
        public float powerProduced, powerNeeded;
        public float powerBalance;               // 电力平衡
        public Seq<Building> producers = new Seq<>();
        public Seq<Building> consumers = new Seq<>();
        public Seq<Building> batteries = new Seq<>();

        public void update() {
            // 计算总产能和需求
            powerProduced = 0f;
            powerNeeded = 0f;

            for(Building producer : producers) {
                powerProduced += producer.block.powerProduction * producer.efficiency();
            }

            for(Building consumer : consumers) {
                if(consumer.shouldConsumePower) {
                    powerNeeded += consumer.block.consumes.getPower().usage * consumer.efficiency();
                }
            }

            // 分配电力
            powerBalance = powerProduced - powerNeeded;
            float satisfaction = powerNeeded == 0f ? 1f : Math.min(powerProduced / powerNeeded, 1f);

            // 更新所有建筑的电力状态
            for(Building consumer : consumers) {
                consumer.power.status = satisfaction;
            }
        }
    }
}
```

#### 3. LiquidModule - 液体管理

```java
public class LiquidModule extends BlockModule {
    private float[] liquids = new float[content.liquids().size];
    private float total;
    private @Nullable Liquid current;

    public void handleLiquid(Building build, Liquid liquid, float amount) {
        if(build.block.hasLiquids) {
            // 检查是否可以接受该液体
            if(current != null && current != liquid) {
                // 混合不同液体的逻辑
                if(current.temperature > liquid.temperature) {
                    // 温度交换
                    float heat = Math.min(amount, liquids[current.id]) *
                                (current.temperature - liquid.temperature) * 0.01f;
                    amount = Math.max(amount - heat, 0f);
                }
            }

            add(liquid, amount);
        }
    }

    public void add(Liquid liquid, float amount) {
        if(amount <= 0f) return;

        if(current == null) current = liquid;

        if(current == liquid) {
            liquids[liquid.id] = Math.min(liquids[liquid.id] + amount,
                                         build.block.liquidCapacity);
            total += amount;
        }
    }

    public void update() {
        // 液体流动逻辑
        if(current != null && total > 0.01f) {
            // 向相邻建筑输送液体
            for(Building other : build.proximity) {
                if(other.block.hasLiquids && other.liquids.current == current) {
                    float flow = Math.min(total * 0.1f, build.block.liquidCapacity * 0.1f);
                    other.liquids.add(current, flow);
                    remove(current, flow);
                }
            }
        }
    }
}
```

## 消耗系统

### Consume基类

所有资源消耗都通过Consume系统管理：

```java
public abstract class Consume {
    public boolean optional;                 // 是否可选
    public boolean booster;                  // 是否为加速器
    public boolean update = true;            // 是否需要更新
    public Floatf<Building> multiplier = b -> 1f; // 消耗倍数

    // 效率计算
    public abstract float efficiency(Building build);

    // 触发消耗
    public abstract void trigger(Building build);

    // 更新逻辑
    public void update(Building build) {}
}
```

#### 具体消耗类型

**电力消耗：**
```java
public class ConsumePower extends Consume {
    public float usage;                      // 电力需求
    public float capacity;                   // 缓冲容量
    public boolean buffered;                 // 是否有缓冲

    @Override
    public float efficiency(Building build) {
        if(buffered) {
            return build.power.status; // 缓冲模式下返回储电比例
        } else {
            return build.power.status >= 0.9999f ? 1f : 0f; // 实时模式
        }
    }
}
```

**物品消耗：**
```java
public class ConsumeItems extends Consume {
    public ItemStack[] items;                // 需要的物品

    @Override
    public float efficiency(Building build) {
        if(build.items == null) return 0f;

        for(ItemStack stack : items) {
            if(!build.items.has(stack.item, stack.amount)) {
                return 0f;
            }
        }
        return 1f;
    }

    @Override
    public void trigger(Building build) {
        for(ItemStack stack : items) {
            build.items.remove(stack.item, stack.amount);
        }
    }
}
```

**液体消耗：**
```java
public class ConsumeLiquid extends Consume {
    public Liquid liquid;                    // 需要的液体
    public float amount;                     // 消耗量

    @Override
    public float efficiency(Building build) {
        if(build.liquids == null) return 0f;
        return Math.min(build.liquids.get(liquid) / amount, 1f);
    }

    @Override
    public void update(Building build) {
        build.liquids.remove(liquid, amount * Time.delta * multiplier.get(build));
    }
}
```

## 方块分类系统

### 1. 生产方块

#### 钻头类型
```java
public class Drill extends Block {
    public int tier = 1;                     // 开采等级
    public float drillTime = 300f;           // 开采时间
    public float hardnessDrillMultiplier = 50f; // 硬度影响
    public Attribute drillAttribute = Attribute.ore; // 开采属性

    @Override
    public void updateTile(Building build) {
        if(build.efficiency() > 0) {
            // 计算开采进度
            float drillMultiplier = 1f;
            if(build.tile.overlay().hardness > tier) {
                drillMultiplier *= hardnessDrillMultiplier;
            }

            build.progress += 1f / (drillTime * drillMultiplier) * build.efficiency();

            if(build.progress >= 1f) {
                // 产出物品
                Item toDrop = build.tile.overlay().itemDrop;
                if(toDrop != null && build.items.get(toDrop) < itemCapacity) {
                    build.items.add(toDrop, 1);
                    build.progress = 0f;
                }
            }
        }
    }
}
```

#### 制造器类型
```java
public class GenericCrafter extends Block {
    public float craftTime = 80f;           // 制作时间
    public ItemStack outputItem;            // 产出物品
    public LiquidStack outputLiquid;        // 产出液体
    public float craftEffect = 0.02f;       // 制作特效频率

    @Override
    public void updateTile(Building build) {
        if(shouldConsume(build) && build.efficiency() > 0) {
            build.progress += getProgressIncrease(build, craftTime);

            if(build.progress >= 1f) {
                consume(build);

                // 产出物品
                if(outputItem != null) {
                    for(int i = 0; i < outputItem.amount; i++) {
                        offload(build, outputItem.item);
                    }
                }

                // 产出液体
                if(outputLiquid != null) {
                    handleLiquid(build, outputLiquid.liquid, outputLiquid.amount);
                }

                build.progress = 0f;
            }
        }
    }

    public void consume(Building build) {
        for(Consume cons : consumes.all()) {
            cons.trigger(build);
        }
    }
}
```

### 2. 分配方块

#### 传送带系统
```java
public class Conveyor extends Block {
    public float speed = 0f;                 // 传输速度
    public float displayedSpeed = 0f;        // 显示速度

    public class ConveyorBuild extends Building {
        public int clogHeat = 0;             // 堵塞热度
        public int lastItem = -1;            // 上一个物品
        public Interval itemTimer = new Interval(1);

        @Override
        public void updateTile() {
            if(efficiency() > 0) {
                float moveSpeed = speed * efficiency();

                // 物品移动逻辑
                if(items.total > 0) {
                    if(itemTimer.get(0, 4f / moveSpeed)) {
                        Item item = items.first();
                        Building next = front();

                        if(next != null && next.acceptItem(self(), item)) {
                            next.handleItem(self(), item);
                            items.remove(item, 1);
                        } else {
                            clogHeat = Math.min(clogHeat + 1, 10);
                        }
                    }
                }

                // 堵塞处理
                if(clogHeat > 0) {
                    clogHeat = Math.max(clogHeat - 1, 0);
                }
            }
        }

        @Override
        public boolean acceptItem(Building source, Item item) {
            return items.total < getMaximumAccepted(item) &&
                   (source == this || source.block instanceof Conveyor);
        }
    }
}
```

#### 路由器系统
```java
public class Router extends Block {
    public class RouterBuild extends Building {
        int lastInput = -1;                  // 上次输入方向

        @Override
        public void updateTile() {
            if(items.total > 0) {
                distributeItem();
            }
        }

        void distributeItem() {
            int dump = rotation();

            // 轮询分配到相邻建筑
            for(int i = 0; i < 4; i++) {
                Building other = nearby((dump + i) % 4);
                Item item = items.first();

                if(other != null && other.acceptItem(self(), item)) {
                    other.handleItem(self(), item);
                    items.remove(item, 1);
                    rotation((dump + i + 1) % 4);
                    break;
                }
            }
        }
    }
}
```

### 3. 防御方块

#### 炮塔系统
```java
public class Turret extends Block {
    public float range = 50f;                // 射程
    public float reloadTime = 30f;          // 重装时间
    public float inaccuracy = 0f;           // 散射角度

    public class TurretBuild extends Building {
        public float reload;                 // 重装倒计时
        public float rotation = 90f;         // 炮塔角度
        public Unit target;                  // 当前目标

        @Override
        public void updateTile() {
            // 目标搜索
            if(timer(timerTarget, targetInterval)) {
                target = Units.closestEnemy(team, x, y, range, u -> u.checkTarget(collidesAir, collidesGround));
            }

            // 射击逻辑
            if(target != null && target.within(this, range)) {
                float targetRot = angleTo(target);

                if(Angles.within(rotation, targetRot, shootCone)) {
                    if(reload <= 0f) {
                        shoot(target);
                        reload = reloadTime;
                    }
                }

                // 炮塔旋转
                rotation = Angles.moveToward(rotation, targetRot, rotateSpeed * efficiency());
            }

            // 重装计时
            if(reload > 0f) {
                reload -= Time.delta * efficiency();
            }
        }

        void shoot(Unit target) {
            // 发射子弹
            BulletType bullet = getCurrentBullet();
            bullet.create(this, team, x, y, rotation + Mathf.range(inaccuracy));

            // 消耗弹药
            consumeAmmo();
        }
    }
}
```

## 邻接系统

### 建筑连接

建筑通过proximity系统管理邻接关系：

```java
public void onProximityAdded() {
    // 建筑被放置时调用
    updateNearbyBelts();
    updatePowerGraph();
    updateLiquidConnections();
}

public void onProximityRemoved() {
    // 建筑被移除时调用
    power.graph.remove(this);

    for(Building other : proximity) {
        other.onProximityUpdate();
    }
}

public void onProximityUpdate() {
    // 邻接关系更新
    updateConnections();
    if(block.sync) {
        // 同步给客户端
    }
}
```

### 连接规则

```java
public boolean connectsTo(Building to, boolean checkLink) {
    if(to == null || to.tile == null) return false;

    // 距离检查
    if(!within(to, range + to.block.size * tilesize / 2f)) return false;

    // 类型兼容性
    if(block.connectedPower && to.block.connectedPower) return true;
    if(block.outputsLiquid && to.block.hasLiquids) return true;
    if(block.acceptsItems && to.block.outputsItems) return true;

    return false;
}
```

## 渲染系统

### DrawBlock架构

方块渲染通过DrawBlock系统实现：

```java
public abstract class DrawBlock {
    // 基础渲染
    public void draw(Building build) {
        Draw.rect(build.block.region, build.x, build.y, build.rotation * 90);
    }

    // 光效渲染
    public void drawLight(Building build) {
        if(build.block.hasLights) {
            Drawf.light(build.team, build.x, build.y, lightRadius, lightColor, efficiency);
        }
    }

    // 规划渲染
    public void drawPlan(Block block, BuildPlan plan, Eachable<BuildPlan> list) {
        Draw.alpha(0.6f);
        Draw.rect(block.region, plan.drawx(), plan.drawy(), plan.rotation * 90);
        Draw.alpha(1f);
    }

    // 资源加载
    public void load(Block block) {
        block.region = Core.atlas.find(block.name);
    }

    // 图标生成
    public TextureRegion[] icons(Block block) {
        return new TextureRegion[]{block.region};
    }
}
```

### 复合渲染器

```java
public class DrawMulti extends DrawBlock {
    public DrawBlock[] drawers;

    @Override
    public void draw(Building build) {
        for(DrawBlock drawer : drawers) {
            drawer.draw(build);
        }
    }
}

public class DrawRotator extends DrawBlock {
    public float rotateSpeed = 1f;
    public TextureRegion rotator;

    @Override
    public void draw(Building build) {
        super.draw(build);

        float rotation = build.totalProgress() * rotateSpeed;
        Draw.rect(rotator, build.x, build.y, rotation);
    }
}
```

## 世界更新循环

### 更新流程

```java
public class World {
    public void update() {
        // 1. 实体更新
        Groups.build.update();

        // 2. 电力网络更新
        powerGraphs.each(PowerGraph::update);

        // 3. 液体流动更新
        liquidBlocks.each(Building::updateLiquids);

        // 4. 物品传输更新
        conveyorBlocks.each(Building::updateConveyor);

        // 5. AI和逻辑更新
        processorBlocks.each(Building::updateLogic);
    }
}
```

### 性能优化

```java
// 建筑休眠系统
public class BuildingSleep {
    static float sleepTime = 60f;           // 休眠阈值
    static int sleepingBuildings = 0;       // 休眠建筑数量

    public boolean canSleep(Building build) {
        return !build.block.alwaysUpdate &&
               build.timeScale <= 0.0001f &&
               build.efficiency() <= 0.001f;
    }

    public void sleep(Building build) {
        build.sleeping = true;
        sleepingBuildings++;
    }

    public void wake(Building build) {
        build.sleeping = false;
        sleepingBuildings--;
    }
}
```

这个世界系统为Mindustry提供了强大而灵活的工业自动化基础，支持复杂的资源管理、生产流水线和防御系统，是游戏核心玩法的技术支撑。