# Mindustry 音频系统文档

## 概述

Mindustry 的音频系统基于 Arc 框架，提供完整的声音效果和音乐管理功能。系统支持 3D 空间音效、动态音乐切换、环境音效循环以及性能优化的音频总线管理。

## 核心架构

### 音频控制器 (SoundControl.java)

`SoundControl` 是音频系统的核心控制器，负责管理所有音频播放逻辑。

```java
public class SoundControl {
    // 音乐播放参数
    public float finTime = 120f;        // 淡入时间
    public float foutTime = 120f;       // 淡出时间
    public float musicInterval = 3f * Time.toMinutes;  // 音乐播放间隔
    public float musicChance = 0.8f;    // 音乐播放概率

    // 音乐分类
    public Seq<Music> ambientMusic;     // 环境音乐
    public Seq<Music> darkMusic;        // 战斗音乐
    public Seq<Music> bossMusic;        // Boss 战音乐
}
```

### 音频总线系统

#### 总线分类
```java
// 音频总线配置
AudioBus uiBus = new AudioBus();           // UI 音效总线
Core.audio.soundBus;                       // 游戏音效总线
Core.audio.musicBus;                       // 音乐总线
```

#### 音频过滤器
```java
// 低通滤波器 - 用于暂停时的音效处理
protected AudioFilter filter = new BiquadFilter() {{
    set(0, 500, 1);  // 频率: 500Hz, 品质因数: 1
}};

// 动态过滤器控制
Core.audio.soundBus.fadeFilterParam(0, Filters.paramWet,
    paused ? 1f : 0f, 0.4f);  // 暂停时启用滤波器
```

## 音乐系统

### 音乐分类和自动切换

#### 音乐类型定义
```java
// 音乐初始化 (SoundControl.java:73-75)
ambientMusic = Seq.with(Musics.game1, Musics.game3, Musics.game6,
                       Musics.game8, Musics.game9, Musics.fine);
darkMusic = Seq.with(Musics.game2, Musics.game5, Musics.game7, Musics.game4);
bossMusic = Seq.with(Musics.boss1, Musics.boss2, Musics.game2, Musics.game5);
```

#### 音乐自动切换逻辑
```java
// 随机播放选择 (SoundControl.java:218-226)
public void playRandom() {
    if(state.boss() != null) {
        playOnce(bossMusic.random(lastRandomPlayed));    // Boss 存在时播放 Boss 音乐
    } else if(isDark()) {
        playOnce(darkMusic.random(lastRandomPlayed));    // 紧张情况播放战斗音乐
    } else {
        playOnce(ambientMusic.random(lastRandomPlayed)); // 正常情况播放环境音乐
    }
}
```

#### 紧张度判定算法
```java
// 音乐氛围判定 (SoundControl.java:229-242)
protected boolean isDark() {
    // 核心损坏 -> 紧张音乐
    if(player.team().data().hasCore() &&
       player.team().data().core().healthf() < 0.85f) {
        return true;
    }

    // 基于波次的概率判定
    if(Mathf.chance((float)(Math.log10((state.wave - 17f)/19f) + 1) / 4f)) {
        return true;
    }

    // 基于敌人数量的概率判定
    return Mathf.chance(state.enemies / 70f + 0.1f);
}
```

### 音乐淡入淡出系统

#### 平滑切换机制
```java
// 音乐播放控制 (SoundControl.java:246-295)
protected void play(@Nullable Music music) {
    if(current == null && music != null) {
        // 开始播放新音轨
        current = music;
        current.setLooping(true);
        current.setVolume(fade = 0f);
        current.play();
    } else if(current == music && music != null) {
        // 淡入正在播放的音轨
        fade = Mathf.clamp(fade + Time.delta / finTime);
    } else if(current != null) {
        // 淡出当前音轨
        fade = Mathf.clamp(fade - Time.delta / foutTime);

        if(fade <= 0.01f) {
            current.stop();  // 音量降至 0 时停止
            current = null;
        }
    }

    // 应用音量设置
    if(current != null) {
        current.setVolume(fade * Core.settings.getInt("musicvol") / 100f);
    }
}
```

### 事件驱动的音乐播放

#### 波次触发音乐
```java
// 波次事件监听 (SoundControl.java:48-56)
Events.on(WaveEvent.class, e -> Time.run(Mathf.random(8f, 15f) * 60f, () -> {
    boolean boss = state.rules.spawns.contains(group ->
        group.getSpawned(state.wave - 2) > 0 && group.effect == StatusEffects.boss);

    if(boss) {
        playOnce(bossMusic.random(lastRandomPlayed));  // Boss 波次
    } else if(Mathf.chance(musicWaveChance)) {
        playRandom();  // 普通波次随机播放
    }
}));
```

## 3D 空间音效系统

### 空间音效计算

#### 音量和声道计算
```java
// 空间音效循环播放 (SoundControl.java:94-105)
public void loop(Sound sound, Position pos, float volume) {
    float baseVol = sound.calcFalloff(pos.getX(), pos.getY());  // 距离衰减
    float vol = baseVol * volume;

    SoundData data = sounds.get(sound, SoundData::new);
    data.volume += vol;
    data.volume = Mathf.clamp(data.volume, 0f, 1f);
    data.total += baseVol;
    data.sum.add(pos.getX() * baseVol, pos.getY() * baseVol);  // 加权位置求和
}
```

#### 声道平移计算
```java
// 更新空间音效 (SoundControl.java:192-214)
float pan = Mathf.zero(data.total, 0.0001f) ? 0f :
           sound.calcPan(data.sum.x / data.total, data.sum.y / data.total);

if(data.soundID <= 0 || !Core.audio.isPlaying(data.soundID)) {
    data.soundID = sound.loop(data.curVolume, 1f, pan);  // 创建新的音效实例
} else {
    Core.audio.set(data.soundID, pan, data.curVolume);   // 更新现有音效
}
```

### 音效数据管理

#### SoundData 结构
```java
protected static class SoundData {
    float volume;      // 当前帧音量累计
    float total;       // 权重总和
    Vec2 sum;          // 加权位置和
    int soundID;       // 音效实例 ID
    float curVolume;   // 当前播放音量
}
```

## 循环音效系统 (SoundLoop.java)

### 单一位置循环音效

`SoundLoop` 类为特定位置提供循环音效播放，支持音量淡入淡出。

```java
public class SoundLoop {
    private static final float fadeSpeed = 0.05f;  // 淡入淡出速度

    public void update(float x, float y, boolean play, float volumeScl) {
        if(play) {
            volume = Mathf.clamp(volume + fadeSpeed * Time.delta);  // 淡入
        } else {
            volume = Mathf.clamp(volume - fadeSpeed * Time.delta);  // 淡出
            if(volume <= 0.001f) {
                Core.audio.stop(id);  // 音量足够低时停止
                id = -1;
                return;
            }
        }

        // 实时更新音效属性
        Core.audio.set(id, sound.calcPan(x, y),
                      sound.calcVolume(x, y) * volume * baseVolume * volumeScl);
    }
}
```

## 音频资源生成系统

### 自动资源扫描

音频资源通过注解处理器自动生成 `Sounds` 和 `Musics` 类。

#### 生成过程 (AssetsProcess.java)
```java
void processSounds(String classname, String path, String rtype, boolean genid) {
    // 扫描指定目录下的音频文件
    Fi.get(path).walk(files::add);
    files.sortComparing(Fi::name);

    for(Fi file : files) {
        String name = file.nameWithoutExtension();
        String filepath = /* 构建相对路径 */;

        // 生成静态字段
        type.addField(FieldSpec.builder(ClassName.bestGuess(rtype), name,
                     Modifier.STATIC, Modifier.PUBLIC)
                     .initializer("new " + rtype + "()")
                     .build());

        // 生成加载代码
        loadBegin.addStatement("Core.assets.load($S, $L.class).loaded = a -> { $L = ($L)a; }",
                              filepath, rtype, name, rtype);
    }
}
```

#### 生成的类结构
```java
// 生成的 Sounds 类示例
public class Sounds {
    public static Sound explosion = new Sound();
    public static Sound build = new Sound();
    public static Sound fire = new Sound();
    public static Sound none = new Sound();  // 空音效

    public static void load() {
        Core.assets.load("sounds/explosion.ogg", Sound.class).loaded = a -> { explosion = (Sound)a; };
        // ... 其他音效加载
    }
}
```

#### ID 映射系统
```java
// 为 Sounds 类生成 ID 映射 (仅 Sound 类型)
if(genid) {
    type.addField(IntMap.class, "idToSound", STATIC, PRIVATE);
    type.addField(ObjectIntMap.class, "soundToId", STATIC, PRIVATE);

    // 生成 ID 查询方法
    type.addMethod(MethodSpec.methodBuilder("getSoundId")
        .returns(int.class)
        .addParameter(Sound.class, "sound")
        .addStatement("return soundToId.get(sound, -1)")
        .build());
}
```

## 性能优化策略

### 音频总线优化

#### 总线分组管理
```java
// 总线状态控制 (SoundControl.java:133-147)
if(playing != wasPlaying) {
    wasPlaying = playing;

    if(playing) {
        Core.audio.soundBus.play();      // 启动音效总线
        setupFilters();                  // 设置滤波器
    } else {
        Core.audio.soundBus.stop();      // 停止音效总线
        Core.audio.musicBus.play();      // 保持音乐总线运行
        Core.audio.soundBus.play();      // 重新启动音效总线
    }
}
```

#### 音效实例保护
```java
// 防止音效被意外停止
data.soundID = sound.loop(data.curVolume, 1f, pan);
Core.audio.protect(data.soundID, true);  // 保护音效实例
```

### 内存管理

#### 音效数据复用
```java
// 音效数据对象复用
SoundData data = sounds.get(sound, SoundData::new);  // 获取或创建
data.volume = 0f;      // 每帧重置累计值
data.total = 0f;
data.sum.setZero();
```

#### 自动清理机制
```java
// 非游戏状态时清理循环音效
if(!state.isGame()) {
    sounds.clear();  // 清理所有循环音效数据
    return;
}
```

## 使用示例

### 在建筑中播放循环音效
```java
public class SomeBuilding extends Building {
    @Override
    public void updateTile() {
        super.updateTile();

        // 播放建筑工作音效
        if(efficiency > 0) {
            control.sound.loop(Sounds.machine, tile, 0.3f);
        }
    }
}
```

### 在武器中播放音效
```java
public class SomeWeapon extends Weapon {
    public SomeWeapon() {
        shootSound = Sounds.laser;      // 射击音效
        chargeSound = Sounds.charge;    // 充能音效
        noAmmoSound = Sounds.noammo;    // 无弹药音效
    }
}
```

### MOD 中添加自定义音效
```java
// MOD 加载事件中注册音效
Events.on(MusicRegisterEvent.class, e -> {
    // 将自定义音乐添加到相应分类
    control.sound.ambientMusic.add(myCustomMusic);
    control.sound.darkMusic.add(myDarkMusic);
});
```

## 配置选项

### 用户设置集成
```java
// 音量设置
Core.settings.getInt("musicvol", 100);    // 音乐音量 (0-100)
Core.settings.getInt("ambientvol", 100);  // 环境音效音量 (0-100)
Core.settings.getBool("alwaysmusic");     // 总是播放音乐

// 音乐播放策略
if(Core.settings.getBool("alwaysmusic")) {
    if(current == null) {
        playRandom();  // 连续播放模式
    }
} else {
    // 间隔播放模式
    if(Time.timeSinceMillis(lastPlayed) > 1000 * musicInterval / 60f) {
        if(Mathf.chance(musicChance)) {
            playRandom();
        }
    }
}
```

## 调试和监控

### 音效状态查询
```java
// 检查音效播放状态
boolean isPlaying = Core.audio.isPlaying(soundID);

// 获取音效 ID (仅限 Sound 类型)
int soundId = Sounds.getSoundId(someSound);
Sound sound = Sounds.getSound(soundId);
```

### 总线状态监控
```java
// 暂停状态控制
Core.audio.setPaused(Core.audio.soundBus.id, state.isPaused());

// 滤波器参数调试
Core.audio.soundBus.setFilterParam(0, Filters.paramWet, wetValue);
```

这个音频系统为 Mindustry 提供了丰富的听觉体验，通过智能的音乐切换、精确的 3D 空间音效和高效的性能优化，创造了沉浸式的游戏环境。